{"file_contents":{"app.py":{"content":"import os\nimport logging\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom config import get_config\n\n# Configure logging based on environment\nconfig_class = get_config()\nlog_level = logging.DEBUG if not config_class.IS_PRODUCTION else logging.INFO\nlogging.basicConfig(\n    level=log_level,\n    format='%(asctime)s %(levelname)s %(name)s: %(message)s'\n)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\n# Create the app\napp = Flask(__name__)\n\n# Load configuration\nconfig_obj = get_config()\napp.config.from_object(config_obj)\n\n# Production-ready security configuration\nif not app.config['SECRET_KEY'] or app.config['SECRET_KEY'] == 'dev-secret-key-change-in-production':\n    if config_obj.IS_PRODUCTION:\n        raise ValueError(\"SESSION_SECRET environment variable is required in production!\")\n\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Add template global for CDN-aware static URLs\n@app.template_global()\ndef static_url(filename):\n    \"\"\"Template function for CDN-aware static URLs\"\"\"\n    return config_obj.get_static_url(filename)\n\n# Initialize the app with the extension\ndb.init_app(app)\n\nwith app.app_context():\n    # Import models to ensure tables are created\n    import models\n    db.create_all()\n\n# Import routes\nimport routes\n","size_bytes":1392},"main.py":{"content":"from app import app\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n","size_bytes":99},"models.py":{"content":"from app import db\nfrom datetime import datetime\nfrom sqlalchemy import func\n\nclass TradingConfig(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    # Basic trading parameters\n    spread_threshold = db.Column(db.Float, default=0.003)\n    trade_amount = db.Column(db.Float, default=100.0)\n    daily_max_volume = db.Column(db.Float, default=5000.0)\n    risk_buffer = db.Column(db.Float, default=0.1)\n    max_pending_orders = db.Column(db.Integer, default=3)\n    \n    # Enhanced risk management\n    max_daily_loss = db.Column(db.Float, default=100.0)  # Max daily loss limit\n    volatility_multiplier = db.Column(db.Float, default=1.0)  # Position size adjustment for volatility\n    circuit_breaker_enabled = db.Column(db.Boolean, default=True)\n    api_rate_limit = db.Column(db.Integer, default=10)  # API calls per minute\n    slippage_tolerance = db.Column(db.Float, default=0.001)  # 0.1% slippage tolerance\n    \n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'spread_threshold': self.spread_threshold,\n            'trade_amount': self.trade_amount,\n            'daily_max_volume': self.daily_max_volume,\n            'risk_buffer': self.risk_buffer,\n            'max_pending_orders': self.max_pending_orders,\n            'max_daily_loss': self.max_daily_loss,\n            'volatility_multiplier': self.volatility_multiplier,\n            'circuit_breaker_enabled': self.circuit_breaker_enabled,\n            'api_rate_limit': self.api_rate_limit,\n            'slippage_tolerance': self.slippage_tolerance,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n\nclass Trade(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    trade_type = db.Column(db.String(20), nullable=False)  # 'buy' or 'sell'\n    pair = db.Column(db.String(20), nullable=False)  # 'XRP/USDT' or 'XRP/USDC'\n    amount = db.Column(db.Float, nullable=False)\n    price = db.Column(db.Float, nullable=False)\n    total_value = db.Column(db.Float, nullable=False)\n    spread = db.Column(db.Float)\n    profit_loss = db.Column(db.Float)\n    status = db.Column(db.String(20), default='pending')  # 'pending', 'completed', 'failed'\n    order_id = db.Column(db.String(100))\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    completed_at = db.Column(db.DateTime)\n\nclass Balance(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    currency = db.Column(db.String(10), nullable=False)  # 'XRP', 'USDT', 'USDC'\n    amount = db.Column(db.Float, nullable=False, default=0.0)\n    locked = db.Column(db.Float, nullable=False, default=0.0)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass PriceHistory(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    pair = db.Column(db.String(20), nullable=False)\n    price = db.Column(db.Float, nullable=False)\n    volume = db.Column(db.Float)\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n\nclass ArbitrageOpportunity(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    usdt_price = db.Column(db.Float, nullable=False)\n    usdc_price = db.Column(db.Float, nullable=False)\n    spread = db.Column(db.Float, nullable=False)\n    spread_percentage = db.Column(db.Float, nullable=False)\n    opportunity_type = db.Column(db.String(20))  # 'buy_usdt_sell_usdc' or 'buy_usdc_sell_usdt'\n    executed = db.Column(db.Boolean, default=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\nclass SystemLog(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    level = db.Column(db.String(20), nullable=False)  # 'INFO', 'WARNING', 'ERROR'\n    message = db.Column(db.Text, nullable=False)\n    module = db.Column(db.String(50))\n    error_details = db.Column(db.Text)\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'level': self.level,\n            'message': self.message,\n            'module': self.module,\n            'error_details': self.error_details,\n            'timestamp': self.timestamp.isoformat() if self.timestamp else None\n        }\n\nclass DailyVolume(db.Model):\n    \"\"\"Daily trading volume tracking\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    trade_date = db.Column(db.Date, nullable=False, default=lambda: datetime.utcnow().date())\n    total_volume_usd = db.Column(db.Float, default=0.0)\n    trade_count = db.Column(db.Integer, default=0)\n    profit_loss = db.Column(db.Float, default=0.0)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Ensure one record per date\n    __table_args__ = (db.UniqueConstraint('trade_date'),)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'trade_date': self.trade_date.isoformat() if self.trade_date else None,\n            'total_volume_usd': self.total_volume_usd,\n            'trade_count': self.trade_count,\n            'profit_loss': self.profit_loss,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n\nclass CircuitBreaker(db.Model):\n    \"\"\"Circuit breaker status tracking\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    breaker_type = db.Column(db.String(50), nullable=False)  # 'daily_loss', 'system_error', 'api_error'\n    is_active = db.Column(db.Boolean, default=False)\n    trigger_reason = db.Column(db.Text)\n    trigger_value = db.Column(db.Float)\n    threshold_value = db.Column(db.Float)\n    activated_at = db.Column(db.DateTime)\n    reset_at = db.Column(db.DateTime)\n    auto_reset = db.Column(db.Boolean, default=True)\n    reset_after_minutes = db.Column(db.Integer, default=60)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'breaker_type': self.breaker_type,\n            'is_active': self.is_active,\n            'trigger_reason': self.trigger_reason,\n            'trigger_value': self.trigger_value,\n            'threshold_value': self.threshold_value,\n            'activated_at': self.activated_at.isoformat() if self.activated_at else None,\n            'reset_at': self.reset_at.isoformat() if self.reset_at else None,\n            'auto_reset': self.auto_reset,\n            'reset_after_minutes': self.reset_after_minutes\n        }\n","size_bytes":6690},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"ccxt>=4.5.3\",\n    \"email-validator>=2.3.0\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"numpy>=2.3.2\",\n    \"pandas>=2.3.2\",\n    \"psutil>=7.1.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-dateutil>=2.9.0.post0\",\n    \"requests>=2.32.5\",\n    \"sqlalchemy>=2.0.43\",\n    \"websockets>=15.0.1\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":496},"replit.md":{"content":"# XRP Arbitrage Trading System\n\n## Overview\n\nThis is a modular XRP arbitrage trading system built with Flask that monitors price differences between XRP/USDT and XRP/USDC trading pairs to identify and execute profitable arbitrage opportunities. The system features a web-based interface with real-time monitoring, trading analytics, and comprehensive risk management. It simulates trading operations with the MEXC exchange API and implements a \"sell-first\" trading strategy to minimize risk exposure.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Framework\n- **Flask**: Web application framework handling HTTP requests and responses\n- **SQLAlchemy**: Database ORM for managing trading data, balances, and configuration\n- **SQLite**: Default database for development with PostgreSQL support via environment variables\n\n### Modular Core Components\n- **Price Monitor**: Background thread monitoring XRP price feeds for both USDT and USDC pairs\n- **Balance Manager**: Tracks wallet balances across XRP, USDT, and USDC currencies with locked/free amounts\n- **Trade Executor**: Implements sell-first arbitrage strategy with order management\n- **Risk Controller**: Validates trades against daily volume limits, balance safety margins, and volatility thresholds\n- **Arbitrage Engine**: Main strategy engine coordinating price monitoring, opportunity detection, and trade execution\n- **Data Logger**: Comprehensive logging system for trades, system events, and error tracking\n\n### Business Logic Layer\n- **Trading Strategy**: Advanced decision logic using multiple factors (spread size, market volatility, historical success rate)\n- **Data Pipeline**: Analytics processing for trading performance metrics and opportunity analysis\n- **Profit Analyzer**: Real-time and historical profit/loss calculations with success rate tracking\n\n### Web Interface Architecture\n- **Dashboard**: Main control panel showing real-time prices, spreads, balances, and trading controls\n- **Monitor**: Dedicated trading activity feed with comprehensive analytics and performance charts\n- **Configuration**: Settings management for trading parameters and risk controls\n- **RESTful API**: JSON endpoints for real-time data updates and trading operations\n\n### Database Schema\n- **TradingConfig**: System configuration with spread thresholds, trade amounts, and risk parameters\n- **Trade**: Individual trade records with execution details, P&L, and status tracking\n- **Balance**: Real-time balance tracking for all currencies with locked amounts\n- **PriceHistory**: Historical price data for trend analysis\n- **ArbitrageOpportunity**: Detected opportunities with spread calculations and execution status\n\n### Frontend Architecture\n- **Bootstrap 5**: Dark-themed responsive UI optimized for trading terminals\n- **Chart.js**: Real-time price charts and analytics visualizations\n- **WebSocket-ready**: Architecture prepared for real-time data streaming\n- **Modular JavaScript**: Separate modules for dashboard, monitor, and chart functionality\n\n## External Dependencies\n\n### Core Dependencies\n- **Flask**: Web framework and request handling\n- **SQLAlchemy**: Database ORM and connection management\n- **Werkzeug**: WSGI utilities and development server\n\n### Frontend Libraries\n- **Bootstrap 5**: UI framework and responsive design\n- **Chart.js**: Data visualization and trading charts\n- **Font Awesome**: Icon library for trading interface\n\n### Development Tools\n- **Python Logging**: Comprehensive system and trade logging\n- **Threading**: Background price monitoring and trade execution\n\n### Planned Integrations\n- **MEXC Exchange API**: Live market data and trade execution (currently simulated)\n- **PostgreSQL**: Production database (configurable via DATABASE_URL environment variable)\n- **WebSocket**: Real-time data streaming for live price updates\n\n### Configuration Management\n- **Environment Variables**: Database URLs, API keys, and deployment settings\n- **Session Management**: User preferences and trading state persistence\n- **Proxy Support**: Production deployment compatibility with reverse proxies\n\nThe system is designed for easy deployment on cloud platforms with environment-based configuration and supports both development (SQLite) and production (PostgreSQL) database configurations.","size_bytes":4335},"routes.py":{"content":"from flask import render_template, jsonify, request, redirect, url_for, flash\nfrom app import app, db\nfrom models import TradingConfig, Trade, Balance, PriceHistory, ArbitrageOpportunity, SystemLog\nfrom datetime import datetime, timedelta\nfrom core.price_monitor import PriceMonitor\nfrom core.balance_manager import BalanceManager\nfrom core.trade_executor import TradeExecutor\nfrom core.profit_analyzer import ProfitAnalyzer\nfrom core.config_manager import ConfigManager\nfrom business.arbitrage_engine import ArbitrageEngine\nimport json\nimport os\nimport psutil\nfrom sqlalchemy import text\n\n# Initialize core modules (will be done lazily)\nprice_monitor = None\nbalance_manager = None\ntrade_executor = None\nprofit_analyzer = None\nconfig_manager = None\narbitrage_engine = None\n\ndef get_core_modules():\n    global price_monitor, balance_manager, trade_executor, profit_analyzer, config_manager, arbitrage_engine\n    if price_monitor is None:\n        from core.price_monitor import PriceMonitor\n        from core.balance_manager import BalanceManager\n        from core.trade_executor import TradeExecutor\n        from core.profit_analyzer import ProfitAnalyzer\n        from core.config_manager import ConfigManager\n        from business.arbitrage_engine import ArbitrageEngine\n        \n        price_monitor = PriceMonitor()\n        balance_manager = BalanceManager()\n        trade_executor = TradeExecutor()\n        profit_analyzer = ProfitAnalyzer()\n        config_manager = ConfigManager()\n        arbitrage_engine = ArbitrageEngine()\n    \n    return price_monitor, balance_manager, trade_executor, profit_analyzer, config_manager, arbitrage_engine\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Railway/production health check endpoint\"\"\"\n    try:\n        # Check database connectivity\n        db_status = \"healthy\"\n        try:\n            result = db.session.execute(text(\"SELECT 1\"))\n            result.fetchone()\n        except Exception as e:\n            db_status = f\"unhealthy: {str(e)}\"\n        \n        # Check system resources (optimized for load balancers)\n        memory_usage = psutil.virtual_memory().percent\n        cpu_usage = psutil.cpu_percent(interval=None)  # Non-blocking\n        disk_usage = psutil.disk_usage('/').percent\n        \n        # Basic system health\n        health_data = {\n            \"status\": \"healthy\" if db_status == \"healthy\" else \"degraded\",\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"version\": \"1.0.0\",\n            \"services\": {\n                \"database\": db_status,\n                \"price_monitor\": \"active\",\n                \"websocket\": \"active\"\n            },\n            \"metrics\": {\n                \"memory_usage_percent\": memory_usage,\n                \"cpu_usage_percent\": cpu_usage,\n                \"disk_usage_percent\": disk_usage\n            },\n            \"environment\": os.environ.get(\"RAILWAY_ENVIRONMENT\", \"development\")\n        }\n        \n        # Return appropriate HTTP status\n        status_code = 200 if health_data[\"status\"] == \"healthy\" else 503\n        return jsonify(health_data), status_code\n        \n    except Exception as e:\n        return jsonify({\n            \"status\": \"unhealthy\",\n            \"error\": str(e),\n            \"timestamp\": datetime.utcnow().isoformat()\n        }), 503\n\n@app.route('/health/simple')\ndef simple_health():\n    \"\"\"Simple health check for load balancers\"\"\"\n    return \"OK\", 200\n\n@app.route('/')\ndef dashboard():\n    \"\"\"Main trading dashboard\"\"\"\n    modules = get_core_modules()\n    config = modules[4].get_config()\n    balances = modules[1].get_balances()\n    today_stats = modules[3].get_today_stats()\n    \n    return render_template('dashboard.html', \n                         config=config, \n                         balances=balances, \n                         today_stats=today_stats)\n\n@app.route('/monitor')\ndef monitor():\n    \"\"\"Trading monitor window\"\"\"\n    recent_trades = Trade.query.order_by(Trade.created_at.desc()).limit(50).all()\n    modules = get_core_modules()\n    profit_stats = modules[3].get_comprehensive_stats()\n    \n    return render_template('monitor.html', \n                         recent_trades=recent_trades, \n                         profit_stats=profit_stats)\n\n@app.route('/config', methods=['GET', 'POST'])\ndef config():\n    \"\"\"Configuration management\"\"\"\n    modules = get_core_modules()\n    config_manager = modules[4]\n    if request.method == 'POST':\n        config_manager.update_config({\n            'spread_threshold': float(request.form.get('spread_threshold', 0.003)),\n            'trade_amount': float(request.form.get('trade_amount', 100.0)),\n            'daily_max_volume': float(request.form.get('daily_max_volume', 5000.0)),\n            'risk_buffer': float(request.form.get('risk_buffer', 0.1)),\n            'max_pending_orders': int(request.form.get('max_pending_orders', 3))\n        })\n        flash('Configuration updated successfully!', 'success')\n        return redirect(url_for('config'))\n    \n    current_config = config_manager.get_config()\n    return render_template('config.html', config=current_config)\n\n@app.route('/api/prices')\ndef api_prices():\n    \"\"\"Get current XRP prices\"\"\"\n    modules = get_core_modules()\n    prices = modules[0].get_current_prices()\n    return jsonify(prices)\n\n@app.route('/api/balances')\ndef api_balances():\n    \"\"\"Get current balances\"\"\"\n    modules = get_core_modules()\n    balances = modules[1].get_balances()\n    return jsonify(balances)\n\n@app.route('/api/trades/recent')\ndef api_recent_trades():\n    \"\"\"Get recent trades\"\"\"\n    limit = request.args.get('limit', 20, type=int)\n    trades = Trade.query.order_by(Trade.created_at.desc()).limit(limit).all()\n    \n    trades_data = []\n    for trade in trades:\n        trades_data.append({\n            'id': trade.id,\n            'type': trade.trade_type,\n            'pair': trade.pair,\n            'amount': trade.amount,\n            'price': trade.price,\n            'total_value': trade.total_value,\n            'profit_loss': trade.profit_loss,\n            'status': trade.status,\n            'created_at': trade.created_at.isoformat() if trade.created_at else None\n        })\n    \n    return jsonify(trades_data)\n\n@app.route('/api/profit/stats')\ndef api_profit_stats():\n    \"\"\"Get profit/loss statistics\"\"\"\n    modules = get_core_modules()\n    stats = modules[3].get_comprehensive_stats()\n    return jsonify(stats)\n\n@app.route('/api/chart/price-history')\ndef api_price_history():\n    \"\"\"Get price history for charts\"\"\"\n    hours = request.args.get('hours', 24, type=int)\n    since = datetime.utcnow() - timedelta(hours=hours)\n    \n    usdt_history = PriceHistory.query.filter(\n        PriceHistory.pair == 'XRP/USDT',\n        PriceHistory.timestamp >= since\n    ).order_by(PriceHistory.timestamp).all()\n    \n    usdc_history = PriceHistory.query.filter(\n        PriceHistory.pair == 'XRP/USDC',\n        PriceHistory.timestamp >= since\n    ).order_by(PriceHistory.timestamp).all()\n    \n    data = {\n        'usdt': [{'time': p.timestamp.isoformat(), 'price': p.price} for p in usdt_history],\n        'usdc': [{'time': p.timestamp.isoformat(), 'price': p.price} for p in usdc_history]\n    }\n    \n    return jsonify(data)\n\n@app.route('/api/chart/profit-trend')\ndef api_profit_trend():\n    \"\"\"Get profit trend for charts\"\"\"\n    days = request.args.get('days', 7, type=int)\n    since = datetime.utcnow() - timedelta(days=days)\n    \n    trades = Trade.query.filter(\n        Trade.created_at >= since,\n        Trade.status == 'completed',\n        Trade.profit_loss.isnot(None)\n    ).order_by(Trade.created_at).all()\n    \n    cumulative_profit = 0\n    data = []\n    \n    for trade in trades:\n        cumulative_profit += trade.profit_loss or 0\n        data.append({\n            'time': trade.created_at.isoformat(),\n            'profit': trade.profit_loss,\n            'cumulative': cumulative_profit\n        })\n    \n    return jsonify(data)\n\n@app.route('/api/start-trading', methods=['POST'])\ndef api_start_trading():\n    \"\"\"Start automated trading\"\"\"\n    try:\n        modules = get_core_modules()\n        # Initialize balances if not exists\n        modules[1].initialize_balances()\n        \n        # Start the arbitrage engine\n        modules[5].start()\n        \n        # Log the action\n        log = SystemLog(level='INFO', message='Trading started', module='API')\n        db.session.add(log)\n        db.session.commit()\n        \n        return jsonify({'success': True, 'message': 'Trading started successfully'})\n    except Exception as e:\n        return jsonify({'success': False, 'message': str(e)}), 500\n\n@app.route('/api/stop-trading', methods=['POST'])\ndef api_stop_trading():\n    \"\"\"Stop automated trading\"\"\"\n    try:\n        modules = get_core_modules()\n        modules[5].stop()\n        \n        # Log the action\n        log = SystemLog(level='INFO', message='Trading stopped', module='API')\n        db.session.add(log)\n        db.session.commit()\n        \n        return jsonify({'success': True, 'message': 'Trading stopped successfully'})\n    except Exception as e:\n        return jsonify({'success': False, 'message': str(e)}), 500\n\n@app.route('/api/opportunities')\ndef api_opportunities():\n    \"\"\"Get current arbitrage opportunities\"\"\"\n    opportunities = ArbitrageOpportunity.query.filter(\n        ArbitrageOpportunity.executed == False\n    ).order_by(ArbitrageOpportunity.created_at.desc()).limit(10).all()\n    \n    data = []\n    for opp in opportunities:\n        data.append({\n            'id': opp.id,\n            'usdt_price': opp.usdt_price,\n            'usdc_price': opp.usdc_price,\n            'spread': opp.spread,\n            'spread_percentage': opp.spread_percentage,\n            'opportunity_type': opp.opportunity_type,\n            'created_at': opp.created_at.isoformat()\n        })\n    \n    return jsonify(data)\n\n@app.route('/api/system-status')\ndef api_system_status():\n    \"\"\"Get system status\"\"\"\n    modules = get_core_modules()\n    status = {\n        'trading_active': modules[5].is_running(),\n        'api_connected': True,  # In simulation, always connected\n        'last_price_update': modules[0].get_last_update(),\n        'pending_orders': Trade.query.filter(Trade.status == 'pending').count(),\n        'system_time': datetime.utcnow().isoformat()\n    }\n    \n    return jsonify(status)\n","size_bytes":10285},"attached_assets/content-1758457887834.md":{"content":"","size_bytes":0},"business/arbitrage_engine.py":{"content":"import time\nimport threading\nimport logging\nfrom datetime import datetime\nfrom app import db\nfrom models import ArbitrageOpportunity, TradingConfig\nfrom core.price_monitor import PriceMonitor\nfrom core.balance_manager import BalanceManager\nfrom core.trade_executor import TradeExecutor\nfrom core.risk_controller import RiskController\nfrom core.data_logger import DataLogger\nfrom core.config_manager import ConfigManager\nfrom core.order_manager import OrderManager\nfrom core.websocket_manager import WebSocketManager\nfrom core.advanced_analytics import AdvancedAnalytics\nfrom core.latency_optimizer import LatencyOptimizer\n\nclass ArbitrageEngine:\n    \"\"\"🚀 终极专业套利引擎 - AI驱动的毫秒级交易系统\"\"\"\n    \n    def __init__(self):\n        self.running = False\n        self.thread = None\n        self.logger = logging.getLogger(__name__)\n        \n        # 核心交易组件\n        self.price_monitor = PriceMonitor()\n        self.balance_manager = BalanceManager()\n        self.trade_executor = TradeExecutor()\n        self.risk_controller = RiskController()\n        self.data_logger = DataLogger()\n        self.config_manager = ConfigManager()\n        \n        # 🆕 专业增强组件\n        self.order_manager = OrderManager()\n        self.websocket_manager = WebSocketManager()\n        self.advanced_analytics = AdvancedAnalytics()\n        self.latency_optimizer = LatencyOptimizer()\n        \n        # 性能统计\n        self.total_opportunities = 0\n        self.executed_trades = 0\n        self.total_profit = 0.0\n        self.engine_start_time = None\n        \n        # 启动所有组件\n        self._initialize_all_components()\n    \n    def _initialize_all_components(self):\n        \"\"\"初始化所有专业组件\"\"\"\n        try:\n            # 启动价格监控\n            self.price_monitor.start_monitoring()\n            \n            # 启动订单管理器\n            self.order_manager.start_monitoring()\n            \n            # 启动WebSocket数据流\n            self.websocket_manager.start()\n            \n            # 注册WebSocket价格回调\n            self.websocket_manager.add_price_callback(self._on_websocket_price_update)\n            \n            self.logger.info(\"🚀 所有专业组件已初始化\")\n            \n        except Exception as e:\n            self.logger.error(f\"组件初始化失败: {e}\")\n    \n    def _on_websocket_price_update(self, symbol: str, price_data: dict):\n        \"\"\"WebSocket价格更新回调\"\"\"\n        try:\n            # 更新高级分析数据\n            self.advanced_analytics.update_price_data(\n                symbol, \n                price_data['price'], \n                price_data['volume']\n            )\n            \n            # 触发超快速价差检查\n            if symbol in ['XRP/USDT', 'XRP/USDC']:\n                self._fast_spread_check()\n                \n        except Exception as e:\n            self.logger.error(f\"WebSocket价格更新处理失败: {e}\")\n    \n    def start(self):\n        \"\"\"🚀 启动终极专业套利引擎\"\"\"\n        if self.running:\n            self.logger.warning(\"专业套利引擎已在运行\")\n            return\n        \n        self.running = True\n        self.engine_start_time = datetime.utcnow()\n        self.thread = threading.Thread(target=self._professional_main_loop)\n        self.thread.daemon = True\n        self.thread.start()\n        \n        self.data_logger.log_system_event(\"PROFESSIONAL_ENGINE_STARTED\", \"专业套利引擎已启动\", \"ArbitrageEngine\")\n        self.logger.info(\"🚀 专业套利引擎已启动 - 毫秒级AI驱动交易\")\n    \n    def stop(self):\n        \"\"\"🛑 停止专业套利引擎\"\"\"\n        if not self.running:\n            return\n        \n        self.running = False\n        if self.thread:\n            self.thread.join()\n        \n        # 停止所有专业组件\n        self.order_manager.stop_monitoring()\n        self.websocket_manager.stop()\n        self.latency_optimizer.shutdown()\n        \n        # 强制取消所有待处理订单\n        cancelled_orders = self.order_manager.force_cancel_all_pending()\n        \n        # 生成最终报告\n        final_report = self._generate_final_report()\n        \n        self.data_logger.log_system_event(\"PROFESSIONAL_ENGINE_STOPPED\", f\"专业套利引擎已停止 - {final_report}\", \"ArbitrageEngine\")\n        self.logger.info(f\"🛑 专业套利引擎已停止 - 取消了{cancelled_orders['cancelled']}个订单\")\n    \n    def _fast_spread_check(self):\n        \"\"\"⚡ 超快速价差检查（WebSocket触发）\"\"\"\n        try:\n            # 使用WebSocket的最新价格\n            latest_prices = self.websocket_manager.get_latest_prices()\n            \n            if 'XRP/USDT' in latest_prices and 'XRP/USDC' in latest_prices:\n                usdt_price = latest_prices['XRP/USDT']['price']\n                usdc_price = latest_prices['XRP/USDC']['price']\n                \n                # 超快速价差计算\n                spread_data = self.latency_optimizer.calculate_spread_fast(usdt_price, usdc_price)\n                \n                if spread_data['valid'] and spread_data['spread_pct'] > 0.3:  # 0.3%以上价差\n                    self.logger.debug(f\"⚡ 快速价差检测: {spread_data['spread_pct']:.4f}%\")\n                    \n                    # 触发快速机会检测\n                    config = self.config_manager.get_config()\n                    if config and spread_data['spread_pct'] > config.spread_threshold * 100:\n                        opportunity = self._create_fast_opportunity(usdt_price, usdc_price, spread_data)\n                        \n                        # 快速AI分析\n                        prediction = self.advanced_analytics.predict_next_spread()\n                        if prediction.get('confidence', 0) > 0.7:\n                            self._execute_opportunity_ultra_fast(opportunity, config)\n                \n        except Exception as e:\n            self.logger.error(f\"快速价差检查失败: {e}\")\n    \n    def _create_fast_opportunity(self, usdt_price: float, usdc_price: float, spread_data: dict) -> dict:\n        \"\"\"创建快速机会对象\"\"\"\n        try:\n            if usdt_price > usdc_price:\n                opportunity_type = 'sell_usdt_buy_usdc'\n                sell_pair = 'XRP/USDT'\n                buy_pair = 'XRP/USDC'\n                sell_price = usdt_price\n                buy_price = usdc_price\n            else:\n                opportunity_type = 'sell_usdc_buy_usdt'\n                sell_pair = 'XRP/USDC'\n                buy_pair = 'XRP/USDT'\n                sell_price = usdc_price\n                buy_price = usdt_price\n            \n            # 快速计算交易数量\n            config = self.config_manager.get_config()\n            trade_amount = min(config.trade_amount, 200.0)  # 快速交易限制200 XRP\n            \n            return {\n                'usdt_price': usdt_price,\n                'usdc_price': usdc_price,\n                'spread': spread_data['spread'],\n                'spread_percentage': spread_data['spread_pct'],\n                'opportunity_type': opportunity_type,\n                'sell_pair': sell_pair,\n                'buy_pair': buy_pair,\n                'sell_price': sell_price,\n                'buy_price': buy_price,\n                'amount': trade_amount,\n                'estimated_profit': trade_amount * spread_data['spread'],\n                'fast_track': True,\n                'detected_at': datetime.utcnow()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"创建快速机会失败: {e}\")\n            return {}\n    \n    def _execute_opportunity_ultra_fast(self, opportunity: dict, config):\n        \"\"\"⚡ 超快速机会执行\"\"\"\n        try:\n            # 检查挂单限制\n            if not self.trade_executor.enforce_pending_orders_limit():\n                return\n            \n            # 超快速风险检查\n            if opportunity['spread_percentage'] > 0.8 and opportunity['amount'] <= 100:\n                # 使用延迟优化器的快速执行\n                execution_result = self.latency_optimizer.execute_order_fast({\n                    'symbol': opportunity['sell_pair'],\n                    'amount': opportunity['amount'],\n                    'type': 'arbitrage',\n                    'urgency': 'ultra_high'\n                })\n                \n                if execution_result.get('success'):\n                    self.logger.info(f\"⚡ 超快速套利执行成功: {opportunity['spread_percentage']:.4f}% ({execution_result.get('execution_time', 0):.2f}ms)\")\n                    \n                    # 更新分析数据\n                    self.advanced_analytics.update_execution_data({\n                        'profit_loss': opportunity['estimated_profit'],\n                        'execution_time': execution_result.get('execution_time', 0),\n                        'amount': opportunity['amount'],\n                        'success': True\n                    })\n        \n        except Exception as e:\n            self.logger.error(f\"超快速执行失败: {e}\")\n    \n    def _detect_arbitrage_opportunity_enhanced(self, config):\n        \"\"\"🧠 增强版机会检测 - AI+实时数据\"\"\"\n        try:\n            # 优先使用WebSocket数据\n            latest_prices = self.websocket_manager.get_latest_prices()\n            \n            if not latest_prices or 'XRP/USDT' not in latest_prices or 'XRP/USDC' not in latest_prices:\n                # 回退到传统价格监控\n                return self._detect_arbitrage_opportunity(config)\n            \n            usdt_data = latest_prices['XRP/USDT']\n            usdc_data = latest_prices['XRP/USDC']\n            \n            usdt_price = usdt_data['price']\n            usdc_price = usdc_data['price']\n            usdt_volume = usdt_data['volume']\n            usdc_volume = usdc_data['volume']\n            \n            # AI增强的价差计算\n            spread_data = self.latency_optimizer.calculate_spread_fast(usdt_price, usdc_price)\n            \n            if not spread_data['valid']:\n                return None\n            \n            spread_percentage = spread_data['spread_pct']\n            \n            # AI预测增强\n            prediction = self.advanced_analytics.predict_next_spread()\n            confidence_multiplier = prediction.get('confidence', 0.5)\n            \n            # 动态阈值调整\n            dynamic_threshold = config.spread_threshold * 100 * (2 - confidence_multiplier)\n            \n            if spread_percentage < dynamic_threshold:\n                return None\n            \n            # 创建增强版机会\n            return self._create_enhanced_opportunity(\n                usdt_price, usdc_price, spread_data, usdt_volume, usdc_volume, config, prediction\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"增强版机会检测失败: {e}\")\n            return self._detect_arbitrage_opportunity(config)  # 回退到原方法\n    \n    def _create_enhanced_opportunity(self, usdt_price, usdc_price, spread_data, usdt_volume, usdc_volume, config, prediction):\n        \"\"\"创建增强版套利机会\"\"\"\n        try:\n            # 基础机会数据\n            base_opportunity = self._create_fast_opportunity(usdt_price, usdc_price, spread_data)\n            \n            # AI增强数据\n            base_opportunity.update({\n                'volume_usdt': usdt_volume,\n                'volume_usdc': usdc_volume,\n                'ai_confidence': prediction.get('confidence', 0),\n                'ai_recommendation': prediction.get('recommendation', 'UNKNOWN'),\n                'trend_direction': prediction.get('trend_direction', 'sideways'),\n                'volatility_level': prediction.get('volatility_level', 'medium'),\n                'enhanced': True\n            })\n            \n            # 动态数量调整\n            confidence = prediction.get('confidence', 0.5)\n            volume_factor = min(usdt_volume, usdc_volume) / 10000  # 基于流动性\n            \n            adjusted_amount = config.trade_amount * confidence * min(1.0, volume_factor)\n            base_opportunity['amount'] = max(50.0, min(adjusted_amount, 500.0))  # 50-500 XRP范围\n            \n            return base_opportunity\n            \n        except Exception as e:\n            self.logger.error(f\"创建增强版机会失败: {e}\")\n            return {}\n    \n    def _execute_opportunity_professional(self, opportunity: dict, config, ai_analysis: dict):\n        \"\"\"🚀 专业级机会执行\"\"\"\n        try:\n            # 获取AI建议\n            ai_recommendation = ai_analysis.get('trading_recommendation', {})\n            action = ai_recommendation.get('action', 'WAIT')\n            \n            if action == 'WAIT':\n                return None\n            \n            # 执行原有的增强执行逻辑\n            return self._execute_opportunity(opportunity, config)\n            \n        except Exception as e:\n            self.logger.error(f\"专业级执行失败: {e}\")\n            return None\n    \n    def _perform_maintenance_tasks(self):\n        \"\"\"🔧 执行专业维护任务\"\"\"\n        try:\n            # 优化缓存\n            self.latency_optimizer.optimize_cache_usage()\n            \n            # 检查超时订单\n            self.order_manager._check_timeout_orders()\n            \n            # 更新性能指标\n            self.order_manager.optimize_timeout_settings()\n            \n        except Exception as e:\n            self.logger.error(f\"维护任务失败: {e}\")\n    \n    def _assess_market_activity(self) -> str:\n        \"\"\"评估市场活跃度\"\"\"\n        try:\n            # 基于最近的机会数量评估\n            if self.total_opportunities > 0:\n                recent_activity = self.total_opportunities % 100  # 简化计算\n                \n                if recent_activity > 10:\n                    return 'high'\n                elif recent_activity > 5:\n                    return 'medium'\n                else:\n                    return 'low'\n            \n            return 'low'\n            \n        except Exception as e:\n            return 'medium'\n    \n    def _calculate_optimal_sleep_time(self, market_activity: str) -> float:\n        \"\"\"计算最优休眠时间\"\"\"\n        sleep_times = {\n            'high': 1.0,    # 高活跃度：1秒\n            'medium': 2.0,  # 中等活跃度：2秒\n            'low': 3.0      # 低活跃度：3秒\n        }\n        \n        return sleep_times.get(market_activity, 2.0)\n    \n    def _generate_final_report(self) -> str:\n        \"\"\"生成最终运行报告\"\"\"\n        try:\n            if self.engine_start_time:\n                runtime = datetime.utcnow() - self.engine_start_time\n                runtime_hours = runtime.total_seconds() / 3600\n            else:\n                runtime_hours = 0\n            \n            success_rate = (self.executed_trades / self.total_opportunities * 100) if self.total_opportunities > 0 else 0\n            \n            return (f\"运行时长: {runtime_hours:.1f}h, \"\n                   f\"检测机会: {self.total_opportunities}, \"\n                   f\"执行交易: {self.executed_trades}, \"\n                   f\"成功率: {success_rate:.1f}%, \"\n                   f\"总利润: {self.total_profit:.2f}\")\n            \n        except Exception as e:\n            return f\"报告生成失败: {e}\"\n    \n    def is_running(self):\n        \"\"\"检查引擎是否运行中\"\"\"\n        return self.running\n    \n    def _professional_main_loop(self):\n        \"\"\"🧠 专业AI驱动的主循环 - 毫秒级决策\"\"\"\n        iteration_count = 0\n        \n        while self.running:\n            try:\n                iteration_start = time.perf_counter()\n                iteration_count += 1\n                \n                # 获取配置\n                config = self.config_manager.get_config()\n                if not config:\n                    self.logger.error(\"配置未找到，停止引擎\")\n                    break\n                \n                # 🔥 超快速系统健康检查\n                if iteration_count % 10 == 0:  # 每10次迭代检查一次\n                    health = self.risk_controller.check_system_health()\n                    stability = self.risk_controller.check_system_stability()\n                    \n                    if not health['healthy'] or not stability['stable']:\n                        self.logger.error(f\"系统状态异常: Health={health['healthy']}, Stability={stability['stable']}\")\n                        self.data_logger.log_risk_event(\n                            \"SYSTEM_HEALTH_CRITICAL\", \n                            f\"健康检查失败: {health['errors']}, 稳定性: {stability['stability_score']}\", \n                            \"CRITICAL\"\n                        )\n                        time.sleep(5)\n                        continue\n                \n                # 🚀 超快速机会检测\n                opportunity = self._detect_arbitrage_opportunity_enhanced(config)\n                \n                if opportunity:\n                    self.total_opportunities += 1\n                    \n                    # 🧠 AI增强决策\n                    ai_analysis = self.advanced_analytics.get_comprehensive_analysis()\n                    ai_recommendation = ai_analysis.get('trading_recommendation', {})\n                    \n                    self.logger.info(f\"💡 AI检测到机会: {opportunity['spread_percentage']:.4f}% - AI建议: {ai_recommendation.get('action', 'UNKNOWN')}\")\n                    \n                    # 更新分析数据\n                    self.advanced_analytics.update_spread_data(\n                        opportunity['usdt_price'],\n                        opportunity['usdc_price'],\n                        opportunity['spread_percentage']\n                    )\n                    \n                    # 存储机会\n                    self._store_opportunity(opportunity)\n                    \n                    # ⚡ 超快速执行决策\n                    if ai_recommendation.get('action') in ['EXECUTE_IMMEDIATELY', 'EXECUTE_CAUTIOUSLY']:\n                        execution_result = self._execute_opportunity_professional(opportunity, config, ai_analysis)\n                        \n                        if execution_result:\n                            self.executed_trades += 1\n                            self.total_profit += execution_result.get('profit_loss', 0)\n                \n                # 🔧 专业维护任务\n                if iteration_count % 5 == 0:  # 每5次迭代\n                    self._perform_maintenance_tasks()\n                \n                # ⚡ 动态睡眠 - 基于市场活跃度\n                market_activity = self._assess_market_activity()\n                sleep_time = self._calculate_optimal_sleep_time(market_activity)\n                \n                iteration_time = (time.perf_counter() - iteration_start) * 1000\n                self.logger.debug(f\"⚡ 迭代 {iteration_count}: {iteration_time:.2f}ms, 休眠: {sleep_time:.1f}s\")\n                \n                time.sleep(sleep_time)\n                \n            except Exception as e:\n                self.logger.error(f\"专业主循环错误: {e}\")\n                self.data_logger.log_error(f\"专业主循环错误: {e}\", \"ArbitrageEngine\", e)\n                time.sleep(3)  # 错误时短暂休眠\n    \n    def _detect_arbitrage_opportunity(self, config):\n        \"\"\"Detect directional arbitrage opportunities with improved logic\"\"\"\n        try:\n            # Get current prices\n            prices = self.price_monitor.get_current_prices()\n            \n            if 'XRP/USDT' not in prices or 'XRP/USDC' not in prices:\n                return None\n            \n            usdt_price = prices['XRP/USDT']['price']\n            usdc_price = prices['XRP/USDC']['price']\n            usdt_volume = prices['XRP/USDT']['volume']\n            usdc_volume = prices['XRP/USDC']['volume']\n            \n            # IMPROVED DIRECTIONAL ARBITRAGE LOGIC\n            # Calculate percentage spread (not just absolute)\n            if usdt_price > usdc_price:\n                # USDT is higher, sell XRP/USDT, buy XRP/USDC\n                spread_percentage = ((usdt_price - usdc_price) / usdc_price) * 100\n                opportunity_type = 'sell_usdt_buy_usdc'\n                sell_pair = 'XRP/USDT'\n                buy_pair = 'XRP/USDC'\n                sell_price = usdt_price\n                buy_price = usdc_price\n                higher_price = usdt_price\n                lower_price = usdc_price\n            else:\n                # USDC is higher, sell XRP/USDC, buy XRP/USDT  \n                spread_percentage = ((usdc_price - usdt_price) / usdt_price) * 100\n                opportunity_type = 'sell_usdc_buy_usdt'\n                sell_pair = 'XRP/USDC'\n                buy_pair = 'XRP/USDT'\n                sell_price = usdc_price\n                buy_price = usdt_price\n                higher_price = usdc_price\n                lower_price = usdt_price\n            \n            spread = higher_price - lower_price\n            \n            # Enhanced threshold check with minimum profitable spread\n            minimum_profitable_spread = 0.08  # 0.08% minimum after fees\n            if spread_percentage < max(config.spread_threshold * 100, minimum_profitable_spread):\n                return None\n            \n            # Volume validation - ensure sufficient liquidity\n            min_volume_24h = 1000.0  # Minimum 24h volume\n            if usdt_volume < min_volume_24h or usdc_volume < min_volume_24h:\n                self.logger.debug(f\"Insufficient volume: USDT={usdt_volume}, USDC={usdc_volume}\")\n                return None\n            \n            # Calculate safe trade amount with volatility consideration\n            max_safe_amount = self.risk_controller.calculate_max_safe_trade_amount(config)\n            \n            # Adjust trade amount based on spread size (larger spreads allow larger trades)\n            spread_multiplier = min(2.0, spread_percentage / 0.3)  # Scale up to 2x for large spreads\n            adjusted_base_amount = config.trade_amount * spread_multiplier\n            \n            trade_amount = min(adjusted_base_amount, max_safe_amount)\n            \n            if trade_amount <= 0:\n                self.logger.warning(\"No safe trade amount available\")\n                return None\n            \n            # Enhanced profit estimation with fee consideration\n            gross_profit = trade_amount * spread\n            estimated_fees = trade_amount * (sell_price + buy_price) * 0.0006  # 0.06% taker fee both sides\n            estimated_net_profit = gross_profit - estimated_fees\n            \n            # Minimum profit threshold\n            min_profit_threshold = 0.10  # Minimum $0.10 profit\n            if estimated_net_profit < min_profit_threshold:\n                self.logger.debug(f\"Profit too small: {estimated_net_profit:.4f} < {min_profit_threshold}\")\n                return None\n            \n            opportunity = {\n                'usdt_price': usdt_price,\n                'usdc_price': usdc_price,\n                'spread': spread,\n                'spread_percentage': spread_percentage,\n                'opportunity_type': opportunity_type,\n                'sell_pair': sell_pair,\n                'buy_pair': buy_pair,\n                'sell_price': sell_price,\n                'buy_price': buy_price,\n                'amount': trade_amount,\n                'estimated_profit': estimated_net_profit,\n                'gross_profit': gross_profit,\n                'estimated_fees': estimated_fees,\n                'volume_usdt': usdt_volume,\n                'volume_usdc': usdc_volume,\n                'spread_multiplier': spread_multiplier\n            }\n            \n            return opportunity\n            \n        except Exception as e:\n            self.logger.error(f\"Error detecting arbitrage opportunity: {e}\")\n            return None\n    \n    def _store_opportunity(self, opportunity):\n        \"\"\"Store arbitrage opportunity in database\"\"\"\n        try:\n            db_opportunity = ArbitrageOpportunity(\n                usdt_price=opportunity['usdt_price'],\n                usdc_price=opportunity['usdc_price'],\n                spread=opportunity['spread'],\n                spread_percentage=opportunity['spread_percentage'],\n                opportunity_type=opportunity['opportunity_type'],\n                executed=False\n            )\n            \n            db.session.add(db_opportunity)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error storing opportunity: {e}\")\n            db.session.rollback()\n    \n    def _execute_opportunity(self, opportunity, config):\n        \"\"\"Execute arbitrage opportunity with enhanced risk checks\"\"\"\n        try:\n            # Perform comprehensive risk check with volatility adjustment\n            risk_check = self.risk_controller.check_trade_risk(opportunity, config)\n            \n            if not risk_check['safe']:\n                self.logger.warning(f\"Trade blocked by risk check: {risk_check['reason']}\")\n                self.data_logger.log_risk_event(\n                    \"TRADE_BLOCKED\", \n                    risk_check['reason'], \n                    \"WARNING\"\n                )\n                return\n            \n            # Use the volatility-adjusted amount from risk check\n            adjusted_amount = risk_check['adjusted_amount']\n            if adjusted_amount != opportunity['amount']:\n                self.logger.info(f\"Position size adjusted for volatility: {opportunity['amount']:.2f} -> {adjusted_amount:.2f} XRP\")\n                opportunity['amount'] = adjusted_amount\n            \n            # Execute the arbitrage trade\n            self.logger.info(f\"Executing ATOMIC arbitrage trade: {opportunity['amount']} XRP\")\n            \n            trade_result = self.trade_executor.execute_arbitrage_trade(opportunity)\n            \n            if trade_result:\n                # Track volume and profit/loss\n                trade_value_usd = opportunity['amount'] * opportunity['sell_price']\n                profit_loss = trade_result.get('profit_loss', 0)\n                \n                self.volume_tracker.track_trade_volume(trade_value_usd, profit_loss)\n                \n                # Mark opportunity as executed\n                self._mark_opportunity_executed(opportunity)\n                \n                self.logger.info(f\"ATOMIC arbitrage completed with P&L: {profit_loss:.4f}\")\n                \n                self.data_logger.log_trade({\n                    'type': 'atomic_arbitrage',\n                    'amount': opportunity['amount'],\n                    'profit_loss': profit_loss,\n                    'spread': opportunity['spread_percentage'],\n                    'execution_type': trade_result.get('execution_type', 'atomic'),\n                    'slippage': trade_result.get('slippage', {})\n                }, 'completed')\n                \n                # Check if we need to activate any circuit breakers based on performance\n                if profit_loss < -50:  # Large single trade loss\n                    self.risk_controller.volume_tracker.activate_circuit_breaker(\n                        'large_loss',\n                        f'Large single trade loss: ${abs(profit_loss):.2f}',\n                        abs(profit_loss),\n                        50.0\n                    )\n                \n            else:\n                self.logger.error(\"ATOMIC arbitrage trade execution failed\")\n                self.data_logger.log_error(\"ATOMIC arbitrage trade execution failed\", \"ArbitrageEngine\")\n                \n                # Track failed execution (might indicate system issues)\n                self.risk_controller.volume_tracker.activate_circuit_breaker(\n                    'execution_failure',\n                    'Multiple trade execution failures detected',\n                    None,\n                    None\n                )\n            \n        except Exception as e:\n            self.logger.error(f\"Error executing opportunity: {e}\")\n            self.data_logger.log_error(f\"Opportunity execution error: {e}\", \"ArbitrageEngine\", e)\n            \n            # Activate circuit breaker for system errors\n            self.risk_controller.volume_tracker.activate_circuit_breaker(\n                'system_error',\n                f'System error in arbitrage execution: {e}',\n                None,\n                None\n            )\n    \n    def _mark_opportunity_executed(self, opportunity):\n        \"\"\"Mark opportunity as executed in database\"\"\"\n        try:\n            # Find the most recent matching opportunity\n            db_opportunity = ArbitrageOpportunity.query.filter(\n                ArbitrageOpportunity.usdt_price == opportunity['usdt_price'],\n                ArbitrageOpportunity.usdc_price == opportunity['usdc_price'],\n                ArbitrageOpportunity.executed == False\n            ).order_by(ArbitrageOpportunity.created_at.desc()).first()\n            \n            if db_opportunity:\n                db_opportunity.executed = True\n                db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error marking opportunity as executed: {e}\")\n            db.session.rollback()\n    \n    def get_engine_status(self):\n        \"\"\"Get current engine status\"\"\"\n        try:\n            config = self.config_manager.get_config()\n            balances = self.balance_manager.get_balances()\n            prices = self.price_monitor.get_current_prices()\n            \n            # Get recent performance\n            from core.profit_analyzer import ProfitAnalyzer\n            profit_analyzer = ProfitAnalyzer()\n            today_stats = profit_analyzer.get_today_stats()\n            \n            status = {\n                'running': self.running,\n                'configuration': {\n                    'spread_threshold': config.spread_threshold if config else 0.003,\n                    'trade_amount': config.trade_amount if config else 100.0,\n                    'daily_max_volume': config.daily_max_volume if config else 5000.0\n                },\n                'balances': balances,\n                'current_prices': prices,\n                'today_performance': today_stats,\n                'pending_orders': self.trade_executor.get_pending_orders_count(),\n                'system_health': self.risk_controller.check_system_health(),\n                'last_update': datetime.utcnow().isoformat()\n            }\n            \n            return status\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting engine status: {e}\")\n            return {\n                'running': self.running,\n                'error': str(e),\n                'last_update': datetime.utcnow().isoformat()\n            }\n    \n    def force_rebalance(self):\n        \"\"\"强制稳定币再平衡\"\"\"\n        try:\n            self.balance_manager.rebalance_stablecoins()\n            self.data_logger.log_system_event(\"PROFESSIONAL_REBALANCE\", \"专业再平衡已触发\", \"ArbitrageEngine\")\n            self.logger.info(\"💰 专业再平衡已完成\")\n        except Exception as e:\n            self.logger.error(f\"专业再平衡错误: {e}\")\n            self.data_logger.log_error(f\"专业再平衡错误: {e}\", \"ArbitrageEngine\", e)\n    \n    def get_professional_status(self) -> dict:\n        \"\"\"🎯 获取专业引擎状态\"\"\"\n        try:\n            # 基础状态\n            base_status = self.get_engine_status()\n            \n            # 专业组件状态\n            professional_status = {\n                'professional_engine': True,\n                'components': {\n                    'order_manager': {\n                        'active': self.order_manager.monitoring_active,\n                        'statistics': self.order_manager.get_order_statistics()\n                    },\n                    'websocket_manager': {\n                        'active': self.websocket_manager.is_running,\n                        'connections': self.websocket_manager.get_connection_stats()\n                    },\n                    'advanced_analytics': {\n                        'active': True,\n                        'analysis': self.advanced_analytics.get_comprehensive_analysis()\n                    },\n                    'latency_optimizer': {\n                        'active': True,\n                        'performance': self.latency_optimizer.get_performance_report()\n                    }\n                },\n                'engine_statistics': {\n                    'total_opportunities': self.total_opportunities,\n                    'executed_trades': self.executed_trades,\n                    'total_profit': self.total_profit,\n                    'success_rate': (self.executed_trades / self.total_opportunities * 100) if self.total_opportunities > 0 else 0,\n                    'runtime_hours': (datetime.utcnow() - self.engine_start_time).total_seconds() / 3600 if self.engine_start_time else 0\n                },\n                'system_optimization': {\n                    'cpu_optimized': True,\n                    'memory_optimized': True,\n                    'network_optimized': True,\n                    'ai_enhanced': True,\n                    'real_time_data': True,\n                    'millisecond_execution': True\n                }\n            }\n            \n            # 合并状态\n            base_status.update(professional_status)\n            \n            return base_status\n            \n        except Exception as e:\n            self.logger.error(f\"获取专业状态失败: {e}\")\n            return {'error': str(e), 'professional_engine': False}\n","size_bytes":33857},"business/data_pipeline.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func\nfrom app import db\nfrom models import Trade, PriceHistory, ArbitrageOpportunity, Balance\nfrom core.profit_analyzer import ProfitAnalyzer\n\nclass DataPipeline:\n    \"\"\"Data processing pipeline for trading analytics\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.profit_analyzer = ProfitAnalyzer()\n    \n    def process_trading_data(self, time_range='24h'):\n        \"\"\"Process and aggregate trading data for analytics\"\"\"\n        try:\n            # Determine time range\n            if time_range == '1h':\n                cutoff = datetime.utcnow() - timedelta(hours=1)\n            elif time_range == '24h':\n                cutoff = datetime.utcnow() - timedelta(hours=24)\n            elif time_range == '7d':\n                cutoff = datetime.utcnow() - timedelta(days=7)\n            elif time_range == '30d':\n                cutoff = datetime.utcnow() - timedelta(days=30)\n            else:\n                cutoff = datetime.utcnow() - timedelta(hours=24)\n            \n            # Aggregate trade data\n            trade_summary = self._aggregate_trades(cutoff)\n            \n            # Process price movements\n            price_analysis = self._analyze_price_movements(cutoff)\n            \n            # Calculate spread statistics\n            spread_stats = self._calculate_spread_statistics(cutoff)\n            \n            # Generate opportunity analysis\n            opportunity_analysis = self._analyze_opportunities(cutoff)\n            \n            # Risk metrics\n            risk_metrics = self._calculate_risk_metrics(cutoff)\n            \n            processed_data = {\n                'time_range': time_range,\n                'processed_at': datetime.utcnow().isoformat(),\n                'trade_summary': trade_summary,\n                'price_analysis': price_analysis,\n                'spread_statistics': spread_stats,\n                'opportunity_analysis': opportunity_analysis,\n                'risk_metrics': risk_metrics\n            }\n            \n            return processed_data\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing trading data: {e}\")\n            return {}\n    \n    def _aggregate_trades(self, cutoff_time):\n        \"\"\"Aggregate trade data for the specified time period\"\"\"\n        try:\n            trades = Trade.query.filter(Trade.created_at >= cutoff_time).all()\n            \n            if not trades:\n                return {\n                    'total_trades': 0,\n                    'total_volume': 0.0,\n                    'total_profit_loss': 0.0,\n                    'avg_trade_size': 0.0,\n                    'success_rate': 0.0,\n                    'trades_by_hour': {},\n                    'trades_by_pair': {}\n                }\n            \n            # Basic aggregations\n            total_trades = len(trades)\n            total_volume = sum(trade.amount for trade in trades)\n            completed_trades = [t for t in trades if t.status == 'completed']\n            total_profit_loss = sum(trade.profit_loss or 0 for trade in completed_trades)\n            \n            avg_trade_size = total_volume / total_trades if total_trades > 0 else 0\n            profitable_trades = len([t for t in completed_trades if (t.profit_loss or 0) > 0])\n            success_rate = (profitable_trades / len(completed_trades) * 100) if completed_trades else 0\n            \n            # Trades by hour\n            trades_by_hour = {}\n            for trade in trades:\n                hour = trade.created_at.hour\n                if hour not in trades_by_hour:\n                    trades_by_hour[hour] = {'count': 0, 'volume': 0, 'profit': 0}\n                trades_by_hour[hour]['count'] += 1\n                trades_by_hour[hour]['volume'] += trade.amount\n                trades_by_hour[hour]['profit'] += trade.profit_loss or 0\n            \n            # Trades by pair\n            trades_by_pair = {}\n            for trade in trades:\n                pair = trade.pair\n                if pair not in trades_by_pair:\n                    trades_by_pair[pair] = {'count': 0, 'volume': 0, 'profit': 0}\n                trades_by_pair[pair]['count'] += 1\n                trades_by_pair[pair]['volume'] += trade.amount\n                trades_by_pair[pair]['profit'] += trade.profit_loss or 0\n            \n            return {\n                'total_trades': total_trades,\n                'total_volume': total_volume,\n                'total_profit_loss': total_profit_loss,\n                'avg_trade_size': avg_trade_size,\n                'success_rate': success_rate,\n                'trades_by_hour': trades_by_hour,\n                'trades_by_pair': trades_by_pair,\n                'completed_trades': len(completed_trades),\n                'pending_trades': len([t for t in trades if t.status == 'pending']),\n                'failed_trades': len([t for t in trades if t.status == 'failed'])\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error aggregating trades: {e}\")\n            return {}\n    \n    def _analyze_price_movements(self, cutoff_time):\n        \"\"\"Analyze price movements and volatility\"\"\"\n        try:\n            # Get price history for both pairs\n            usdt_prices = PriceHistory.query.filter(\n                PriceHistory.pair == 'XRP/USDT',\n                PriceHistory.timestamp >= cutoff_time\n            ).order_by(PriceHistory.timestamp).all()\n            \n            usdc_prices = PriceHistory.query.filter(\n                PriceHistory.pair == 'XRP/USDC',\n                PriceHistory.timestamp >= cutoff_time\n            ).order_by(PriceHistory.timestamp).all()\n            \n            analysis = {}\n            \n            # Analyze USDT pair\n            if usdt_prices:\n                usdt_values = [p.price for p in usdt_prices]\n                analysis['XRP/USDT'] = self._calculate_price_stats(usdt_values)\n                analysis['XRP/USDT']['data_points'] = len(usdt_prices)\n            \n            # Analyze USDC pair\n            if usdc_prices:\n                usdc_values = [p.price for p in usdc_prices]\n                analysis['XRP/USDC'] = self._calculate_price_stats(usdc_values)\n                analysis['XRP/USDC']['data_points'] = len(usdc_prices)\n            \n            # Calculate correlation if both pairs have data\n            if usdt_prices and usdc_prices:\n                usdt_values = [p.price for p in usdt_prices] if 'usdt_values' not in locals() else usdt_values\n                usdc_values = [p.price for p in usdc_prices] if 'usdc_values' not in locals() else usdc_values\n                correlation = self._calculate_price_correlation(usdt_values, usdc_values)\n                analysis['correlation'] = correlation\n            \n            return analysis\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing price movements: {e}\")\n            return {}\n    \n    def _calculate_price_stats(self, prices):\n        \"\"\"Calculate statistical measures for price data\"\"\"\n        if not prices or len(prices) < 2:\n            return {\n                'min': 0, 'max': 0, 'avg': 0, 'volatility': 0,\n                'change': 0, 'change_percent': 0\n            }\n        \n        min_price = min(prices)\n        max_price = max(prices)\n        avg_price = sum(prices) / len(prices)\n        \n        # Calculate volatility (standard deviation)\n        variance = sum((p - avg_price) ** 2 for p in prices) / (len(prices) - 1)\n        volatility = variance ** 0.5\n        \n        # Price change\n        price_change = prices[-1] - prices[0]\n        change_percent = (price_change / prices[0] * 100) if prices[0] > 0 else 0\n        \n        return {\n            'min': min_price,\n            'max': max_price,\n            'avg': avg_price,\n            'volatility': volatility,\n            'change': price_change,\n            'change_percent': change_percent,\n            'current': prices[-1]\n        }\n    \n    def _calculate_price_correlation(self, prices1, prices2):\n        \"\"\"Calculate correlation between two price series\"\"\"\n        try:\n            if len(prices1) != len(prices2) or len(prices1) < 2:\n                return 0\n            \n            # Take the minimum length to ensure equal lengths\n            min_len = min(len(prices1), len(prices2))\n            p1 = prices1[:min_len]\n            p2 = prices2[:min_len]\n            \n            # Calculate means\n            mean1 = sum(p1) / len(p1)\n            mean2 = sum(p2) / len(p2)\n            \n            # Calculate correlation coefficient\n            numerator = sum((p1[i] - mean1) * (p2[i] - mean2) for i in range(len(p1)))\n            \n            sum_sq1 = sum((p - mean1) ** 2 for p in p1)\n            sum_sq2 = sum((p - mean2) ** 2 for p in p2)\n            denominator = (sum_sq1 * sum_sq2) ** 0.5\n            \n            correlation = numerator / denominator if denominator > 0 else 0\n            return correlation\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating correlation: {e}\")\n            return 0\n    \n    def _calculate_spread_statistics(self, cutoff_time):\n        \"\"\"Calculate spread statistics and trends\"\"\"\n        try:\n            opportunities = ArbitrageOpportunity.query.filter(\n                ArbitrageOpportunity.created_at >= cutoff_time\n            ).order_by(ArbitrageOpportunity.created_at).all()\n            \n            if not opportunities:\n                return {\n                    'avg_spread': 0,\n                    'max_spread': 0,\n                    'min_spread': 0,\n                    'spread_volatility': 0,\n                    'spread_trend': 'neutral'\n                }\n            \n            spreads = [opp.spread_percentage for opp in opportunities]\n            \n            avg_spread = sum(spreads) / len(spreads)\n            max_spread = max(spreads)\n            min_spread = min(spreads)\n            \n            # Calculate spread volatility\n            spread_variance = sum((s - avg_spread) ** 2 for s in spreads) / len(spreads)\n            spread_volatility = spread_variance ** 0.5\n            \n            # Determine spread trend\n            if len(spreads) >= 5:\n                recent_avg = sum(spreads[-5:]) / 5\n                older_avg = sum(spreads[:5]) / 5\n                \n                if recent_avg > older_avg * 1.1:\n                    spread_trend = 'increasing'\n                elif recent_avg < older_avg * 0.9:\n                    spread_trend = 'decreasing'\n                else:\n                    spread_trend = 'stable'\n            else:\n                spread_trend = 'insufficient_data'\n            \n            return {\n                'avg_spread': avg_spread,\n                'max_spread': max_spread,\n                'min_spread': min_spread,\n                'spread_volatility': spread_volatility,\n                'spread_trend': spread_trend,\n                'total_opportunities': len(opportunities)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating spread statistics: {e}\")\n            return {}\n    \n    def _analyze_opportunities(self, cutoff_time):\n        \"\"\"Analyze arbitrage opportunities\"\"\"\n        try:\n            opportunities = ArbitrageOpportunity.query.filter(\n                ArbitrageOpportunity.created_at >= cutoff_time\n            ).all()\n            \n            if not opportunities:\n                return {\n                    'total_opportunities': 0,\n                    'executed_opportunities': 0,\n                    'execution_rate': 0,\n                    'avg_opportunity_duration': 0\n                }\n            \n            total_opportunities = len(opportunities)\n            executed_opportunities = len([o for o in opportunities if o.executed])\n            execution_rate = (executed_opportunities / total_opportunities * 100) if total_opportunities > 0 else 0\n            \n            # Analyze opportunity types\n            opportunity_types = {}\n            for opp in opportunities:\n                opp_type = opp.opportunity_type\n                if opp_type not in opportunity_types:\n                    opportunity_types[opp_type] = {'count': 0, 'executed': 0}\n                opportunity_types[opp_type]['count'] += 1\n                if opp.executed:\n                    opportunity_types[opp_type]['executed'] += 1\n            \n            return {\n                'total_opportunities': total_opportunities,\n                'executed_opportunities': executed_opportunities,\n                'execution_rate': execution_rate,\n                'opportunity_types': opportunity_types,\n                'missed_opportunities': total_opportunities - executed_opportunities\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing opportunities: {e}\")\n            return {}\n    \n    def _calculate_risk_metrics(self, cutoff_time):\n        \"\"\"Calculate risk metrics for the time period\"\"\"\n        try:\n            trades = Trade.query.filter(\n                Trade.created_at >= cutoff_time,\n                Trade.status == 'completed'\n            ).all()\n            \n            if not trades:\n                return {\n                    'value_at_risk': 0,\n                    'max_drawdown': 0,\n                    'risk_score': 0\n                }\n            \n            # Calculate returns\n            returns = [trade.profit_loss or 0 for trade in trades]\n            \n            # Value at Risk (95% confidence)\n            if len(returns) >= 20:\n                sorted_returns = sorted(returns)\n                var_index = int(len(sorted_returns) * 0.05)  # 5th percentile\n                value_at_risk = abs(sorted_returns[var_index])\n            else:\n                value_at_risk = 0\n            \n            # Maximum drawdown calculation\n            cumulative_returns = []\n            running_total = 0\n            for ret in returns:\n                running_total += ret\n                cumulative_returns.append(running_total)\n            \n            peak = cumulative_returns[0] if cumulative_returns else 0\n            max_drawdown = 0\n            \n            for value in cumulative_returns:\n                if value > peak:\n                    peak = value\n                drawdown = peak - value\n                if drawdown > max_drawdown:\n                    max_drawdown = drawdown\n            \n            # Risk score (0-100, lower is better)\n            avg_return = sum(returns) / len(returns) if returns else 0\n            volatility = (sum((r - avg_return) ** 2 for r in returns) / len(returns)) ** 0.5 if returns else 0\n            \n            if avg_return > 0 and volatility > 0:\n                sharpe_ratio = avg_return / volatility\n                risk_score = max(0, min(100, 50 - (sharpe_ratio * 10)))\n            else:\n                risk_score = 75  # High risk if no positive returns or no volatility data\n            \n            return {\n                'value_at_risk': value_at_risk,\n                'max_drawdown': max_drawdown,\n                'risk_score': risk_score,\n                'volatility': volatility,\n                'total_risk_events': len([r for r in returns if r < 0])\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating risk metrics: {e}\")\n            return {}\n    \n    def generate_trading_report(self, time_range='24h'):\n        \"\"\"Generate comprehensive trading report\"\"\"\n        try:\n            processed_data = self.process_trading_data(time_range)\n            \n            # Get current system status\n            from core.balance_manager import BalanceManager\n            balance_manager = BalanceManager()\n            current_balances = balance_manager.get_balance_summary()\n            \n            # Get profit analysis\n            profit_stats = self.profit_analyzer.get_comprehensive_stats()\n            \n            report = {\n                'generated_at': datetime.utcnow().isoformat(),\n                'time_range': time_range,\n                'summary': {\n                    'total_trades': processed_data.get('trade_summary', {}).get('total_trades', 0),\n                    'total_profit_loss': processed_data.get('trade_summary', {}).get('total_profit_loss', 0),\n                    'success_rate': processed_data.get('trade_summary', {}).get('success_rate', 0),\n                    'risk_score': processed_data.get('risk_metrics', {}).get('risk_score', 0)\n                },\n                'processed_data': processed_data,\n                'current_balances': current_balances,\n                'profit_analysis': profit_stats\n            }\n            \n            return report\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating trading report: {e}\")\n            return {}\n","size_bytes":16972},"business/trading_strategy.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom core.price_monitor import PriceMonitor\nfrom core.profit_analyzer import ProfitAnalyzer\n\nclass TradingStrategy:\n    \"\"\"Advanced trading decision logic\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.price_monitor = PriceMonitor()\n        self.profit_analyzer = ProfitAnalyzer()\n    \n    def should_trade(self, opportunity, config, market_conditions=None):\n        \"\"\"\n        Advanced trading decision logic\n        \n        Args:\n            opportunity: Detected arbitrage opportunity\n            config: Trading configuration\n            market_conditions: Current market analysis\n            \n        Returns:\n            dict: {'trade': bool, 'confidence': float, 'reason': str}\n        \"\"\"\n        try:\n            decision_factors = []\n            confidence_score = 0.0\n            \n            # Factor 1: Spread size (30% weight)\n            spread_factor = self._analyze_spread_factor(opportunity, config)\n            decision_factors.append(spread_factor)\n            confidence_score += spread_factor['score'] * 0.3\n            \n            # Factor 2: Market volatility (25% weight)\n            volatility_factor = self._analyze_volatility_factor()\n            decision_factors.append(volatility_factor)\n            confidence_score += volatility_factor['score'] * 0.25\n            \n            # Factor 3: Historical success rate (20% weight)\n            success_factor = self._analyze_success_factor()\n            decision_factors.append(success_factor)\n            confidence_score += success_factor['score'] * 0.2\n            \n            # Factor 4: Market timing (15% weight)\n            timing_factor = self._analyze_timing_factor()\n            decision_factors.append(timing_factor)\n            confidence_score += timing_factor['score'] * 0.15\n            \n            # Factor 5: Balance health (10% weight)\n            balance_factor = self._analyze_balance_factor(opportunity['amount'])\n            decision_factors.append(balance_factor)\n            confidence_score += balance_factor['score'] * 0.1\n            \n            # Make trading decision\n            should_trade = confidence_score >= 0.6  # 60% confidence threshold\n            \n            # Compile decision reasoning\n            positive_factors = [f for f in decision_factors if f['score'] > 0.5]\n            negative_factors = [f for f in decision_factors if f['score'] <= 0.5]\n            \n            reason_parts = []\n            if positive_factors:\n                reason_parts.append(f\"Positive: {', '.join([f['name'] for f in positive_factors])}\")\n            if negative_factors:\n                reason_parts.append(f\"Negative: {', '.join([f['name'] for f in negative_factors])}\")\n            \n            reason = \"; \".join(reason_parts) if reason_parts else \"Neutral market conditions\"\n            \n            decision = {\n                'trade': should_trade,\n                'confidence': confidence_score,\n                'reason': reason,\n                'factors': decision_factors\n            }\n            \n            self.logger.info(f\"Trading decision: {should_trade} (confidence: {confidence_score:.2f}) - {reason}\")\n            \n            return decision\n            \n        except Exception as e:\n            self.logger.error(f\"Error in trading decision: {e}\")\n            return {\n                'trade': False,\n                'confidence': 0.0,\n                'reason': f\"Decision error: {e}\",\n                'factors': []\n            }\n    \n    def _analyze_spread_factor(self, opportunity, config):\n        \"\"\"Analyze spread attractiveness\"\"\"\n        try:\n            spread_pct = opportunity['spread_percentage']\n            threshold_pct = config.spread_threshold * 100\n            \n            # Score based on how much the spread exceeds the threshold\n            if spread_pct >= threshold_pct * 3:  # 3x threshold\n                score = 1.0\n                assessment = \"Excellent spread\"\n            elif spread_pct >= threshold_pct * 2:  # 2x threshold\n                score = 0.8\n                assessment = \"Good spread\"\n            elif spread_pct >= threshold_pct * 1.5:  # 1.5x threshold\n                score = 0.6\n                assessment = \"Adequate spread\"\n            elif spread_pct >= threshold_pct:  # Above threshold\n                score = 0.4\n                assessment = \"Minimal spread\"\n            else:\n                score = 0.0\n                assessment = \"Spread too small\"\n            \n            return {\n                'name': 'Spread Size',\n                'score': score,\n                'assessment': assessment,\n                'details': f\"{spread_pct:.4f}% vs {threshold_pct:.4f}% threshold\"\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing spread factor: {e}\")\n            return {'name': 'Spread Size', 'score': 0.5, 'assessment': 'Analysis failed'}\n    \n    def _analyze_volatility_factor(self):\n        \"\"\"Analyze market volatility\"\"\"\n        try:\n            prices = self.price_monitor.get_current_prices()\n            \n            # Get recent price history for volatility calculation\n            from models import PriceHistory\n            recent_cutoff = datetime.utcnow() - timedelta(minutes=15)\n            \n            recent_prices = PriceHistory.query.filter(\n                PriceHistory.timestamp >= recent_cutoff,\n                PriceHistory.pair == 'XRP/USDT'\n            ).order_by(PriceHistory.timestamp).all()\n            \n            if len(recent_prices) < 5:\n                return {\n                    'name': 'Market Volatility',\n                    'score': 0.5,\n                    'assessment': 'Insufficient data',\n                    'details': 'Not enough price history'\n                }\n            \n            price_values = [p.price for p in recent_prices]\n            avg_price = sum(price_values) / len(price_values)\n            \n            # Calculate volatility as standard deviation\n            variance = sum((p - avg_price) ** 2 for p in price_values) / len(price_values)\n            volatility = (variance ** 0.5) / avg_price\n            \n            # Score volatility (lower is better for arbitrage)\n            if volatility < 0.001:  # < 0.1%\n                score = 1.0\n                assessment = \"Very low volatility\"\n            elif volatility < 0.005:  # < 0.5%\n                score = 0.8\n                assessment = \"Low volatility\"\n            elif volatility < 0.01:  # < 1%\n                score = 0.6\n                assessment = \"Moderate volatility\"\n            elif volatility < 0.02:  # < 2%\n                score = 0.3\n                assessment = \"High volatility\"\n            else:\n                score = 0.1\n                assessment = \"Very high volatility\"\n            \n            return {\n                'name': 'Market Volatility',\n                'score': score,\n                'assessment': assessment,\n                'details': f\"Volatility: {volatility:.4f}\"\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing volatility: {e}\")\n            return {'name': 'Market Volatility', 'score': 0.5, 'assessment': 'Analysis failed'}\n    \n    def _analyze_success_factor(self):\n        \"\"\"Analyze historical success rate\"\"\"\n        try:\n            stats = self.profit_analyzer.get_comprehensive_stats(days=7)\n            \n            if stats['total_trades'] == 0:\n                return {\n                    'name': 'Success Rate',\n                    'score': 0.5,\n                    'assessment': 'No trading history',\n                    'details': 'First trade'\n                }\n            \n            success_rate = stats['success_rate']\n            avg_profit = stats['avg_profit_per_trade']\n            \n            # Score based on success rate and profitability\n            if success_rate >= 80 and avg_profit > 0:\n                score = 1.0\n                assessment = \"Excellent track record\"\n            elif success_rate >= 70 and avg_profit > 0:\n                score = 0.8\n                assessment = \"Good track record\"\n            elif success_rate >= 60:\n                score = 0.6\n                assessment = \"Adequate track record\"\n            elif success_rate >= 50:\n                score = 0.4\n                assessment = \"Poor track record\"\n            else:\n                score = 0.2\n                assessment = \"Very poor track record\"\n            \n            return {\n                'name': 'Success Rate',\n                'score': score,\n                'assessment': assessment,\n                'details': f\"{success_rate:.1f}% success, avg profit: {avg_profit:.4f}\"\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing success factor: {e}\")\n            return {'name': 'Success Rate', 'score': 0.5, 'assessment': 'Analysis failed'}\n    \n    def _analyze_timing_factor(self):\n        \"\"\"Analyze market timing\"\"\"\n        try:\n            current_hour = datetime.utcnow().hour\n            \n            # Get historical performance by hour\n            stats = self.profit_analyzer.get_comprehensive_stats(days=30)\n            time_analysis = stats.get('time_analysis', {})\n            \n            if 'hourly_performance' not in time_analysis:\n                # Default scoring based on typical trading hours\n                if 8 <= current_hour <= 16:  # Business hours\n                    score = 0.7\n                    assessment = \"Good trading hours\"\n                elif 0 <= current_hour <= 6:  # Night hours\n                    score = 0.4\n                    assessment = \"Low activity hours\"\n                else:\n                    score = 0.6\n                    assessment = \"Moderate activity hours\"\n            else:\n                hourly_perf = time_analysis['hourly_performance']\n                \n                if current_hour in hourly_perf:\n                    hour_profit = hourly_perf[current_hour]\n                    \n                    # Score based on historical performance this hour\n                    if hour_profit > 0.5:\n                        score = 1.0\n                        assessment = \"Excellent timing\"\n                    elif hour_profit > 0.1:\n                        score = 0.8\n                        assessment = \"Good timing\"\n                    elif hour_profit > 0:\n                        score = 0.6\n                        assessment = \"Positive timing\"\n                    elif hour_profit > -0.1:\n                        score = 0.4\n                        assessment = \"Neutral timing\"\n                    else:\n                        score = 0.2\n                        assessment = \"Poor timing\"\n                else:\n                    score = 0.5\n                    assessment = \"No historical data\"\n            \n            return {\n                'name': 'Market Timing',\n                'score': score,\n                'assessment': assessment,\n                'details': f\"Hour: {current_hour}:00\"\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing timing factor: {e}\")\n            return {'name': 'Market Timing', 'score': 0.5, 'assessment': 'Analysis failed'}\n    \n    def _analyze_balance_factor(self, trade_amount):\n        \"\"\"Analyze balance health for trading\"\"\"\n        try:\n            from core.balance_manager import BalanceManager\n            balance_manager = BalanceManager()\n            \n            balances = balance_manager.get_balances()\n            \n            # Check XRP balance sufficiency\n            xrp_balance = balances.get('XRP', {}).get('free', 0)\n            xrp_ratio = trade_amount / xrp_balance if xrp_balance > 0 else 1\n            \n            # Check stablecoin balance\n            usdt_balance = balances.get('USDT', {}).get('free', 0)\n            usdc_balance = balances.get('USDC', {}).get('free', 0)\n            total_stable = usdt_balance + usdc_balance\n            \n            estimated_cost = trade_amount * 0.52  # Approximate XRP price\n            stable_ratio = estimated_cost / total_stable if total_stable > 0 else 1\n            \n            # Score based on balance utilization\n            max_ratio = max(xrp_ratio, stable_ratio)\n            \n            if max_ratio < 0.1:  # Using < 10% of balance\n                score = 1.0\n                assessment = \"Excellent balance health\"\n            elif max_ratio < 0.2:  # Using < 20% of balance\n                score = 0.8\n                assessment = \"Good balance health\"\n            elif max_ratio < 0.4:  # Using < 40% of balance\n                score = 0.6\n                assessment = \"Adequate balance health\"\n            elif max_ratio < 0.6:  # Using < 60% of balance\n                score = 0.4\n                assessment = \"Marginal balance health\"\n            else:\n                score = 0.2\n                assessment = \"Poor balance health\"\n            \n            return {\n                'name': 'Balance Health',\n                'score': score,\n                'assessment': assessment,\n                'details': f\"Using {max_ratio:.1%} of available balance\"\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing balance factor: {e}\")\n            return {'name': 'Balance Health', 'score': 0.5, 'assessment': 'Analysis failed'}\n    \n    def optimize_trade_amount(self, base_amount, opportunity, config):\n        \"\"\"Optimize trade amount based on current conditions\"\"\"\n        try:\n            # Start with configured base amount\n            optimized_amount = base_amount\n            \n            # Adjust based on spread size\n            spread_pct = opportunity['spread_percentage']\n            threshold_pct = config.spread_threshold * 100\n            \n            if spread_pct > threshold_pct * 2:\n                # Large spread - increase trade size by up to 50%\n                multiplier = 1 + min(0.5, (spread_pct / threshold_pct - 1) * 0.25)\n                optimized_amount *= multiplier\n            \n            # Adjust based on recent performance\n            stats = self.profit_analyzer.get_today_stats()\n            if stats['success_rate'] > 80 and stats['total_profit_loss'] > 0:\n                # Good performance today - slightly increase trade size\n                optimized_amount *= 1.1\n            elif stats['success_rate'] < 50 or stats['total_profit_loss'] < 0:\n                # Poor performance today - decrease trade size\n                optimized_amount *= 0.8\n            \n            # Ensure we don't exceed configured limits\n            optimized_amount = min(optimized_amount, config.trade_amount * 1.5)\n            optimized_amount = max(optimized_amount, config.trade_amount * 0.5)\n            \n            # Safety check - ensure we have sufficient balances\n            from core.risk_controller import RiskController\n            risk_controller = RiskController()\n            max_safe = risk_controller.calculate_max_safe_trade_amount(config)\n            \n            optimized_amount = min(optimized_amount, max_safe)\n            \n            self.logger.info(f\"Trade amount optimized: {base_amount:.2f} -> {optimized_amount:.2f}\")\n            \n            return optimized_amount\n            \n        except Exception as e:\n            self.logger.error(f\"Error optimizing trade amount: {e}\")\n            return base_amount\n","size_bytes":15545},"core/advanced_analytics.py":{"content":"import numpy as np\nimport pandas as pd\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom collections import deque\nfrom app import db\nfrom models import Trade, PriceHistory, ArbitrageOpportunity, DailyVolume\n\nclass AdvancedAnalytics:\n    \"\"\"🧠 高级交易分析引擎 - AI驱动的性能优化\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        \n        # 数据缓存\n        self.price_cache = deque(maxlen=1000)  # 最近1000个价格点\n        self.spread_cache = deque(maxlen=500)   # 最近500个价差\n        self.execution_cache = deque(maxlen=200) # 最近200次执行\n        \n        # 模型参数\n        self.trend_window = 20      # 趋势分析窗口\n        self.volatility_window = 50 # 波动率计算窗口\n        self.correlation_window = 100 # 相关性分析窗口\n        \n        # 性能指标\n        self.sharpe_ratio = 0.0\n        self.max_drawdown = 0.0\n        self.win_rate = 0.0\n        self.profit_factor = 0.0\n        \n        # 预测模型参数\n        self.alpha = 0.3  # 指数移动平均参数\n        self.beta = 0.7   # 趋势权重\n        self.gamma = 0.2  # 波动率权重\n    \n    def update_price_data(self, symbol: str, price: float, volume: float, timestamp: datetime = None):\n        \"\"\"更新价格数据到分析缓存\"\"\"\n        try:\n            if timestamp is None:\n                timestamp = datetime.utcnow()\n            \n            price_point = {\n                'symbol': symbol,\n                'price': price,\n                'volume': volume,\n                'timestamp': timestamp\n            }\n            \n            self.price_cache.append(price_point)\n            \n            # 实时计算指标\n            self._update_real_time_metrics()\n            \n        except Exception as e:\n            self.logger.error(f\"更新价格数据失败: {e}\")\n    \n    def update_spread_data(self, usdt_price: float, usdc_price: float, spread_pct: float):\n        \"\"\"更新价差数据\"\"\"\n        try:\n            spread_point = {\n                'usdt_price': usdt_price,\n                'usdc_price': usdc_price,\n                'spread_percentage': spread_pct,\n                'spread_abs': abs(usdt_price - usdc_price),\n                'timestamp': datetime.utcnow()\n            }\n            \n            self.spread_cache.append(spread_point)\n            \n            # 触发价差分析\n            self._analyze_spread_patterns()\n            \n        except Exception as e:\n            self.logger.error(f\"更新价差数据失败: {e}\")\n    \n    def update_execution_data(self, trade_result: dict):\n        \"\"\"更新交易执行数据\"\"\"\n        try:\n            execution_point = {\n                'profit_loss': trade_result.get('profit_loss', 0),\n                'execution_time': trade_result.get('execution_time', 0),\n                'slippage': trade_result.get('slippage', {}),\n                'amount': trade_result.get('amount', 0),\n                'success': trade_result.get('profit_loss', 0) > 0,\n                'timestamp': datetime.utcnow()\n            }\n            \n            self.execution_cache.append(execution_point)\n            \n            # 更新性能指标\n            self._update_performance_metrics()\n            \n        except Exception as e:\n            self.logger.error(f\"更新执行数据失败: {e}\")\n    \n    def _update_real_time_metrics(self):\n        \"\"\"更新实时市场指标\"\"\"\n        try:\n            if len(self.price_cache) < self.trend_window:\n                return\n            \n            # 获取最近价格数据\n            recent_prices = list(self.price_cache)[-self.trend_window:]\n            \n            # 按交易对分组\n            usdt_prices = [p['price'] for p in recent_prices if 'USDT' in p['symbol']]\n            usdc_prices = [p['price'] for p in recent_prices if 'USDC' in p['symbol']]\n            \n            if len(usdt_prices) >= 10 and len(usdc_prices) >= 10:\n                # 计算趋势强度\n                usdt_trend = self._calculate_trend_strength(usdt_prices)\n                usdc_trend = self._calculate_trend_strength(usdc_prices)\n                \n                # 计算波动率\n                usdt_volatility = self._calculate_volatility(usdt_prices)\n                usdc_volatility = self._calculate_volatility(usdc_prices)\n                \n                # 更新缓存的指标\n                self.current_metrics = {\n                    'usdt_trend': usdt_trend,\n                    'usdc_trend': usdc_trend,\n                    'usdt_volatility': usdt_volatility,\n                    'usdc_volatility': usdc_volatility,\n                    'trend_divergence': abs(usdt_trend - usdc_trend),\n                    'volatility_ratio': usdt_volatility / usdc_volatility if usdc_volatility != 0 else 1,\n                    'updated_at': datetime.utcnow()\n                }\n                \n        except Exception as e:\n            self.logger.error(f\"更新实时指标失败: {e}\")\n    \n    def _calculate_trend_strength(self, prices: List[float]) -> float:\n        \"\"\"计算趋势强度 (-1到1，-1强烈下跌，1强烈上涨)\"\"\"\n        try:\n            if len(prices) < 5:\n                return 0.0\n            \n            # 使用线性回归计算趋势\n            x = np.arange(len(prices))\n            y = np.array(prices)\n            \n            # 计算斜率\n            slope = np.polyfit(x, y, 1)[0]\n            \n            # 归一化到[-1, 1]范围\n            price_range = max(prices) - min(prices)\n            if price_range == 0:\n                return 0.0\n            \n            normalized_slope = slope / (price_range / len(prices))\n            \n            # 限制在[-1, 1]范围内\n            return max(-1.0, min(1.0, normalized_slope))\n            \n        except Exception as e:\n            self.logger.error(f\"计算趋势强度失败: {e}\")\n            return 0.0\n    \n    def _calculate_volatility(self, prices: List[float]) -> float:\n        \"\"\"计算价格波动率\"\"\"\n        try:\n            if len(prices) < 2:\n                return 0.0\n            \n            # 计算价格变化率\n            returns = []\n            for i in range(1, len(prices)):\n                return_pct = (prices[i] - prices[i-1]) / prices[i-1]\n                returns.append(return_pct)\n            \n            # 计算标准差作为波动率\n            volatility = np.std(returns) if returns else 0.0\n            \n            return volatility\n            \n        except Exception as e:\n            self.logger.error(f\"计算波动率失败: {e}\")\n            return 0.0\n    \n    def _analyze_spread_patterns(self):\n        \"\"\"分析价差模式\"\"\"\n        try:\n            if len(self.spread_cache) < 20:\n                return\n            \n            recent_spreads = list(self.spread_cache)[-20:]\n            spread_values = [s['spread_percentage'] for s in recent_spreads]\n            \n            # 价差统计\n            mean_spread = np.mean(spread_values)\n            std_spread = np.std(spread_values)\n            max_spread = max(spread_values)\n            min_spread = min(spread_values)\n            \n            # 价差趋势\n            spread_trend = self._calculate_trend_strength(spread_values)\n            \n            # 价差突破检测\n            recent_spread = spread_values[-1]\n            z_score = (recent_spread - mean_spread) / std_spread if std_spread != 0 else 0\n            \n            self.spread_analysis = {\n                'mean_spread': mean_spread,\n                'std_spread': std_spread,\n                'max_spread': max_spread,\n                'min_spread': min_spread,\n                'current_spread': recent_spread,\n                'spread_trend': spread_trend,\n                'z_score': z_score,\n                'is_outlier': abs(z_score) > 2.0,  # 2个标准差外认为是异常值\n                'recommendation': self._get_spread_recommendation(z_score, spread_trend),\n                'updated_at': datetime.utcnow()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"分析价差模式失败: {e}\")\n    \n    def _get_spread_recommendation(self, z_score: float, trend: float) -> str:\n        \"\"\"基于价差分析给出交易建议\"\"\"\n        try:\n            if abs(z_score) > 2.5:  # 极端价差\n                if z_score > 0:\n                    return \"STRONG_BUY - 极大价差机会\"\n                else:\n                    return \"AVOID - 价差过小\"\n            \n            elif abs(z_score) > 1.5:  # 较大价差\n                if z_score > 0 and trend > 0:\n                    return \"BUY - 价差扩大趋势\"\n                elif z_score > 0 and trend < 0:\n                    return \"QUICK_BUY - 价差可能收窄\"\n                else:\n                    return \"WAIT - 价差不佳\"\n            \n            else:  # 正常价差\n                if trend > 0.3:\n                    return \"WAIT_EXPANSION - 等待价差扩大\"\n                else:\n                    return \"NORMAL - 正常市场条件\"\n                    \n        except Exception as e:\n            self.logger.error(f\"生成价差建议失败: {e}\")\n            return \"UNKNOWN\"\n    \n    def _update_performance_metrics(self):\n        \"\"\"更新交易性能指标\"\"\"\n        try:\n            if len(self.execution_cache) < 10:\n                return\n            \n            executions = list(self.execution_cache)\n            \n            # 基础统计\n            profits = [e['profit_loss'] for e in executions]\n            execution_times = [e['execution_time'] for e in executions]\n            \n            total_profit = sum(profits)\n            winning_trades = [p for p in profits if p > 0]\n            losing_trades = [p for p in profits if p < 0]\n            \n            # 胜率\n            self.win_rate = len(winning_trades) / len(profits) * 100 if profits else 0\n            \n            # 盈利因子\n            total_wins = sum(winning_trades) if winning_trades else 0\n            total_losses = abs(sum(losing_trades)) if losing_trades else 1\n            self.profit_factor = total_wins / total_losses if total_losses != 0 else 0\n            \n            # 夏普比率 (简化版)\n            if len(profits) > 1:\n                profit_std = np.std(profits)\n                avg_profit = np.mean(profits)\n                self.sharpe_ratio = avg_profit / profit_std if profit_std != 0 else 0\n            \n            # 最大回撤\n            cumulative_profit = 0\n            peak = 0\n            max_dd = 0\n            \n            for profit in profits:\n                cumulative_profit += profit\n                if cumulative_profit > peak:\n                    peak = cumulative_profit\n                drawdown = peak - cumulative_profit\n                if drawdown > max_dd:\n                    max_dd = drawdown\n            \n            self.max_drawdown = max_dd\n            \n            # 平均执行时间\n            self.avg_execution_time = np.mean(execution_times) if execution_times else 0\n            \n        except Exception as e:\n            self.logger.error(f\"更新性能指标失败: {e}\")\n    \n    def predict_next_spread(self) -> Dict:\n        \"\"\"预测下一个价差机会\"\"\"\n        try:\n            if len(self.spread_cache) < 30:\n                return {'prediction': 'insufficient_data', 'confidence': 0}\n            \n            recent_spreads = list(self.spread_cache)[-30:]\n            spread_values = [s['spread_percentage'] for s in recent_spreads]\n            \n            # 使用指数移动平均预测\n            ema_short = self._calculate_ema(spread_values[-10:], 0.4)\n            ema_long = self._calculate_ema(spread_values, 0.2)\n            \n            # 趋势预测\n            trend = self._calculate_trend_strength(spread_values[-15:])\n            \n            # 波动率调整\n            volatility = self._calculate_volatility(spread_values[-20:])\n            \n            # 综合预测\n            base_prediction = ema_short\n            trend_adjustment = trend * 0.1 * base_prediction\n            volatility_adjustment = volatility * 50  # 波动率转换为价差百分比\n            \n            predicted_spread = base_prediction + trend_adjustment + volatility_adjustment\n            \n            # 置信度计算\n            recent_accuracy = self._calculate_prediction_accuracy()\n            trend_consistency = 1 - abs(trend) * 0.2  # 趋势越强，置信度稍降\n            volatility_penalty = max(0, 1 - volatility * 20)  # 高波动率降低置信度\n            \n            confidence = recent_accuracy * trend_consistency * volatility_penalty\n            \n            return {\n                'predicted_spread': predicted_spread,\n                'confidence': min(1.0, max(0.1, confidence)),\n                'trend_direction': 'up' if trend > 0.1 else 'down' if trend < -0.1 else 'sideways',\n                'volatility_level': 'high' if volatility > 0.02 else 'low',\n                'recommendation': self._get_prediction_recommendation(predicted_spread, confidence),\n                'time_horizon': '2-5分钟',\n                'updated_at': datetime.utcnow()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"预测价差失败: {e}\")\n            return {'prediction': 'error', 'confidence': 0}\n    \n    def _calculate_ema(self, values: List[float], alpha: float) -> float:\n        \"\"\"计算指数移动平均\"\"\"\n        try:\n            if not values:\n                return 0.0\n            \n            ema = values[0]\n            for value in values[1:]:\n                ema = alpha * value + (1 - alpha) * ema\n            \n            return ema\n            \n        except Exception as e:\n            self.logger.error(f\"计算EMA失败: {e}\")\n            return 0.0\n    \n    def _calculate_prediction_accuracy(self) -> float:\n        \"\"\"计算预测准确率\"\"\"\n        try:\n            # 简化的准确率计算\n            # 在实际应用中，需要存储预测历史并比较实际结果\n            \n            if len(self.execution_cache) < 5:\n                return 0.7  # 默认70%\n            \n            recent_executions = list(self.execution_cache)[-10:]\n            successful_trades = len([e for e in recent_executions if e['success']])\n            \n            return successful_trades / len(recent_executions)\n            \n        except Exception as e:\n            self.logger.error(f\"计算预测准确率失败: {e}\")\n            return 0.5\n    \n    def _get_prediction_recommendation(self, predicted_spread: float, confidence: float) -> str:\n        \"\"\"基于预测结果给出建议\"\"\"\n        try:\n            if confidence < 0.3:\n                return \"LOW_CONFIDENCE - 建议等待更好信号\"\n            \n            if predicted_spread > 0.5:  # 大于0.5%\n                if confidence > 0.7:\n                    return \"STRONG_OPPORTUNITY - 高置信度大价差\"\n                else:\n                    return \"MODERATE_OPPORTUNITY - 中等机会\"\n            \n            elif predicted_spread > 0.2:  # 0.2%-0.5%\n                if confidence > 0.8:\n                    return \"ACCEPTABLE_OPPORTUNITY - 可接受的机会\"\n                else:\n                    return \"MARGINAL_OPPORTUNITY - 边际机会\"\n            \n            else:\n                return \"POOR_OPPORTUNITY - 价差预测不佳\"\n                \n        except Exception as e:\n            self.logger.error(f\"生成预测建议失败: {e}\")\n            return \"UNKNOWN\"\n    \n    def get_comprehensive_analysis(self) -> Dict:\n        \"\"\"获取综合分析报告\"\"\"\n        try:\n            # 获取实时指标\n            current_metrics = getattr(self, 'current_metrics', {})\n            spread_analysis = getattr(self, 'spread_analysis', {})\n            \n            # 预测下一个机会\n            prediction = self.predict_next_spread()\n            \n            # 市场状态评估\n            market_state = self._assess_market_state(current_metrics, spread_analysis)\n            \n            # 交易建议\n            trading_recommendation = self._generate_trading_recommendation(\n                current_metrics, spread_analysis, prediction, market_state\n            )\n            \n            return {\n                'performance_metrics': {\n                    'sharpe_ratio': round(self.sharpe_ratio, 3),\n                    'max_drawdown': round(self.max_drawdown, 3),\n                    'win_rate': round(self.win_rate, 1),\n                    'profit_factor': round(self.profit_factor, 2),\n                    'avg_execution_time': round(getattr(self, 'avg_execution_time', 0), 2)\n                },\n                'current_metrics': current_metrics,\n                'spread_analysis': spread_analysis,\n                'prediction': prediction,\n                'market_state': market_state,\n                'trading_recommendation': trading_recommendation,\n                'system_health': {\n                    'data_quality': len(self.price_cache) / 1000,  # 数据完整性\n                    'analysis_freshness': self._get_analysis_freshness(),\n                    'prediction_reliability': prediction.get('confidence', 0)\n                },\n                'generated_at': datetime.utcnow().isoformat()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"生成综合分析失败: {e}\")\n            return {'error': str(e), 'generated_at': datetime.utcnow().isoformat()}\n    \n    def _assess_market_state(self, metrics: Dict, spread_analysis: Dict) -> Dict:\n        \"\"\"评估市场状态\"\"\"\n        try:\n            trend_divergence = metrics.get('trend_divergence', 0)\n            volatility_ratio = metrics.get('volatility_ratio', 1)\n            current_spread = spread_analysis.get('current_spread', 0)\n            spread_trend = spread_analysis.get('spread_trend', 0)\n            \n            # 市场状态分类\n            if trend_divergence > 0.5 and current_spread > 0.3:\n                state = \"DIVERGENT_HIGH_SPREAD\"\n                description = \"市场分化，高价差环境\"\n                favorability = \"excellent\"\n            elif trend_divergence < 0.2 and abs(volatility_ratio - 1) < 0.1:\n                state = \"CONVERGENT_STABLE\"\n                description = \"市场收敛，稳定环境\"\n                favorability = \"good\"\n            elif abs(spread_trend) > 0.3:\n                state = \"TRENDING_SPREAD\"\n                description = \"价差趋势明显\"\n                favorability = \"moderate\"\n            else:\n                state = \"NEUTRAL\"\n                description = \"中性市场环境\"\n                favorability = \"fair\"\n            \n            return {\n                'state': state,\n                'description': description,\n                'favorability': favorability,\n                'key_factors': {\n                    'trend_divergence': trend_divergence,\n                    'volatility_ratio': volatility_ratio,\n                    'spread_level': current_spread,\n                    'spread_momentum': spread_trend\n                }\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"评估市场状态失败: {e}\")\n            return {'state': 'UNKNOWN', 'description': '无法评估', 'favorability': 'unknown'}\n    \n    def _generate_trading_recommendation(self, metrics: Dict, spread_analysis: Dict, \n                                       prediction: Dict, market_state: Dict) -> Dict:\n        \"\"\"生成交易建议\"\"\"\n        try:\n            # 综合评分\n            spread_score = min(100, (spread_analysis.get('current_spread', 0) * 100))\n            confidence_score = prediction.get('confidence', 0) * 100\n            market_score = {'excellent': 100, 'good': 80, 'moderate': 60, 'fair': 40}.get(\n                market_state.get('favorability', 'fair'), 40\n            )\n            \n            overall_score = (spread_score * 0.4 + confidence_score * 0.3 + market_score * 0.3)\n            \n            # 生成建议\n            if overall_score >= 80:\n                action = \"EXECUTE_IMMEDIATELY\"\n                reasoning = \"高价差 + 高置信度 + 优秀市场条件\"\n                position_size = \"FULL\"\n            elif overall_score >= 60:\n                action = \"EXECUTE_CAUTIOUSLY\"\n                reasoning = \"良好条件，建议执行\"\n                position_size = \"REDUCED\"\n            elif overall_score >= 40:\n                action = \"MONITOR_CLOSELY\"\n                reasoning = \"边际条件，密切观察\"\n                position_size = \"MINIMAL\"\n            else:\n                action = \"WAIT\"\n                reasoning = \"条件不佳，建议等待\"\n                position_size = \"NONE\"\n            \n            return {\n                'action': action,\n                'reasoning': reasoning,\n                'position_size': position_size,\n                'overall_score': round(overall_score, 1),\n                'component_scores': {\n                    'spread': round(spread_score, 1),\n                    'confidence': round(confidence_score, 1),\n                    'market': round(market_score, 1)\n                },\n                'risk_level': 'LOW' if overall_score >= 70 else 'MEDIUM' if overall_score >= 50 else 'HIGH',\n                'expected_duration': '2-5分钟',\n                'stop_loss_level': 0.05  # 5%止损\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"生成交易建议失败: {e}\")\n            return {'action': 'ERROR', 'reasoning': str(e)}\n    \n    def _get_analysis_freshness(self) -> float:\n        \"\"\"获取分析数据新鲜度\"\"\"\n        try:\n            if not self.price_cache:\n                return 0.0\n            \n            latest_data = self.price_cache[-1]['timestamp']\n            time_diff = (datetime.utcnow() - latest_data).total_seconds()\n            \n            # 30秒内为1.0，超过5分钟为0\n            freshness = max(0.0, 1.0 - time_diff / 300)\n            \n            return freshness\n            \n        except Exception as e:\n            self.logger.error(f\"计算数据新鲜度失败: {e}\")\n            return 0.0","size_bytes":22337},"core/api_connector.py":{"content":"import random\nimport time\nimport logging\nfrom datetime import datetime\n\nclass APIConnector:\n    \"\"\"MEXC exchange API connection simulator\"\"\"\n    \n    def __init__(self):\n        self.connected = False\n        self.last_ping = None\n        self.logger = logging.getLogger(__name__)\n        \n    def connect(self):\n        \"\"\"Simulate API connection\"\"\"\n        try:\n            # Simulate connection delay\n            time.sleep(0.5)\n            self.connected = True\n            self.last_ping = datetime.utcnow()\n            self.logger.info(\"Connected to MEXC API (simulated)\")\n            return True\n        except Exception as e:\n            self.logger.error(f\"Failed to connect to API: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"Disconnect from API\"\"\"\n        self.connected = False\n        self.last_ping = None\n        self.logger.info(\"Disconnected from MEXC API\")\n    \n    def is_connected(self):\n        \"\"\"Check if API is connected\"\"\"\n        return self.connected\n    \n    def get_ticker(self, symbol):\n        \"\"\"Get ticker data for a symbol\"\"\"\n        if not self.connected:\n            raise Exception(\"API not connected\")\n        \n        # Simulate realistic XRP prices with small variations\n        base_prices = {\n            'XRP/USDT': 0.5234,\n            'XRP/USDC': 0.5241\n        }\n        \n        if symbol not in base_prices:\n            raise Exception(f\"Symbol {symbol} not found\")\n        \n        base_price = base_prices[symbol]\n        # Add small random variation (-0.5% to +0.5%)\n        variation = random.uniform(-0.005, 0.005)\n        current_price = base_price * (1 + variation)\n        \n        # Simulate volume\n        volume = random.uniform(1000000, 5000000)\n        \n        ticker = {\n            'symbol': symbol,\n            'last': current_price,\n            'bid': current_price * 0.9995,\n            'ask': current_price * 1.0005,\n            'volume': volume,\n            'timestamp': datetime.utcnow().timestamp() * 1000\n        }\n        \n        return ticker\n    \n    def get_balance(self):\n        \"\"\"Get account balance\"\"\"\n        if not self.connected:\n            raise Exception(\"API not connected\")\n        \n        # Simulate account balances\n        return {\n            'XRP': {'free': 10000.0, 'used': 100.0, 'total': 10100.0},\n            'USDT': {'free': 5000.0, 'used': 50.0, 'total': 5050.0},\n            'USDC': {'free': 5000.0, 'used': 50.0, 'total': 5050.0}\n        }\n    \n    def create_order(self, symbol, order_type, side, amount, price=None):\n        \"\"\"Create a trading order\"\"\"\n        if not self.connected:\n            raise Exception(\"API not connected\")\n        \n        # Simulate order creation\n        order_id = f\"sim_{int(time.time())}_{random.randint(1000, 9999)}\"\n        \n        # Simulate small chance of order failure\n        if random.random() < 0.05:  # 5% chance of failure\n            raise Exception(\"Order creation failed (simulated)\")\n        \n        order = {\n            'id': order_id,\n            'symbol': symbol,\n            'type': order_type,\n            'side': side,\n            'amount': amount,\n            'price': price,\n            'status': 'open',\n            'timestamp': datetime.utcnow().timestamp() * 1000\n        }\n        \n        # Simulate immediate execution for market orders\n        if order_type == 'market':\n            order['status'] = 'closed'\n            ticker = self.get_ticker(symbol)\n            order['price'] = ticker['last']\n        \n        self.logger.info(f\"Created order: {order_id} for {amount} {symbol}\")\n        return order\n    \n    def get_order_status(self, order_id, symbol):\n        \"\"\"Get order status\"\"\"\n        if not self.connected:\n            raise Exception(\"API not connected\")\n        \n        # Simulate order completion after short delay\n        return {\n            'id': order_id,\n            'status': 'closed',\n            'filled': True,\n            'timestamp': datetime.utcnow().timestamp() * 1000\n        }\n    \n    def cancel_order(self, order_id, symbol):\n        \"\"\"Cancel an order\"\"\"\n        if not self.connected:\n            raise Exception(\"API not connected\")\n        \n        self.logger.info(f\"Cancelled order: {order_id}\")\n        return {'id': order_id, 'status': 'cancelled'}\n","size_bytes":4294},"core/balance_manager.py":{"content":"import logging\nfrom app import db\nfrom models import Balance\nfrom core.api_connector import APIConnector\n\nclass BalanceManager:\n    \"\"\"Wallet balance management and stablecoin rebalancing\"\"\"\n    \n    def __init__(self):\n        self.api = APIConnector()\n        self.logger = logging.getLogger(__name__)\n        \n        # Connect to API\n        self.api.connect()\n    \n    def initialize_balances(self):\n        \"\"\"Initialize balances if they don't exist\"\"\"\n        try:\n            # Check if balances exist\n            existing_balances = Balance.query.all()\n            if existing_balances:\n                return\n            \n            # Create initial balances\n            initial_balances = [\n                Balance(currency='XRP', amount=10000.0, locked=0.0),\n                Balance(currency='USDT', amount=5000.0, locked=0.0),\n                Balance(currency='USDC', amount=5000.0, locked=0.0)\n            ]\n            \n            for balance in initial_balances:\n                db.session.add(balance)\n            \n            db.session.commit()\n            self.logger.info(\"Initialized default balances\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error initializing balances: {e}\")\n            db.session.rollback()\n    \n    def get_balances(self):\n        \"\"\"Get current balances\"\"\"\n        try:\n            balances = {}\n            db_balances = Balance.query.all()\n            \n            for balance in db_balances:\n                balances[balance.currency] = {\n                    'free': balance.amount,\n                    'locked': balance.locked,\n                    'total': balance.amount + balance.locked\n                }\n            \n            # If no balances in DB, initialize and get from API simulation\n            if not balances:\n                self.initialize_balances()\n                return self.get_balances()\n            \n            return balances\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting balances: {e}\")\n            return {}\n    \n    def update_balance(self, currency, amount_change, lock_change=0):\n        \"\"\"Update balance for a currency\"\"\"\n        try:\n            balance = Balance.query.filter_by(currency=currency).first()\n            if not balance:\n                balance = Balance(currency=currency, amount=0.0, locked=0.0)\n                db.session.add(balance)\n            \n            balance.amount += amount_change\n            balance.locked += lock_change\n            \n            # Ensure no negative balances\n            if balance.amount < 0:\n                balance.amount = 0\n            if balance.locked < 0:\n                balance.locked = 0\n            \n            db.session.commit()\n            self.logger.info(f\"Updated {currency} balance: {amount_change:+.4f}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error updating balance: {e}\")\n            db.session.rollback()\n    \n    def lock_balance(self, currency, amount):\n        \"\"\"Lock balance for pending trades\"\"\"\n        try:\n            balance = Balance.query.filter_by(currency=currency).first()\n            if not balance:\n                raise Exception(f\"No balance found for {currency}\")\n            \n            if balance.amount < amount:\n                raise Exception(f\"Insufficient {currency} balance\")\n            \n            balance.amount -= amount\n            balance.locked += amount\n            \n            db.session.commit()\n            self.logger.info(f\"Locked {amount:.4f} {currency}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error locking balance: {e}\")\n            db.session.rollback()\n            raise\n    \n    def unlock_balance(self, currency, amount):\n        \"\"\"Unlock balance after trade completion\"\"\"\n        try:\n            balance = Balance.query.filter_by(currency=currency).first()\n            if not balance:\n                raise Exception(f\"No balance found for {currency}\")\n            \n            if balance.locked < amount:\n                self.logger.warning(f\"Trying to unlock more {currency} than locked\")\n                amount = balance.locked\n            \n            balance.locked -= amount\n            balance.amount += amount\n            \n            db.session.commit()\n            self.logger.info(f\"Unlocked {amount:.4f} {currency}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error unlocking balance: {e}\")\n            db.session.rollback()\n    \n    def check_sufficient_balance(self, currency, required_amount, safety_buffer=0.1):\n        \"\"\"Check if there's sufficient balance for a trade\"\"\"\n        try:\n            balance = Balance.query.filter_by(currency=currency).first()\n            if not balance:\n                return False\n            \n            available = balance.amount\n            required_with_buffer = required_amount * (1 + safety_buffer)\n            \n            return available >= required_with_buffer\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking balance: {e}\")\n            return False\n    \n    def rebalance_stablecoins(self, target_ratio=0.5):\n        \"\"\"Rebalance USDT/USDC to maintain target ratio\"\"\"\n        try:\n            balances = self.get_balances()\n            \n            if 'USDT' not in balances or 'USDC' not in balances:\n                self.logger.warning(\"USDT or USDC balance not found\")\n                return\n            \n            usdt_balance = balances['USDT']['free']\n            usdc_balance = balances['USDC']['free']\n            total_stable = usdt_balance + usdc_balance\n            \n            if total_stable == 0:\n                return\n            \n            target_usdt = total_stable * target_ratio\n            target_usdc = total_stable * (1 - target_ratio)\n            \n            usdt_diff = target_usdt - usdt_balance\n            usdc_diff = target_usdc - usdc_balance\n            \n            # Only rebalance if difference is significant (>5%)\n            if abs(usdt_diff) / total_stable > 0.05:\n                if usdt_diff > 0:\n                    # Need more USDT, convert USDC to USDT\n                    self.update_balance('USDC', -abs(usdt_diff))\n                    self.update_balance('USDT', abs(usdt_diff))\n                    self.logger.info(f\"Rebalanced: Converted {abs(usdt_diff):.2f} USDC to USDT\")\n                else:\n                    # Need more USDC, convert USDT to USDC\n                    self.update_balance('USDT', -abs(usdc_diff))\n                    self.update_balance('USDC', abs(usdc_diff))\n                    self.logger.info(f\"Rebalanced: Converted {abs(usdc_diff):.2f} USDT to USDC\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error rebalancing stablecoins: {e}\")\n    \n    def get_balance_summary(self):\n        \"\"\"Get balance summary with totals\"\"\"\n        try:\n            balances = self.get_balances()\n            \n            # Calculate USD equivalents (assuming XRP price)\n            from core.price_monitor import PriceMonitor\n            price_monitor = PriceMonitor()\n            prices = price_monitor.get_current_prices()\n            \n            xrp_price = 0.52  # Default fallback\n            if 'XRP/USDT' in prices:\n                xrp_price = prices['XRP/USDT']['price']\n            \n            summary = {\n                'balances': balances,\n                'totals': {\n                    'xrp_usd_value': balances.get('XRP', {}).get('total', 0) * xrp_price,\n                    'stable_total': (balances.get('USDT', {}).get('total', 0) + \n                                   balances.get('USDC', {}).get('total', 0)),\n                    'portfolio_total': 0\n                }\n            }\n            \n            summary['totals']['portfolio_total'] = (\n                summary['totals']['xrp_usd_value'] + \n                summary['totals']['stable_total']\n            )\n            \n            return summary\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting balance summary: {e}\")\n            return {'balances': {}, 'totals': {}}\n","size_bytes":8189},"core/config_manager.py":{"content":"import logging\nfrom app import db\nfrom models import TradingConfig\n\nclass ConfigManager:\n    \"\"\"Configuration management for trading system\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self._ensure_default_config()\n    \n    def _ensure_default_config(self):\n        \"\"\"Ensure default configuration exists\"\"\"\n        try:\n            config = TradingConfig.query.first()\n            if not config:\n                default_config = TradingConfig(\n                    spread_threshold=0.003,\n                    trade_amount=100.0,\n                    daily_max_volume=5000.0,\n                    risk_buffer=0.1,\n                    max_pending_orders=3\n                )\n                db.session.add(default_config)\n                db.session.commit()\n                self.logger.info(\"Created default trading configuration\")\n        except Exception as e:\n            self.logger.error(f\"Error ensuring default config: {e}\")\n            db.session.rollback()\n    \n    def get_config(self):\n        \"\"\"Get current trading configuration\"\"\"\n        try:\n            config = TradingConfig.query.first()\n            if not config:\n                self._ensure_default_config()\n                config = TradingConfig.query.first()\n            \n            return config\n        except Exception as e:\n            self.logger.error(f\"Error getting config: {e}\")\n            return None\n    \n    def update_config(self, config_data):\n        \"\"\"Update trading configuration\"\"\"\n        try:\n            config = TradingConfig.query.first()\n            if not config:\n                config = TradingConfig()\n                db.session.add(config)\n            \n            # Update configuration fields\n            if 'spread_threshold' in config_data:\n                config.spread_threshold = float(config_data['spread_threshold'])\n            \n            if 'trade_amount' in config_data:\n                config.trade_amount = float(config_data['trade_amount'])\n            \n            if 'daily_max_volume' in config_data:\n                config.daily_max_volume = float(config_data['daily_max_volume'])\n            \n            if 'risk_buffer' in config_data:\n                config.risk_buffer = float(config_data['risk_buffer'])\n            \n            if 'max_pending_orders' in config_data:\n                config.max_pending_orders = int(config_data['max_pending_orders'])\n            \n            db.session.commit()\n            self.logger.info(\"Configuration updated successfully\")\n            \n            return config\n            \n        except Exception as e:\n            self.logger.error(f\"Error updating config: {e}\")\n            db.session.rollback()\n            return None\n    \n    def get_config_dict(self):\n        \"\"\"Get configuration as dictionary\"\"\"\n        try:\n            config = self.get_config()\n            if not config:\n                return {}\n            \n            return {\n                'spread_threshold': config.spread_threshold,\n                'trade_amount': config.trade_amount,\n                'daily_max_volume': config.daily_max_volume,\n                'risk_buffer': config.risk_buffer,\n                'max_pending_orders': config.max_pending_orders,\n                'updated_at': config.updated_at.isoformat() if config.updated_at else None\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting config dict: {e}\")\n            return {}\n    \n    def validate_config(self, config_data):\n        \"\"\"Validate configuration parameters\"\"\"\n        errors = []\n        \n        try:\n            # Validate spread threshold\n            if 'spread_threshold' in config_data:\n                threshold = float(config_data['spread_threshold'])\n                if threshold <= 0 or threshold >= 0.1:\n                    errors.append(\"Spread threshold must be between 0 and 0.1 (10%)\")\n            \n            # Validate trade amount\n            if 'trade_amount' in config_data:\n                amount = float(config_data['trade_amount'])\n                if amount <= 0 or amount > 10000:\n                    errors.append(\"Trade amount must be between 0 and 10,000 XRP\")\n            \n            # Validate daily max volume\n            if 'daily_max_volume' in config_data:\n                volume = float(config_data['daily_max_volume'])\n                if volume <= 0 or volume > 100000:\n                    errors.append(\"Daily max volume must be between 0 and 100,000 XRP\")\n            \n            # Validate risk buffer\n            if 'risk_buffer' in config_data:\n                buffer = float(config_data['risk_buffer'])\n                if buffer < 0 or buffer > 0.5:\n                    errors.append(\"Risk buffer must be between 0 and 0.5 (50%)\")\n            \n            # Validate max pending orders\n            if 'max_pending_orders' in config_data:\n                max_orders = int(config_data['max_pending_orders'])\n                if max_orders < 1 or max_orders > 10:\n                    errors.append(\"Max pending orders must be between 1 and 10\")\n            \n            # Cross-validation: trade amount vs daily volume\n            if ('trade_amount' in config_data and 'daily_max_volume' in config_data):\n                trade_amount = float(config_data['trade_amount'])\n                daily_volume = float(config_data['daily_max_volume'])\n                if trade_amount > daily_volume:\n                    errors.append(\"Trade amount cannot exceed daily max volume\")\n            \n        except ValueError as e:\n            errors.append(f\"Invalid number format: {e}\")\n        except Exception as e:\n            errors.append(f\"Validation error: {e}\")\n        \n        return {\n            'valid': len(errors) == 0,\n            'errors': errors\n        }\n    \n    def reset_to_defaults(self):\n        \"\"\"Reset configuration to default values\"\"\"\n        try:\n            config = TradingConfig.query.first()\n            if config:\n                db.session.delete(config)\n            \n            self._ensure_default_config()\n            self.logger.info(\"Configuration reset to defaults\")\n            \n            return self.get_config()\n            \n        except Exception as e:\n            self.logger.error(f\"Error resetting config: {e}\")\n            db.session.rollback()\n            return None\n    \n    def get_config_history(self, limit=10):\n        \"\"\"Get configuration change history\"\"\"\n        try:\n            # This would require a config history table in a real implementation\n            # For now, return the current config\n            configs = TradingConfig.query.order_by(TradingConfig.updated_at.desc()).limit(limit).all()\n            \n            history = []\n            for config in configs:\n                history.append({\n                    'id': config.id,\n                    'spread_threshold': config.spread_threshold,\n                    'trade_amount': config.trade_amount,\n                    'daily_max_volume': config.daily_max_volume,\n                    'risk_buffer': config.risk_buffer,\n                    'max_pending_orders': config.max_pending_orders,\n                    'updated_at': config.updated_at.isoformat() if config.updated_at else None\n                })\n            \n            return history\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting config history: {e}\")\n            return []\n","size_bytes":7456},"core/data_logger.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom app import db\nfrom models import SystemLog, Trade\n\nclass DataLogger:\n    \"\"\"Transaction logging and history management\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        \n        # Configure file logging\n        file_handler = logging.FileHandler('trading_system.log')\n        file_handler.setLevel(logging.INFO)\n        \n        formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n        file_handler.setFormatter(formatter)\n        \n        self.logger.addHandler(file_handler)\n    \n    def log_trade(self, trade_data, trade_type='info'):\n        \"\"\"Log trade information\"\"\"\n        try:\n            message = f\"Trade {trade_type}: {trade_data}\"\n            self.logger.info(message)\n            \n            # Store in database\n            log_entry = SystemLog(\n                level='INFO',\n                message=message,\n                module='TradeLogger'\n            )\n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging trade: {e}\")\n    \n    def log_arbitrage_opportunity(self, opportunity):\n        \"\"\"Log arbitrage opportunity\"\"\"\n        try:\n            message = (f\"Arbitrage opportunity detected - \"\n                      f\"Spread: {opportunity.get('spread_percentage', 0):.4f}%, \"\n                      f\"USDT: {opportunity.get('usdt_price', 0):.4f}, \"\n                      f\"USDC: {opportunity.get('usdc_price', 0):.4f}\")\n            \n            self.logger.info(message)\n            \n            log_entry = SystemLog(\n                level='INFO',\n                message=message,\n                module='ArbitrageEngine'\n            )\n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging arbitrage opportunity: {e}\")\n    \n    def log_balance_change(self, currency, old_balance, new_balance, reason):\n        \"\"\"Log balance changes\"\"\"\n        try:\n            change = new_balance - old_balance\n            message = (f\"Balance change - {currency}: \"\n                      f\"{old_balance:.4f} -> {new_balance:.4f} \"\n                      f\"(Δ{change:+.4f}) - Reason: {reason}\")\n            \n            self.logger.info(message)\n            \n            log_entry = SystemLog(\n                level='INFO',\n                message=message,\n                module='BalanceManager'\n            )\n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging balance change: {e}\")\n    \n    def log_risk_event(self, risk_type, details, severity='WARNING'):\n        \"\"\"Log risk management events\"\"\"\n        try:\n            message = f\"Risk Event ({risk_type}): {details}\"\n            \n            if severity == 'ERROR':\n                self.logger.error(message)\n            elif severity == 'WARNING':\n                self.logger.warning(message)\n            else:\n                self.logger.info(message)\n            \n            log_entry = SystemLog(\n                level=severity,\n                message=message,\n                module='RiskController'\n            )\n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging risk event: {e}\")\n    \n    def log_system_event(self, event_type, details, module='System'):\n        \"\"\"Log general system events\"\"\"\n        try:\n            message = f\"{event_type}: {details}\"\n            self.logger.info(message)\n            \n            log_entry = SystemLog(\n                level='INFO',\n                message=message,\n                module=module\n            )\n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging system event: {e}\")\n    \n    def log_error(self, error_message, module='Unknown', exception=None):\n        \"\"\"Log errors with optional exception details\"\"\"\n        try:\n            if exception:\n                message = f\"Error in {module}: {error_message} - Exception: {str(exception)}\"\n            else:\n                message = f\"Error in {module}: {error_message}\"\n            \n            self.logger.error(message)\n            \n            log_entry = SystemLog(\n                level='ERROR',\n                message=message,\n                module=module\n            )\n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging error: {e}\")\n    \n    def get_recent_logs(self, limit=100, level=None):\n        \"\"\"Get recent system logs\"\"\"\n        try:\n            query = SystemLog.query\n            \n            if level:\n                query = query.filter_by(level=level)\n            \n            logs = query.order_by(SystemLog.timestamp.desc()).limit(limit).all()\n            \n            return [{\n                'id': log.id,\n                'timestamp': log.timestamp.isoformat(),\n                'level': log.level,\n                'message': log.message,\n                'module': log.module\n            } for log in logs]\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting recent logs: {e}\")\n            return []\n    \n    def get_trade_history(self, days=7, status=None):\n        \"\"\"Get trade history\"\"\"\n        try:\n            cutoff_date = datetime.utcnow() - timedelta(days=days)\n            query = Trade.query.filter(Trade.created_at >= cutoff_date)\n            \n            if status:\n                query = query.filter_by(status=status)\n            \n            trades = query.order_by(Trade.created_at.desc()).all()\n            \n            return [{\n                'id': trade.id,\n                'type': trade.trade_type,\n                'pair': trade.pair,\n                'amount': trade.amount,\n                'price': trade.price,\n                'total_value': trade.total_value,\n                'profit_loss': trade.profit_loss,\n                'status': trade.status,\n                'created_at': trade.created_at.isoformat(),\n                'completed_at': trade.completed_at.isoformat() if trade.completed_at else None\n            } for trade in trades]\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting trade history: {e}\")\n            return []\n    \n    def cleanup_old_logs(self, days_to_keep=30):\n        \"\"\"Clean up old log entries\"\"\"\n        try:\n            cutoff_date = datetime.utcnow() - timedelta(days=days_to_keep)\n            \n            # Delete old system logs\n            old_logs = SystemLog.query.filter(SystemLog.timestamp < cutoff_date)\n            deleted_count = old_logs.count()\n            old_logs.delete()\n            \n            db.session.commit()\n            \n            self.logger.info(f\"Cleaned up {deleted_count} old log entries\")\n            return deleted_count\n            \n        except Exception as e:\n            self.logger.error(f\"Error cleaning up old logs: {e}\")\n            db.session.rollback()\n            return 0\n    \n    def export_trade_history(self, start_date=None, end_date=None):\n        \"\"\"Export trade history for analysis\"\"\"\n        try:\n            query = Trade.query\n            \n            if start_date:\n                query = query.filter(Trade.created_at >= start_date)\n            if end_date:\n                query = query.filter(Trade.created_at <= end_date)\n            \n            trades = query.order_by(Trade.created_at).all()\n            \n            # Prepare data for export\n            export_data = []\n            for trade in trades:\n                export_data.append({\n                    'timestamp': trade.created_at.isoformat(),\n                    'type': trade.trade_type,\n                    'pair': trade.pair,\n                    'amount': trade.amount,\n                    'price': trade.price,\n                    'total_value': trade.total_value,\n                    'profit_loss': trade.profit_loss or 0,\n                    'status': trade.status,\n                    'order_id': trade.order_id\n                })\n            \n            return export_data\n            \n        except Exception as e:\n            self.logger.error(f\"Error exporting trade history: {e}\")\n            return []\n","size_bytes":8595},"core/latency_optimizer.py":{"content":"import time\nimport threading\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Callable\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport psutil\nimport gc\n\nclass LatencyOptimizer:\n    \"\"\"⚡ 超低延迟优化引擎 - 毫秒级交易执行\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        \n        # 性能监控\n        self.execution_times = []\n        self.network_latencies = []\n        self.processing_times = []\n        \n        # 优化配置\n        self.cpu_optimization = True\n        self.memory_optimization = True\n        self.network_optimization = True\n        self.gc_optimization = True\n        \n        # 执行器池\n        self.fast_executor = ThreadPoolExecutor(\n            max_workers=4, \n            thread_name_prefix=\"FastExec\"\n        )\n        self.critical_executor = ThreadPoolExecutor(\n            max_workers=2, \n            thread_name_prefix=\"CriticalExec\"\n        )\n        \n        # 缓存和预分配\n        self.order_cache = {}\n        self.price_cache = {}\n        self.balance_cache = {}\n        self.cache_update_time = {}\n        \n        # 网络连接池\n        self.connection_pool = {}\n        self.keepalive_sessions = {}\n        \n        # 性能基准\n        self.performance_baseline = {\n            'order_execution': 50,  # 50ms目标\n            'price_fetch': 20,      # 20ms目标\n            'balance_check': 15,    # 15ms目标\n            'spread_calc': 5        # 5ms目标\n        }\n        \n        # 启动优化\n        self._initialize_optimizations()\n    \n    def _initialize_optimizations(self):\n        \"\"\"初始化所有性能优化\"\"\"\n        try:\n            if self.cpu_optimization:\n                self._optimize_cpu_usage()\n            \n            if self.memory_optimization:\n                self._optimize_memory_usage()\n            \n            if self.gc_optimization:\n                self._optimize_garbage_collection()\n            \n            self.logger.info(\"⚡ 延迟优化引擎已启动\")\n            \n        except Exception as e:\n            self.logger.error(f\"初始化优化失败: {e}\")\n    \n    def _optimize_cpu_usage(self):\n        \"\"\"优化CPU使用\"\"\"\n        try:\n            # 设置进程优先级（如果可能）\n            try:\n                process = psutil.Process()\n                if hasattr(process, 'nice'):\n                    process.nice(-10)  # 提高优先级\n                    self.logger.info(\"🚀 CPU优先级已提升\")\n            except (psutil.AccessDenied, AttributeError):\n                self.logger.warning(\"⚠️ 无法提升CPU优先级\")\n            \n            # 设置CPU亲和性到性能核心\n            try:\n                process = psutil.Process()\n                cpu_count = psutil.cpu_count()\n                if cpu_count > 4:\n                    # 使用前4个核心（通常是性能核心）\n                    process.cpu_affinity([0, 1, 2, 3])\n                    self.logger.info(f\"🎯 CPU亲和性设置为核心0-3\")\n            except (psutil.AccessDenied, AttributeError):\n                self.logger.warning(\"⚠️ 无法设置CPU亲和性\")\n                \n        except Exception as e:\n            self.logger.error(f\"CPU优化失败: {e}\")\n    \n    def _optimize_memory_usage(self):\n        \"\"\"优化内存使用\"\"\"\n        try:\n            # 预分配关键数据结构\n            self.order_cache = {i: None for i in range(100)}  # 预分配100个订单槽位\n            self.price_cache = {f\"slot_{i}\": None for i in range(50)}  # 预分配价格缓存\n            \n            # 内存池优化\n            self._preallocate_memory_pools()\n            \n            self.logger.info(\"🧠 内存优化已完成\")\n            \n        except Exception as e:\n            self.logger.error(f\"内存优化失败: {e}\")\n    \n    def _preallocate_memory_pools(self):\n        \"\"\"预分配内存池\"\"\"\n        try:\n            # 预分配常用对象\n            self.object_pools = {\n                'order_data': [{}] * 50,\n                'price_data': [{}] * 100,\n                'calculations': [0.0] * 200\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"预分配内存池失败: {e}\")\n    \n    def _optimize_garbage_collection(self):\n        \"\"\"优化垃圾回收\"\"\"\n        try:\n            import gc\n            \n            # 设置垃圾回收阈值\n            gc.set_threshold(1000, 15, 15)  # 降低GC频率\n            \n            # 启动后台GC线程\n            def background_gc():\n                while True:\n                    time.sleep(60)  # 每分钟清理一次\n                    if not self._is_critical_period():\n                        gc.collect(0)  # 只清理最新代\n            \n            gc_thread = threading.Thread(target=background_gc, daemon=True)\n            gc_thread.start()\n            \n            self.logger.info(\"🗑️ 垃圾回收优化已启动\")\n            \n        except Exception as e:\n            self.logger.error(f\"垃圾回收优化失败: {e}\")\n    \n    def _is_critical_period(self) -> bool:\n        \"\"\"检查是否在关键交易期间\"\"\"\n        try:\n            # 检查是否有正在执行的关键操作\n            current_time = datetime.utcnow()\n            \n            # 如果有活跃的订单执行，认为是关键期间\n            active_orders = len([t for t in self.execution_times[-10:] \n                               if (current_time - t['timestamp']).total_seconds() < 30])\n            \n            return active_orders > 0\n            \n        except Exception as e:\n            return False\n    \n    def measure_execution_time(self, operation_name: str):\n        \"\"\"装饰器：测量执行时间\"\"\"\n        def decorator(func):\n            def wrapper(*args, **kwargs):\n                start_time = time.perf_counter()\n                try:\n                    result = func(*args, **kwargs)\n                    return result\n                finally:\n                    end_time = time.perf_counter()\n                    execution_time = (end_time - start_time) * 1000  # 转换为毫秒\n                    \n                    self._record_execution_time(operation_name, execution_time)\n                    \n                    # 如果超过基准，记录警告\n                    baseline = self.performance_baseline.get(operation_name, 100)\n                    if execution_time > baseline * 1.5:\n                        self.logger.warning(f\"⚠️ {operation_name} 执行超时: {execution_time:.2f}ms (基准: {baseline}ms)\")\n            \n            return wrapper\n        return decorator\n    \n    def _record_execution_time(self, operation: str, execution_time: float):\n        \"\"\"记录执行时间\"\"\"\n        try:\n            record = {\n                'operation': operation,\n                'execution_time': execution_time,\n                'timestamp': datetime.utcnow()\n            }\n            \n            self.execution_times.append(record)\n            \n            # 保持最近1000条记录\n            if len(self.execution_times) > 1000:\n                self.execution_times = self.execution_times[-1000:]\n                \n        except Exception as e:\n            self.logger.error(f\"记录执行时间失败: {e}\")\n    \n    def execute_order_fast(self, order_params: Dict) -> Dict:\n        \"\"\"超快速订单执行\"\"\"\n        start_time = time.perf_counter()\n        try:\n            # 使用关键执行器\n            future = self.critical_executor.submit(self._internal_order_execution, order_params)\n            \n            # 设置短超时\n            result = future.result(timeout=2.0)\n            \n            return result\n            \n        except Exception as e:\n            self.logger.error(f\"快速订单执行失败: {e}\")\n            return {'success': False, 'error': str(e)}\n        finally:\n            # 记录执行时间\n            execution_time = (time.perf_counter() - start_time) * 1000\n            self._record_execution_time(\"fast_order_execution\", execution_time)\n    \n    def _internal_order_execution(self, order_params: Dict) -> Dict:\n        \"\"\"内部订单执行逻辑\"\"\"\n        try:\n            # 模拟快速订单执行\n            start_time = time.perf_counter()\n            \n            # 预验证（使用缓存）\n            if not self._fast_validate_order(order_params):\n                return {'success': False, 'error': 'validation_failed'}\n            \n            # 执行订单\n            order_result = self._submit_order_optimized(order_params)\n            \n            end_time = time.perf_counter()\n            execution_time = (end_time - start_time) * 1000\n            \n            return {\n                'success': True,\n                'order_id': f\"fast_{int(time.time() * 1000)}\",\n                'execution_time': execution_time,\n                'optimized': True\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"内部订单执行失败: {e}\")\n            return {'success': False, 'error': str(e)}\n    \n    def _fast_validate_order(self, order_params: Dict) -> bool:\n        \"\"\"快速订单验证（使用缓存）\"\"\"\n        try:\n            # 使用缓存的余额信息\n            symbol = order_params.get('symbol', '')\n            amount = order_params.get('amount', 0)\n            \n            # 快速余额检查\n            cache_key = f\"balance_{symbol}\"\n            if cache_key in self.balance_cache:\n                cached_balance = self.balance_cache[cache_key]\n                if cached_balance['amount'] >= amount:\n                    return True\n            \n            # 如果缓存未命中，执行快速验证\n            return amount > 0 and amount < 10000  # 简化验证\n            \n        except Exception as e:\n            self.logger.error(f\"快速验证失败: {e}\")\n            return False\n    \n    def _submit_order_optimized(self, order_params: Dict) -> Dict:\n        \"\"\"优化的订单提交\"\"\"\n        try:\n            # 使用连接池和keepalive\n            # 这里模拟优化的订单提交\n            time.sleep(0.01)  # 模拟10ms网络延迟\n            \n            return {\n                'order_id': f\"opt_{int(time.time() * 1000)}\",\n                'status': 'submitted',\n                'timestamp': datetime.utcnow()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"优化订单提交失败: {e}\")\n            return {}\n    \n    def get_prices_fast(self, symbols: List[str]) -> Dict:\n        \"\"\"超快速价格获取\"\"\"\n        start_time = time.perf_counter()\n        try:\n            # 并行获取价格\n            with ThreadPoolExecutor(max_workers=len(symbols)) as executor:\n                futures = {\n                    executor.submit(self._fetch_single_price, symbol): symbol \n                    for symbol in symbols\n                }\n                \n                prices = {}\n                for future in as_completed(futures, timeout=1.0):\n                    symbol = futures[future]\n                    try:\n                        price_data = future.result()\n                        prices[symbol] = price_data\n                    except Exception as e:\n                        self.logger.error(f\"获取{symbol}价格失败: {e}\")\n                        prices[symbol] = None\n                \n                return prices\n                \n        except Exception as e:\n            self.logger.error(f\"快速价格获取失败: {e}\")\n            return {}\n        finally:\n            # 记录执行时间\n            execution_time = (time.perf_counter() - start_time) * 1000\n            self._record_execution_time(\"fast_price_fetch\", execution_time)\n    \n    def _fetch_single_price(self, symbol: str) -> Dict:\n        \"\"\"获取单个价格\"\"\"\n        try:\n            # 检查缓存\n            cache_key = f\"price_{symbol}\"\n            if cache_key in self.price_cache:\n                cached_data = self.price_cache[cache_key]\n                cache_time = self.cache_update_time.get(cache_key, datetime.min)\n                \n                # 如果缓存在5秒内，直接返回\n                if (datetime.utcnow() - cache_time).total_seconds() < 5:\n                    return cached_data\n            \n            # 模拟快速价格获取\n            import random\n            price_data = {\n                'symbol': symbol,\n                'price': round(0.52 + random.uniform(-0.02, 0.02), 4),\n                'timestamp': datetime.utcnow()\n            }\n            \n            # 更新缓存\n            self.price_cache[cache_key] = price_data\n            self.cache_update_time[cache_key] = datetime.utcnow()\n            \n            return price_data\n            \n        except Exception as e:\n            self.logger.error(f\"获取{symbol}价格失败: {e}\")\n            return {}\n    \n    def calculate_spread_fast(self, usdt_price: float, usdc_price: float) -> Dict:\n        \"\"\"超快速价差计算\"\"\"\n        start_time = time.perf_counter()\n        try:\n            # 预计算的优化\n            if usdt_price <= 0 or usdc_price <= 0:\n                return {'spread': 0, 'spread_pct': 0, 'valid': False}\n            \n            # 使用位运算优化\n            spread = abs(usdt_price - usdc_price)\n            min_price = min(usdt_price, usdc_price)\n            spread_pct = (spread / min_price) * 100\n            \n            return {\n                'spread': round(spread, 6),\n                'spread_pct': round(spread_pct, 4),\n                'usdt_higher': usdt_price > usdc_price,\n                'valid': True,\n                'calculated_at': time.perf_counter()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"快速价差计算失败: {e}\")\n            return {'spread': 0, 'spread_pct': 0, 'valid': False}\n        finally:\n            # 记录执行时间\n            execution_time = (time.perf_counter() - start_time) * 1000\n            self._record_execution_time(\"spread_calc\", execution_time)\n    \n    def optimize_cache_usage(self):\n        \"\"\"优化缓存使用\"\"\"\n        try:\n            current_time = datetime.utcnow()\n            \n            # 清理过期缓存\n            expired_keys = []\n            for key, update_time in self.cache_update_time.items():\n                if (current_time - update_time).total_seconds() > 300:  # 5分钟过期\n                    expired_keys.append(key)\n            \n            for key in expired_keys:\n                if key in self.price_cache:\n                    del self.price_cache[key]\n                if key in self.balance_cache:\n                    del self.balance_cache[key]\n                del self.cache_update_time[key]\n            \n            # 预热重要缓存\n            self._preheat_cache()\n            \n        except Exception as e:\n            self.logger.error(f\"优化缓存失败: {e}\")\n    \n    def _preheat_cache(self):\n        \"\"\"预热缓存\"\"\"\n        try:\n            # 预加载关键价格数据\n            important_symbols = ['XRPUSDT', 'XRPUSDC']\n            for symbol in important_symbols:\n                self._fetch_single_price(symbol)\n                \n        except Exception as e:\n            self.logger.error(f\"预热缓存失败: {e}\")\n    \n    def get_performance_report(self) -> Dict:\n        \"\"\"获取性能报告\"\"\"\n        try:\n            if not self.execution_times:\n                return {'status': 'no_data'}\n            \n            # 按操作分类统计\n            operation_stats = {}\n            for record in self.execution_times[-100:]:  # 最近100条\n                op = record['operation']\n                if op not in operation_stats:\n                    operation_stats[op] = []\n                operation_stats[op].append(record['execution_time'])\n            \n            # 计算统计信息\n            performance_summary = {}\n            for operation, times in operation_stats.items():\n                baseline = self.performance_baseline.get(operation, 100)\n                avg_time = sum(times) / len(times)\n                max_time = max(times)\n                min_time = min(times)\n                \n                performance_summary[operation] = {\n                    'avg_time': round(avg_time, 2),\n                    'max_time': round(max_time, 2),\n                    'min_time': round(min_time, 2),\n                    'baseline': baseline,\n                    'performance_ratio': round(baseline / avg_time, 2),\n                    'samples': len(times),\n                    'status': 'excellent' if avg_time < baseline * 0.8 \n                             else 'good' if avg_time < baseline \n                             else 'needs_improvement'\n                }\n            \n            # 系统资源状态\n            try:\n                process = psutil.Process()\n                system_stats = {\n                    'cpu_percent': process.cpu_percent(),\n                    'memory_mb': process.memory_info().rss / 1024 / 1024,\n                    'threads': process.num_threads(),\n                    'open_files': len(process.open_files()) if hasattr(process, 'open_files') else 0\n                }\n            except:\n                system_stats = {'status': 'unavailable'}\n            \n            return {\n                'performance_summary': performance_summary,\n                'system_stats': system_stats,\n                'cache_stats': {\n                    'price_cache_size': len(self.price_cache),\n                    'balance_cache_size': len(self.balance_cache),\n                    'cache_hit_rate': self._calculate_cache_hit_rate()\n                },\n                'optimization_status': {\n                    'cpu_optimized': self.cpu_optimization,\n                    'memory_optimized': self.memory_optimization,\n                    'network_optimized': self.network_optimization,\n                    'gc_optimized': self.gc_optimization\n                },\n                'generated_at': datetime.utcnow().isoformat()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"生成性能报告失败: {e}\")\n            return {'error': str(e)}\n    \n    def _calculate_cache_hit_rate(self) -> float:\n        \"\"\"计算缓存命中率\"\"\"\n        try:\n            # 简化的缓存命中率计算\n            if not hasattr(self, '_cache_requests'):\n                return 0.8  # 默认80%\n            \n            total_requests = getattr(self, '_cache_requests', 100)\n            cache_hits = getattr(self, '_cache_hits', 80)\n            \n            return cache_hits / total_requests if total_requests > 0 else 0\n            \n        except Exception as e:\n            return 0.5\n    \n    def shutdown(self):\n        \"\"\"关闭优化器\"\"\"\n        try:\n            self.fast_executor.shutdown(wait=True)\n            self.critical_executor.shutdown(wait=True)\n            \n            self.logger.info(\"⚡ 延迟优化引擎已关闭\")\n            \n        except Exception as e:\n            self.logger.error(f\"关闭优化器失败: {e}\")","size_bytes":19240},"core/mexc_connector.py":{"content":"import os\nimport time\nimport hmac\nimport hashlib\nimport requests\nimport logging\nfrom datetime import datetime\nfrom cryptography.fernet import Fernet\nfrom core.api_connector import APIConnector\n\nclass MEXCConnector(APIConnector):\n    \"\"\"MEXC Exchange-specific API connector with advanced features\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self.base_url = 'https://api.mexc.com'\n        self.ws_url = 'wss://wbs.mexc.com/ws'\n        self.exchange_name = 'MEXC'\n        self.logger = logging.getLogger(__name__)\n        \n        # MEXC-specific configuration\n        self.rate_limits = {\n            'orders': 20,  # Orders per second\n            'general': 10,  # General API calls per second\n            'market_data': 50  # Market data calls per second\n        }\n        \n        self.trading_fees = {\n            'maker': 0.0002,  # 0.02%\n            'taker': 0.0006   # 0.06%\n        }\n        \n        # Security\n        self.encrypted_credentials = None\n        self._load_encrypted_credentials()\n        \n        # Rate limiting\n        self._last_request_time = {}\n        self._request_counts = {}\n        \n    def _load_encrypted_credentials(self):\n        \"\"\"Load encrypted API credentials\"\"\"\n        try:\n            # Check for encrypted credentials in environment\n            encrypted_key = os.environ.get('MEXC_API_KEY_ENCRYPTED')\n            encrypted_secret = os.environ.get('MEXC_API_SECRET_ENCRYPTED')\n            encryption_key = os.environ.get('MEXC_ENCRYPTION_KEY')\n            \n            if encrypted_key and encrypted_secret and encryption_key:\n                fernet = Fernet(encryption_key.encode())\n                self.api_key = fernet.decrypt(encrypted_key.encode()).decode()\n                self.api_secret = fernet.decrypt(encrypted_secret.encode()).decode()\n                self.logger.info(\"Encrypted MEXC credentials loaded successfully\")\n            else:\n                # Fallback to plain text (development mode)\n                self.api_key = os.environ.get('MEXC_API_KEY', 'demo_key')\n                self.api_secret = os.environ.get('MEXC_API_SECRET', 'demo_secret')\n                self.logger.warning(\"Using plain text credentials (development mode)\")\n                \n        except Exception as e:\n            self.logger.error(f\"Error loading MEXC credentials: {e}\")\n            self.api_key = 'demo_key'\n            self.api_secret = 'demo_secret'\n    \n    def connect(self):\n        \"\"\"Connect to MEXC API with enhanced validation\"\"\"\n        try:\n            # Test connectivity\n            response = self._make_request('GET', '/api/v3/ping')\n            \n            if response.status_code == 200:\n                self.connected = True\n                self.logger.info(\"Connected to MEXC API successfully\")\n                \n                # Test authentication if credentials are provided\n                if self.api_key != 'demo_key':\n                    self._test_authentication()\n                    \n                return True\n            else:\n                self.logger.error(f\"MEXC API connection failed: {response.status_code}\")\n                return False\n                \n        except Exception as e:\n            self.logger.error(f\"Error connecting to MEXC API: {e}\")\n            return False\n    \n    def _test_authentication(self):\n        \"\"\"Test API authentication\"\"\"\n        try:\n            # Get account information to test auth\n            response = self._make_authenticated_request('GET', '/api/v3/account')\n            \n            if response.status_code == 200:\n                self.authenticated = True\n                self.logger.info(\"MEXC API authentication successful\")\n            else:\n                self.logger.error(f\"MEXC API authentication failed: {response.status_code}\")\n                \n        except Exception as e:\n            self.logger.error(f\"Error testing MEXC authentication: {e}\")\n    \n    def _make_authenticated_request(self, method, endpoint, params=None):\n        \"\"\"Make authenticated request with MEXC signature\"\"\"\n        try:\n            if not params:\n                params = {}\n            \n            # Add timestamp\n            timestamp = int(time.time() * 1000)\n            params['timestamp'] = timestamp\n            \n            # Create query string\n            query_string = '&'.join([f\"{key}={value}\" for key, value in sorted(params.items())])\n            \n            # Create signature\n            signature = hmac.new(\n                self.api_secret.encode(),\n                query_string.encode(),\n                hashlib.sha256\n            ).hexdigest()\n            \n            params['signature'] = signature\n            \n            # Add API key to headers\n            headers = {\n                'X-MEXC-APIKEY': self.api_key,\n                'Content-Type': 'application/json'\n            }\n            \n            return self._make_request(method, endpoint, params, headers)\n            \n        except Exception as e:\n            self.logger.error(f\"Error making authenticated MEXC request: {e}\")\n            return None\n    \n    def _make_request(self, method, endpoint, params=None, headers=None):\n        \"\"\"Make rate-limited request to MEXC API\"\"\"\n        try:\n            # Apply rate limiting\n            if not self._check_rate_limit(endpoint):\n                time.sleep(0.1)  # Brief pause if rate limited\n            \n            url = f\"{self.base_url}{endpoint}\"\n            \n            if method == 'GET':\n                response = requests.get(url, params=params, headers=headers, timeout=10)\n            elif method == 'POST':\n                response = requests.post(url, json=params, headers=headers, timeout=10)\n            else:\n                raise ValueError(f\"Unsupported HTTP method: {method}\")\n            \n            # Update rate limiting counters\n            self._update_rate_limit_counters(endpoint)\n            \n            return response\n            \n        except requests.exceptions.RequestException as e:\n            self.logger.error(f\"MEXC API request error: {e}\")\n            raise\n    \n    def _check_rate_limit(self, endpoint):\n        \"\"\"Check if request would exceed rate limits\"\"\"\n        current_time = time.time()\n        \n        # Determine rate limit category\n        if '/order' in endpoint:\n            category = 'orders'\n        elif '/ticker' in endpoint or '/depth' in endpoint:\n            category = 'market_data'\n        else:\n            category = 'general'\n        \n        limit = self.rate_limits[category]\n        \n        # Check if we have recent requests in this category\n        if category not in self._request_counts:\n            self._request_counts[category] = []\n        \n        # Remove old requests (older than 1 second)\n        self._request_counts[category] = [\n            req_time for req_time in self._request_counts[category]\n            if current_time - req_time < 1.0\n        ]\n        \n        # Check if we're under the limit\n        return len(self._request_counts[category]) < limit\n    \n    def _update_rate_limit_counters(self, endpoint):\n        \"\"\"Update rate limiting counters\"\"\"\n        current_time = time.time()\n        \n        # Determine category\n        if '/order' in endpoint:\n            category = 'orders'\n        elif '/ticker' in endpoint or '/depth' in endpoint:\n            category = 'market_data'\n        else:\n            category = 'general'\n        \n        if category not in self._request_counts:\n            self._request_counts[category] = []\n        \n        self._request_counts[category].append(current_time)\n    \n    def create_order(self, symbol, order_type, side, amount, price=None):\n        \"\"\"Create order with MEXC-specific parameters\"\"\"\n        try:\n            if not self.authenticated:\n                return self._simulate_order(symbol, order_type, side, amount, price)\n            \n            params = {\n                'symbol': symbol.replace('/', ''),  # MEXC format: XRPUSDT\n                'side': side.upper(),\n                'type': order_type.upper(),\n                'quantity': str(amount),\n                'timeInForce': 'IOC'  # Immediate or Cancel for arbitrage\n            }\n            \n            if price:\n                params['price'] = str(price)\n            \n            response = self._make_authenticated_request('POST', '/api/v3/order', params)\n            \n            if response and response.status_code == 200:\n                order_data = response.json()\n                return {\n                    'id': order_data.get('orderId'),\n                    'symbol': symbol,\n                    'side': side,\n                    'amount': amount,\n                    'price': price or order_data.get('price', 0),\n                    'status': 'pending',\n                    'timestamp': datetime.utcnow().isoformat()\n                }\n            else:\n                self.logger.error(f\"MEXC order creation failed: {response.status_code if response else 'No response'}\")\n                return None\n                \n        except Exception as e:\n            self.logger.error(f\"Error creating MEXC order: {e}\")\n            return None\n    \n    def get_order_status(self, order_id, symbol):\n        \"\"\"Get order status from MEXC\"\"\"\n        try:\n            if not self.authenticated:\n                return self._simulate_order_status(order_id)\n            \n            params = {\n                'symbol': symbol.replace('/', ''),\n                'orderId': order_id\n            }\n            \n            response = self._make_authenticated_request('GET', '/api/v3/order', params)\n            \n            if response and response.status_code == 200:\n                order_data = response.json()\n                return {\n                    'id': order_data.get('orderId'),\n                    'status': self._map_mexc_status(order_data.get('status')),\n                    'filled_amount': float(order_data.get('executedQty', 0)),\n                    'price': float(order_data.get('price', 0))\n                }\n            else:\n                return {'status': 'unknown'}\n                \n        except Exception as e:\n            self.logger.error(f\"Error getting MEXC order status: {e}\")\n            return {'status': 'error'}\n    \n    def _map_mexc_status(self, mexc_status):\n        \"\"\"Map MEXC order status to our standard format\"\"\"\n        status_map = {\n            'NEW': 'pending',\n            'PARTIALLY_FILLED': 'partial',\n            'FILLED': 'closed',\n            'CANCELED': 'cancelled',\n            'REJECTED': 'rejected',\n            'EXPIRED': 'expired'\n        }\n        return status_map.get(mexc_status, 'unknown')\n    \n    def cancel_order(self, order_id, symbol):\n        \"\"\"Cancel order on MEXC\"\"\"\n        try:\n            if not self.authenticated:\n                return True  # Simulate success in demo mode\n            \n            params = {\n                'symbol': symbol.replace('/', ''),\n                'orderId': order_id\n            }\n            \n            response = self._make_authenticated_request('DELETE', '/api/v3/order', params)\n            \n            return response and response.status_code == 200\n            \n        except Exception as e:\n            self.logger.error(f\"Error cancelling MEXC order: {e}\")\n            return False\n    \n    def get_market_data(self, symbol):\n        \"\"\"Get real-time market data from MEXC\"\"\"\n        try:\n            mexc_symbol = symbol.replace('/', '')\n            response = self._make_request('GET', f'/api/v3/ticker/24hr', {'symbol': mexc_symbol})\n            \n            if response and response.status_code == 200:\n                data = response.json()\n                return {\n                    'symbol': symbol,\n                    'price': float(data.get('lastPrice', 0)),\n                    'volume': float(data.get('volume', 0)),\n                    'high': float(data.get('highPrice', 0)),\n                    'low': float(data.get('lowPrice', 0)),\n                    'change': float(data.get('priceChangePercent', 0)),\n                    'timestamp': datetime.utcnow().isoformat()\n                }\n            else:\n                return self._simulate_market_data(symbol)\n                \n        except Exception as e:\n            self.logger.error(f\"Error getting MEXC market data: {e}\")\n            return self._simulate_market_data(symbol)\n    \n    def get_account_balance(self):\n        \"\"\"Get account balance from MEXC\"\"\"\n        try:\n            if not self.authenticated:\n                return self._simulate_balances()\n            \n            response = self._make_authenticated_request('GET', '/api/v3/account')\n            \n            if response and response.status_code == 200:\n                account_data = response.json()\n                balances = {}\n                \n                for balance in account_data.get('balances', []):\n                    asset = balance.get('asset')\n                    free = float(balance.get('free', 0))\n                    locked = float(balance.get('locked', 0))\n                    \n                    if free > 0 or locked > 0:\n                        balances[asset] = {\n                            'free': free,\n                            'locked': locked,\n                            'total': free + locked\n                        }\n                \n                return balances\n            else:\n                return self._simulate_balances()\n                \n        except Exception as e:\n            self.logger.error(f\"Error getting MEXC account balance: {e}\")\n            return self._simulate_balances()\n    \n    def get_trading_fees(self):\n        \"\"\"Get current trading fees\"\"\"\n        return self.trading_fees\n    \n    def _simulate_balances(self):\n        \"\"\"Simulate account balances for testing\"\"\"\n        return {\n            'XRP': {'free': 10000.0, 'locked': 0.0, 'total': 10000.0},\n            'USDT': {'free': 5000.0, 'locked': 0.0, 'total': 5000.0},\n            'USDC': {'free': 5000.0, 'locked': 0.0, 'total': 5000.0}\n        }","size_bytes":14074},"core/order_manager.py":{"content":"import time\nimport threading\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional\nfrom app import db\nfrom models import Trade, CircuitBreaker\nfrom core.mexc_connector import MEXCConnector\nfrom core.volume_tracker import VolumeTracker\n\nclass OrderManager:\n    \"\"\"专业订单管理系统 - 超时监控和自动取消\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.mexc_connector = MEXCConnector()\n        self.volume_tracker = VolumeTracker()\n        \n        # 订单监控配置\n        self.monitoring_active = False\n        self.monitor_thread = None\n        self.timeout_configs = {\n            'limit_order': 30,      # 限价单30秒超时\n            'market_order': 10,     # 市价单10秒超时\n            'arbitrage_order': 20,  # 套利单20秒超时\n        }\n        \n        # 订单状态缓存\n        self.order_cache = {}\n        self.pending_orders = {}\n        \n        # 性能监控\n        self.execution_times = []\n        self.timeout_counts = {'limit': 0, 'market': 0, 'arbitrage': 0}\n        \n    def start_monitoring(self):\n        \"\"\"启动订单监控系统\"\"\"\n        try:\n            if self.monitoring_active:\n                self.logger.warning(\"订单监控已在运行\")\n                return\n            \n            self.monitoring_active = True\n            self.monitor_thread = threading.Thread(target=self._monitoring_loop, daemon=True)\n            self.monitor_thread.start()\n            \n            self.logger.info(\"📊 专业订单监控系统已启动\")\n            \n        except Exception as e:\n            self.logger.error(f\"启动订单监控失败: {e}\")\n    \n    def stop_monitoring(self):\n        \"\"\"停止订单监控系统\"\"\"\n        try:\n            self.monitoring_active = False\n            if self.monitor_thread and self.monitor_thread.is_alive():\n                self.monitor_thread.join(timeout=5)\n            \n            self.logger.info(\"🛑 订单监控系统已停止\")\n            \n        except Exception as e:\n            self.logger.error(f\"停止订单监控失败: {e}\")\n    \n    def _monitoring_loop(self):\n        \"\"\"监控循环 - 检查超时订单\"\"\"\n        from app import app\n        \n        while self.monitoring_active:\n            try:\n                with app.app_context():\n                    # 检查超时订单\n                    self._check_timeout_orders()\n                    \n                    # 更新订单状态\n                    self._update_pending_orders()\n                    \n                    # 清理过期缓存\n                    self._cleanup_cache()\n                \n                # 监控间隔\n                time.sleep(2)  # 每2秒检查一次\n                \n            except Exception as e:\n                self.logger.error(f\"订单监控循环错误: {e}\")\n                time.sleep(5)  # 错误时延长间隔\n    \n    def _check_timeout_orders(self):\n        \"\"\"检查并处理超时订单\"\"\"\n        try:\n            current_time = datetime.utcnow()\n            \n            # 获取所有待处理订单\n            pending_trades = Trade.query.filter_by(status='pending').all()\n            \n            for trade in pending_trades:\n                if not trade.created_at:\n                    continue\n                \n                # 计算订单年龄\n                order_age = (current_time - trade.created_at).total_seconds()\n                \n                # 确定超时时间\n                order_type = self._classify_order_type(trade)\n                timeout_seconds = self.timeout_configs.get(order_type, 30)\n                \n                if order_age > timeout_seconds:\n                    self._handle_timeout_order(trade, order_age, order_type)\n                    \n        except Exception as e:\n            self.logger.error(f\"检查超时订单错误: {e}\")\n    \n    def _classify_order_type(self, trade):\n        \"\"\"分类订单类型\"\"\"\n        # 根据订单特征分类\n        if hasattr(trade, 'order_type'):\n            return trade.order_type\n        \n        # 基于交易对和数量推断\n        if trade.amount > 500:  # 大额订单\n            return 'limit_order'\n        elif 'arbitrage' in trade.pair.lower():\n            return 'arbitrage_order'\n        else:\n            return 'market_order'\n    \n    def _handle_timeout_order(self, trade, order_age, order_type):\n        \"\"\"处理超时订单\"\"\"\n        try:\n            self.logger.warning(f\"⏰ 订单超时: {trade.id} ({order_type}, {order_age:.1f}秒)\")\n            \n            # 尝试获取最新状态\n            if trade.order_id:\n                try:\n                    status = self.mexc_connector.get_order_status(trade.order_id, trade.pair)\n                    \n                    if status['status'] == 'closed':\n                        # 订单已完成，更新状态\n                        trade.status = 'completed'\n                        trade.completed_at = datetime.utcnow()\n                        self.logger.info(f\"✅ 超时订单已完成: {trade.id}\")\n                        \n                        # 更新余额\n                        self._update_balances_for_completed_trade(trade)\n                        \n                    elif status['status'] in ['partial']:\n                        # 部分成交，等待完成\n                        self.logger.info(f\"⏳ 订单部分成交: {trade.id}\")\n                        trade.updated_at = datetime.utcnow()\n                        \n                    else:\n                        # 取消未完成的订单\n                        success = self.mexc_connector.cancel_order(trade.order_id, trade.pair)\n                        if success:\n                            trade.status = 'timeout_cancelled'\n                            self.logger.info(f\"❌ 超时订单已取消: {trade.id}\")\n                        else:\n                            trade.status = 'timeout_failed'\n                            self.logger.error(f\"🚨 超时订单取消失败: {trade.id}\")\n                        \n                        # 解锁余额\n                        self._unlock_trade_balances(trade)\n                        \n                except Exception as e:\n                    self.logger.error(f\"处理超时订单状态失败: {e}\")\n                    trade.status = 'timeout_error'\n                    self._unlock_trade_balances(trade)\n            \n            # 更新统计\n            self.timeout_counts[order_type] = self.timeout_counts.get(order_type, 0) + 1\n            \n            # 检查是否需要触发熔断\n            if self.timeout_counts[order_type] > 5:  # 5次超时触发熔断\n                self.volume_tracker.activate_circuit_breaker(\n                    'order_timeout',\n                    f'过多{order_type}订单超时: {self.timeout_counts[order_type]}次',\n                    self.timeout_counts[order_type],\n                    5\n                )\n            \n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"处理超时订单失败: {e}\")\n            db.session.rollback()\n    \n    def _update_pending_orders(self):\n        \"\"\"更新待处理订单状态\"\"\"\n        try:\n            pending_trades = Trade.query.filter_by(status='pending').limit(20).all()\n            \n            for trade in pending_trades:\n                if trade.order_id and trade.id not in self.order_cache:\n                    # 检查订单状态\n                    status = self.mexc_connector.get_order_status(trade.order_id, trade.pair)\n                    \n                    if status['status'] == 'closed':\n                        trade.status = 'completed'\n                        trade.completed_at = datetime.utcnow()\n                        self._update_balances_for_completed_trade(trade)\n                        \n                        # 记录执行时间\n                        if trade.created_at:\n                            execution_time = (datetime.utcnow() - trade.created_at).total_seconds()\n                            self.execution_times.append(execution_time)\n                            \n                            # 保持最近100次执行时间\n                            if len(self.execution_times) > 100:\n                                self.execution_times = self.execution_times[-100:]\n                    \n                    # 缓存状态检查\n                    self.order_cache[trade.id] = {\n                        'last_check': datetime.utcnow(),\n                        'status': status['status']\n                    }\n            \n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"更新订单状态失败: {e}\")\n            db.session.rollback()\n    \n    def _unlock_trade_balances(self, trade):\n        \"\"\"解锁交易相关的余额\"\"\"\n        try:\n            from core.balance_manager import BalanceManager\n            balance_manager = BalanceManager()\n            \n            if trade.trade_type == 'sell':\n                # 解锁XRP\n                balance_manager.unlock_balance('XRP', trade.amount)\n            else:\n                # 解锁稳定币\n                currency = 'USDT' if 'USDT' in trade.pair else 'USDC'\n                balance_manager.unlock_balance(currency, trade.total_value)\n                \n        except Exception as e:\n            self.logger.error(f\"解锁余额失败: {e}\")\n    \n    def _update_balances_for_completed_trade(self, trade):\n        \"\"\"更新已完成交易的余额\"\"\"\n        try:\n            from core.balance_manager import BalanceManager\n            balance_manager = BalanceManager()\n            \n            if trade.trade_type == 'sell':\n                # 卖单：减少XRP，增加稳定币\n                balance_manager.unlock_balance('XRP', trade.amount)\n                balance_manager.update_balance('XRP', -trade.amount)\n                \n                currency = 'USDT' if 'USDT' in trade.pair else 'USDC'\n                balance_manager.update_balance(currency, trade.total_value)\n                \n            else:\n                # 买单：减少稳定币，增加XRP\n                currency = 'USDT' if 'USDT' in trade.pair else 'USDC'\n                balance_manager.unlock_balance(currency, trade.total_value)\n                balance_manager.update_balance(currency, -trade.total_value)\n                balance_manager.update_balance('XRP', trade.amount)\n                \n        except Exception as e:\n            self.logger.error(f\"更新交易余额失败: {e}\")\n    \n    def _cleanup_cache(self):\n        \"\"\"清理过期缓存\"\"\"\n        try:\n            current_time = datetime.utcnow()\n            expired_keys = []\n            \n            for order_id, cache_data in self.order_cache.items():\n                if (current_time - cache_data['last_check']).total_seconds() > 300:  # 5分钟过期\n                    expired_keys.append(order_id)\n            \n            for key in expired_keys:\n                del self.order_cache[key]\n                \n        except Exception as e:\n            self.logger.error(f\"清理缓存失败: {e}\")\n    \n    def get_order_statistics(self):\n        \"\"\"获取订单统计信息\"\"\"\n        try:\n            current_time = datetime.utcnow()\n            today_start = current_time.replace(hour=0, minute=0, second=0, microsecond=0)\n            \n            # 今日订单统计\n            today_trades = Trade.query.filter(\n                Trade.created_at >= today_start\n            ).all()\n            \n            stats = {\n                'today_total': len(today_trades),\n                'today_completed': len([t for t in today_trades if t.status == 'completed']),\n                'today_timeout': len([t for t in today_trades if 'timeout' in t.status]),\n                'today_pending': len([t for t in today_trades if t.status == 'pending']),\n                'timeout_counts': self.timeout_counts.copy(),\n                'avg_execution_time': sum(self.execution_times) / len(self.execution_times) if self.execution_times else 0,\n                'max_execution_time': max(self.execution_times) if self.execution_times else 0,\n                'min_execution_time': min(self.execution_times) if self.execution_times else 0,\n                'monitoring_active': self.monitoring_active,\n                'cached_orders': len(self.order_cache)\n            }\n            \n            # 成功率计算\n            if stats['today_total'] > 0:\n                stats['success_rate'] = (stats['today_completed'] / stats['today_total']) * 100\n                stats['timeout_rate'] = (stats['today_timeout'] / stats['today_total']) * 100\n            else:\n                stats['success_rate'] = 0\n                stats['timeout_rate'] = 0\n            \n            return stats\n            \n        except Exception as e:\n            self.logger.error(f\"获取订单统计失败: {e}\")\n            return {}\n    \n    def force_cancel_all_pending(self):\n        \"\"\"强制取消所有待处理订单\"\"\"\n        try:\n            pending_trades = Trade.query.filter_by(status='pending').all()\n            cancelled_count = 0\n            \n            for trade in pending_trades:\n                try:\n                    if trade.order_id:\n                        success = self.mexc_connector.cancel_order(trade.order_id, trade.pair)\n                        if success:\n                            trade.status = 'force_cancelled'\n                            self._unlock_trade_balances(trade)\n                            cancelled_count += 1\n                        else:\n                            trade.status = 'cancel_failed'\n                    else:\n                        trade.status = 'force_cancelled'\n                        self._unlock_trade_balances(trade)\n                        cancelled_count += 1\n                        \n                except Exception as e:\n                    self.logger.error(f\"强制取消订单失败 {trade.id}: {e}\")\n                    trade.status = 'cancel_error'\n            \n            db.session.commit()\n            \n            self.logger.info(f\"🛑 强制取消了{cancelled_count}个待处理订单\")\n            return {'cancelled': cancelled_count, 'total': len(pending_trades)}\n            \n        except Exception as e:\n            self.logger.error(f\"强制取消所有订单失败: {e}\")\n            db.session.rollback()\n            return {'cancelled': 0, 'total': 0}\n    \n    def optimize_timeout_settings(self):\n        \"\"\"基于历史数据优化超时设置\"\"\"\n        try:\n            if not self.execution_times:\n                return\n            \n            # 计算99分位数作为新的超时时间\n            sorted_times = sorted(self.execution_times)\n            p95_time = sorted_times[int(len(sorted_times) * 0.95)]\n            p99_time = sorted_times[int(len(sorted_times) * 0.99)]\n            \n            # 动态调整超时时间\n            self.timeout_configs['market_order'] = max(10, int(p95_time * 1.5))\n            self.timeout_configs['limit_order'] = max(15, int(p99_time * 1.2))\n            self.timeout_configs['arbitrage_order'] = max(20, int(p99_time * 1.3))\n            \n            self.logger.info(f\"📈 超时设置已优化: {self.timeout_configs}\")\n            \n        except Exception as e:\n            self.logger.error(f\"优化超时设置失败: {e}\")","size_bytes":15511},"core/price_monitor.py":{"content":"import time\nimport threading\nimport logging\nfrom datetime import datetime\nfrom app import db\nfrom models import PriceHistory\nfrom core.api_connector import APIConnector\n\nclass PriceMonitor:\n    \"\"\"Real-time XRP price monitoring\"\"\"\n    \n    def __init__(self):\n        self.api = APIConnector()\n        self.running = False\n        self.thread = None\n        self.current_prices = {}\n        self.last_update = None\n        self.logger = logging.getLogger(__name__)\n        \n        # Connect to API\n        self.api.connect()\n    \n    def start_monitoring(self):\n        \"\"\"Start price monitoring in background thread\"\"\"\n        if self.running:\n            return\n        \n        self.running = True\n        self.thread = threading.Thread(target=self._monitor_loop)\n        self.thread.daemon = True\n        self.thread.start()\n        self.logger.info(\"Price monitoring started\")\n    \n    def stop_monitoring(self):\n        \"\"\"Stop price monitoring\"\"\"\n        self.running = False\n        if self.thread:\n            self.thread.join()\n        self.logger.info(\"Price monitoring stopped\")\n    \n    def _monitor_loop(self):\n        \"\"\"Main monitoring loop\"\"\"\n        while self.running:\n            try:\n                # Get current prices\n                usdt_ticker = self.api.get_ticker('XRP/USDT')\n                usdc_ticker = self.api.get_ticker('XRP/USDC')\n                \n                # Update current prices\n                self.current_prices = {\n                    'XRP/USDT': {\n                        'price': usdt_ticker['last'],\n                        'bid': usdt_ticker['bid'],\n                        'ask': usdt_ticker['ask'],\n                        'volume': usdt_ticker['volume'],\n                        'timestamp': datetime.utcnow()\n                    },\n                    'XRP/USDC': {\n                        'price': usdc_ticker['last'],\n                        'bid': usdc_ticker['bid'],\n                        'ask': usdc_ticker['ask'],\n                        'volume': usdc_ticker['volume'],\n                        'timestamp': datetime.utcnow()\n                    }\n                }\n                \n                self.last_update = datetime.utcnow()\n                \n                # Store in database every 10th update (reduce storage)\n                if int(time.time()) % 10 == 0:\n                    self._store_price_history()\n                \n                # Calculate and log spread\n                spread = abs(usdt_ticker['last'] - usdc_ticker['last'])\n                spread_percentage = (spread / usdt_ticker['last']) * 100\n                \n                if spread_percentage > 0.1:  # Log significant spreads\n                    self.logger.info(f\"Spread detected: {spread_percentage:.4f}% \"\n                                   f\"(USDT: {usdt_ticker['last']:.4f}, \"\n                                   f\"USDC: {usdc_ticker['last']:.4f})\")\n                \n            except Exception as e:\n                self.logger.error(f\"Error in price monitoring: {e}\")\n            \n            # Update every 2 seconds\n            time.sleep(2)\n    \n    def _store_price_history(self):\n        \"\"\"Store current prices in database\"\"\"\n        try:\n            from app import app\n            with app.app_context():\n                for pair, data in self.current_prices.items():\n                    price_history = PriceHistory(\n                        pair=pair,\n                        price=data['price'],\n                        volume=data['volume']\n                    )\n                    db.session.add(price_history)\n                \n                db.session.commit()\n        except Exception as e:\n            self.logger.error(f\"Error storing price history: {e}\")\n            try:\n                from app import app\n                with app.app_context():\n                    db.session.rollback()\n            except:\n                pass\n    \n    def get_current_prices(self):\n        \"\"\"Get current prices\"\"\"\n        if not self.current_prices:\n            # If no prices yet, get initial prices\n            try:\n                usdt_ticker = self.api.get_ticker('XRP/USDT')\n                usdc_ticker = self.api.get_ticker('XRP/USDC')\n                \n                self.current_prices = {\n                    'XRP/USDT': {\n                        'price': usdt_ticker['last'],\n                        'bid': usdt_ticker['bid'],\n                        'ask': usdt_ticker['ask'],\n                        'volume': usdt_ticker['volume'],\n                        'timestamp': datetime.utcnow()\n                    },\n                    'XRP/USDC': {\n                        'price': usdc_ticker['last'],\n                        'bid': usdc_ticker['bid'],\n                        'ask': usdc_ticker['ask'],\n                        'volume': usdc_ticker['volume'],\n                        'timestamp': datetime.utcnow()\n                    }\n                }\n                self.last_update = datetime.utcnow()\n            except Exception as e:\n                self.logger.error(f\"Error getting initial prices: {e}\")\n                return {}\n        \n        # Calculate spread\n        if 'XRP/USDT' in self.current_prices and 'XRP/USDC' in self.current_prices:\n            usdt_price = self.current_prices['XRP/USDT']['price']\n            usdc_price = self.current_prices['XRP/USDC']['price']\n            spread = abs(usdt_price - usdc_price)\n            spread_percentage = (spread / usdt_price) * 100\n            \n            return {\n                'XRP/USDT': self.current_prices['XRP/USDT'],\n                'XRP/USDC': self.current_prices['XRP/USDC'],\n                'spread': spread,\n                'spread_percentage': spread_percentage,\n                'last_update': self.last_update.isoformat() if self.last_update else None\n            }\n        \n        return self.current_prices\n    \n    def get_last_update(self):\n        \"\"\"Get timestamp of last price update\"\"\"\n        return self.last_update.isoformat() if self.last_update else None\n    \n    def get_spread(self):\n        \"\"\"Get current spread between XRP/USDT and XRP/USDC\"\"\"\n        prices = self.get_current_prices()\n        if 'spread' in prices:\n            return prices['spread'], prices['spread_percentage']\n        return 0, 0\n","size_bytes":6287},"core/profit_analyzer.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func\nfrom app import db\nfrom models import Trade\n\nclass ProfitAnalyzer:\n    \"\"\"Profit/loss analysis and statistics\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n    \n    def get_today_stats(self):\n        \"\"\"Get today's trading statistics\"\"\"\n        try:\n            today = datetime.utcnow().date()\n            today_start = datetime.combine(today, datetime.min.time())\n            \n            # Get today's completed trades\n            today_trades = Trade.query.filter(\n                Trade.created_at >= today_start,\n                Trade.status == 'completed'\n            ).all()\n            \n            if not today_trades:\n                return {\n                    'total_trades': 0,\n                    'total_profit_loss': 0.0,\n                    'total_volume': 0.0,\n                    'avg_profit_per_trade': 0.0,\n                    'success_rate': 0.0,\n                    'profitable_trades': 0,\n                    'losing_trades': 0\n                }\n            \n            total_trades = len(today_trades)\n            total_profit_loss = sum(trade.profit_loss or 0 for trade in today_trades)\n            total_volume = sum(trade.amount for trade in today_trades)\n            avg_profit_per_trade = total_profit_loss / total_trades if total_trades > 0 else 0\n            \n            # Count profitable vs losing trades\n            profitable_trades = len([t for t in today_trades if (t.profit_loss or 0) > 0])\n            losing_trades = len([t for t in today_trades if (t.profit_loss or 0) < 0])\n            success_rate = (profitable_trades / total_trades * 100) if total_trades > 0 else 0\n            \n            return {\n                'total_trades': total_trades,\n                'total_profit_loss': total_profit_loss,\n                'total_volume': total_volume,\n                'avg_profit_per_trade': avg_profit_per_trade,\n                'success_rate': success_rate,\n                'profitable_trades': profitable_trades,\n                'losing_trades': losing_trades\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting today's stats: {e}\")\n            return {}\n    \n    def get_comprehensive_stats(self, days=30):\n        \"\"\"Get comprehensive trading statistics\"\"\"\n        try:\n            cutoff_date = datetime.utcnow() - timedelta(days=days)\n            \n            # Get all completed trades in the period\n            trades = Trade.query.filter(\n                Trade.created_at >= cutoff_date,\n                Trade.status == 'completed'\n            ).all()\n            \n            if not trades:\n                return self._empty_stats()\n            \n            # Basic statistics\n            total_trades = len(trades)\n            total_profit_loss = sum(trade.profit_loss or 0 for trade in trades)\n            total_volume = sum(trade.amount for trade in trades)\n            \n            # Profit/loss analysis\n            profitable_trades = [t for t in trades if (t.profit_loss or 0) > 0]\n            losing_trades = [t for t in trades if (t.profit_loss or 0) < 0]\n            \n            success_rate = (len(profitable_trades) / total_trades * 100) if total_trades > 0 else 0\n            avg_profit_per_trade = total_profit_loss / total_trades if total_trades > 0 else 0\n            \n            # Profit statistics\n            if profitable_trades:\n                avg_winning_trade = sum(t.profit_loss for t in profitable_trades) / len(profitable_trades)\n                max_winning_trade = max(t.profit_loss for t in profitable_trades)\n            else:\n                avg_winning_trade = 0\n                max_winning_trade = 0\n            \n            # Loss statistics\n            if losing_trades:\n                avg_losing_trade = sum(t.profit_loss for t in losing_trades) / len(losing_trades)\n                max_losing_trade = min(t.profit_loss for t in losing_trades)\n            else:\n                avg_losing_trade = 0\n                max_losing_trade = 0\n            \n            # Drawdown analysis\n            drawdown_stats = self._calculate_drawdown(trades)\n            \n            # Time-based analysis\n            time_stats = self._analyze_time_performance(trades)\n            \n            # Risk metrics\n            risk_metrics = self._calculate_risk_metrics(trades)\n            \n            return {\n                'period_days': days,\n                'total_trades': total_trades,\n                'total_profit_loss': total_profit_loss,\n                'total_volume': total_volume,\n                'success_rate': success_rate,\n                'avg_profit_per_trade': avg_profit_per_trade,\n                'profitable_trades_count': len(profitable_trades),\n                'losing_trades_count': len(losing_trades),\n                'avg_winning_trade': avg_winning_trade,\n                'avg_losing_trade': avg_losing_trade,\n                'max_winning_trade': max_winning_trade,\n                'max_losing_trade': max_losing_trade,\n                'drawdown': drawdown_stats,\n                'time_analysis': time_stats,\n                'risk_metrics': risk_metrics\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting comprehensive stats: {e}\")\n            return self._empty_stats()\n    \n    def _empty_stats(self):\n        \"\"\"Return empty statistics structure\"\"\"\n        return {\n            'period_days': 0,\n            'total_trades': 0,\n            'total_profit_loss': 0.0,\n            'total_volume': 0.0,\n            'success_rate': 0.0,\n            'avg_profit_per_trade': 0.0,\n            'profitable_trades_count': 0,\n            'losing_trades_count': 0,\n            'avg_winning_trade': 0.0,\n            'avg_losing_trade': 0.0,\n            'max_winning_trade': 0.0,\n            'max_losing_trade': 0.0,\n            'drawdown': {'max_drawdown': 0, 'current_drawdown': 0},\n            'time_analysis': {'best_hour': 0, 'worst_hour': 0},\n            'risk_metrics': {'sharpe_ratio': 0, 'win_loss_ratio': 0}\n        }\n    \n    def _calculate_drawdown(self, trades):\n        \"\"\"Calculate maximum and current drawdown\"\"\"\n        try:\n            if not trades:\n                return {'max_drawdown': 0, 'current_drawdown': 0}\n            \n            # Sort trades by time\n            sorted_trades = sorted(trades, key=lambda x: x.created_at)\n            \n            # Calculate cumulative P&L\n            cumulative_pnl = []\n            running_total = 0\n            \n            for trade in sorted_trades:\n                running_total += trade.profit_loss or 0\n                cumulative_pnl.append(running_total)\n            \n            # Calculate drawdown\n            peak = cumulative_pnl[0]\n            max_drawdown = 0\n            current_drawdown = 0\n            \n            for pnl in cumulative_pnl:\n                if pnl > peak:\n                    peak = pnl\n                \n                drawdown = peak - pnl\n                if drawdown > max_drawdown:\n                    max_drawdown = drawdown\n            \n            # Current drawdown is from the last peak\n            current_peak = max(cumulative_pnl)\n            current_drawdown = current_peak - cumulative_pnl[-1]\n            \n            return {\n                'max_drawdown': max_drawdown,\n                'current_drawdown': current_drawdown\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating drawdown: {e}\")\n            return {'max_drawdown': 0, 'current_drawdown': 0}\n    \n    def _analyze_time_performance(self, trades):\n        \"\"\"Analyze performance by time of day\"\"\"\n        try:\n            if not trades:\n                return {'best_hour': 0, 'worst_hour': 0}\n            \n            # Group trades by hour\n            hourly_performance = {}\n            \n            for trade in trades:\n                hour = trade.created_at.hour\n                if hour not in hourly_performance:\n                    hourly_performance[hour] = []\n                hourly_performance[hour].append(trade.profit_loss or 0)\n            \n            # Calculate average performance per hour\n            hourly_avg = {}\n            for hour, profits in hourly_performance.items():\n                hourly_avg[hour] = sum(profits) / len(profits)\n            \n            # Find best and worst hours\n            if hourly_avg:\n                best_hour = max(hourly_avg.keys(), key=lambda k: hourly_avg[k])\n                worst_hour = min(hourly_avg.keys(), key=lambda k: hourly_avg[k])\n            else:\n                best_hour = 0\n                worst_hour = 0\n            \n            return {\n                'best_hour': best_hour,\n                'worst_hour': worst_hour,\n                'hourly_performance': hourly_avg\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error analyzing time performance: {e}\")\n            return {'best_hour': 0, 'worst_hour': 0}\n    \n    def _calculate_risk_metrics(self, trades):\n        \"\"\"Calculate risk-adjusted performance metrics\"\"\"\n        try:\n            if not trades or len(trades) < 2:\n                return {'sharpe_ratio': 0, 'win_loss_ratio': 0}\n            \n            # Calculate returns\n            returns = [trade.profit_loss or 0 for trade in trades]\n            avg_return = sum(returns) / len(returns)\n            \n            # Calculate standard deviation\n            variance = sum((r - avg_return) ** 2 for r in returns) / (len(returns) - 1)\n            std_dev = variance ** 0.5\n            \n            # Sharpe ratio (assuming risk-free rate of 0)\n            sharpe_ratio = avg_return / std_dev if std_dev > 0 else 0\n            \n            # Win/Loss ratio\n            profitable_trades = [r for r in returns if r > 0]\n            losing_trades = [r for r in returns if r < 0]\n            \n            if profitable_trades and losing_trades:\n                avg_win = sum(profitable_trades) / len(profitable_trades)\n                avg_loss = abs(sum(losing_trades) / len(losing_trades))\n                win_loss_ratio = avg_win / avg_loss\n            else:\n                win_loss_ratio = 0\n            \n            return {\n                'sharpe_ratio': sharpe_ratio,\n                'win_loss_ratio': win_loss_ratio,\n                'volatility': std_dev,\n                'avg_return': avg_return\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating risk metrics: {e}\")\n            return {'sharpe_ratio': 0, 'win_loss_ratio': 0}\n    \n    def get_daily_performance(self, days=30):\n        \"\"\"Get daily performance breakdown\"\"\"\n        try:\n            cutoff_date = datetime.utcnow() - timedelta(days=days)\n            \n            # Get trades grouped by date\n            trades = Trade.query.filter(\n                Trade.created_at >= cutoff_date,\n                Trade.status == 'completed'\n            ).all()\n            \n            # Group by date\n            daily_performance = {}\n            \n            for trade in trades:\n                date_key = trade.created_at.date().isoformat()\n                if date_key not in daily_performance:\n                    daily_performance[date_key] = {\n                        'trades': 0,\n                        'profit_loss': 0.0,\n                        'volume': 0.0\n                    }\n                \n                daily_performance[date_key]['trades'] += 1\n                daily_performance[date_key]['profit_loss'] += trade.profit_loss or 0\n                daily_performance[date_key]['volume'] += trade.amount\n            \n            return daily_performance\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting daily performance: {e}\")\n            return {}\n    \n    def get_pair_performance(self, days=30):\n        \"\"\"Get performance breakdown by trading pair\"\"\"\n        try:\n            cutoff_date = datetime.utcnow() - timedelta(days=days)\n            \n            trades = Trade.query.filter(\n                Trade.created_at >= cutoff_date,\n                Trade.status == 'completed'\n            ).all()\n            \n            # Group by pair\n            pair_performance = {}\n            \n            for trade in trades:\n                pair = trade.pair\n                if pair not in pair_performance:\n                    pair_performance[pair] = {\n                        'trades': 0,\n                        'profit_loss': 0.0,\n                        'volume': 0.0,\n                        'avg_price': 0.0\n                    }\n                \n                pair_performance[pair]['trades'] += 1\n                pair_performance[pair]['profit_loss'] += trade.profit_loss or 0\n                pair_performance[pair]['volume'] += trade.amount\n                pair_performance[pair]['avg_price'] = (\n                    pair_performance[pair]['avg_price'] * (pair_performance[pair]['trades'] - 1) + trade.price\n                ) / pair_performance[pair]['trades']\n            \n            return pair_performance\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting pair performance: {e}\")\n            return {}\n","size_bytes":13321},"core/risk_controller.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom app import db\nfrom models import Trade, TradingConfig, Balance, CircuitBreaker\nfrom core.balance_manager import BalanceManager\nfrom core.volume_tracker import VolumeTracker\n\nclass RiskController:\n    \"\"\"Enhanced risk management with circuit breakers and volatility-based sizing\"\"\"\n    \n    def __init__(self):\n        self.balance_manager = BalanceManager()\n        self.volume_tracker = VolumeTracker()\n        self.logger = logging.getLogger(__name__)\n    \n    def check_trade_risk(self, opportunity, config):\n        \"\"\"\n        Enhanced comprehensive risk check with circuit breakers\n        \n        Args:\n            opportunity: Trade opportunity details\n            config: Trading configuration\n            \n        Returns:\n            dict: {'safe': bool, 'reason': str, 'adjusted_amount': float}\n        \"\"\"\n        try:\n            # 0. Check circuit breakers first\n            breaker_status = self.volume_tracker.check_circuit_breakers()\n            if not breaker_status['trading_allowed']:\n                active_breakers = [b['type'] for b in breaker_status['breakers'] if b['active']]\n                return {\n                    'safe': False, \n                    'reason': f'Circuit breaker(s) active: {active_breakers}',\n                    'adjusted_amount': 0\n                }\n            \n            # 1. Calculate volatility-adjusted trade amount\n            adjusted_amount = self._calculate_volatility_adjusted_amount(opportunity, config)\n            opportunity['amount'] = adjusted_amount  # Update opportunity with adjusted amount\n            \n            # 2. Check daily volume limits with adjusted amount\n            trade_value_usd = adjusted_amount * opportunity['sell_price']\n            volume_check = self.volume_tracker.check_daily_volume_limit(trade_value_usd, config)\n            if not volume_check['allowed']:\n                return {\n                    'safe': False, \n                    'reason': volume_check['reason'],\n                    'adjusted_amount': 0\n                }\n            \n            # 3. Check balance safety margins\n            balance_check = self._check_balance_safety(adjusted_amount, config.risk_buffer)\n            if not balance_check['safe']:\n                return {\n                    'safe': False,\n                    'reason': balance_check['reason'],\n                    'adjusted_amount': 0\n                }\n            \n            # 4. Check pending orders limit\n            pending_check = self._check_pending_orders_limit(config.max_pending_orders)\n            if not pending_check['safe']:\n                return {\n                    'safe': False,\n                    'reason': pending_check['reason'],\n                    'adjusted_amount': 0\n                }\n            \n            # 5. Check price volatility\n            volatility_check = self._check_price_volatility(opportunity)\n            if not volatility_check['safe']:\n                return {\n                    'safe': False,\n                    'reason': volatility_check['reason'],\n                    'adjusted_amount': 0\n                }\n            \n            # 6. Check spread validity\n            spread_check = self._check_spread_validity(opportunity, config.spread_threshold)\n            if not spread_check['safe']:\n                return {\n                    'safe': False,\n                    'reason': spread_check['reason'],\n                    'adjusted_amount': 0\n                }\n            \n            # 7. Check trading frequency\n            frequency_check = self._check_trading_frequency()\n            if not frequency_check['safe']:\n                return {\n                    'safe': False,\n                    'reason': frequency_check['reason'],\n                    'adjusted_amount': 0\n                }\n            \n            return {\n                'safe': True, \n                'reason': 'All risk checks passed',\n                'adjusted_amount': adjusted_amount\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error in risk check: {e}\")\n            return {\n                'safe': False, \n                'reason': f'Risk check error: {e}',\n                'adjusted_amount': 0\n            }\n    \n    def _check_daily_volume_limit(self, trade_amount, daily_limit):\n        \"\"\"Check if trade would exceed daily volume limit\"\"\"\n        try:\n            today = datetime.utcnow().date()\n            today_start = datetime.combine(today, datetime.min.time())\n            \n            # Calculate today's total volume\n            today_trades = Trade.query.filter(\n                Trade.created_at >= today_start,\n                Trade.status.in_(['completed', 'pending'])\n            ).all()\n            \n            today_volume = sum(trade.amount for trade in today_trades)\n            \n            if today_volume + trade_amount > daily_limit:\n                return {\n                    'safe': False, \n                    'reason': f'Daily volume limit exceeded: {today_volume + trade_amount:.2f} > {daily_limit}'\n                }\n            \n            return {'safe': True, 'reason': 'Volume limit OK'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking daily volume: {e}\")\n            return {'safe': False, 'reason': 'Volume check failed'}\n    \n    def _check_balance_safety(self, trade_amount, risk_buffer):\n        \"\"\"Check if balances have sufficient safety margins\"\"\"\n        try:\n            balances = self.balance_manager.get_balances()\n            \n            # Check XRP balance (for sell order)\n            xrp_balance = balances.get('XRP', {}).get('free', 0)\n            required_xrp = trade_amount * (1 + risk_buffer)\n            \n            if xrp_balance < required_xrp:\n                return {\n                    'safe': False,\n                    'reason': f'Insufficient XRP balance with safety margin: {xrp_balance:.2f} < {required_xrp:.2f}'\n                }\n            \n            # Check stablecoin balances (for buy order)\n            usdt_balance = balances.get('USDT', {}).get('free', 0)\n            usdc_balance = balances.get('USDC', {}).get('free', 0)\n            \n            # Estimate required stablecoin (using approximate price)\n            estimated_price = 0.52  # Conservative estimate\n            required_stable = trade_amount * estimated_price * (1 + risk_buffer)\n            \n            if usdt_balance < required_stable and usdc_balance < required_stable:\n                return {\n                    'safe': False,\n                    'reason': f'Insufficient stablecoin balance with safety margin'\n                }\n            \n            return {'safe': True, 'reason': 'Balance safety OK'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking balance safety: {e}\")\n            return {'safe': False, 'reason': 'Balance safety check failed'}\n    \n    def _check_pending_orders_limit(self, max_pending):\n        \"\"\"Check if pending orders limit would be exceeded\"\"\"\n        try:\n            pending_count = Trade.query.filter_by(status='pending').count()\n            \n            if pending_count >= max_pending:\n                return {\n                    'safe': False,\n                    'reason': f'Too many pending orders: {pending_count} >= {max_pending}'\n                }\n            \n            return {'safe': True, 'reason': 'Pending orders OK'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking pending orders: {e}\")\n            return {'safe': False, 'reason': 'Pending orders check failed'}\n    \n    def _check_price_volatility(self, opportunity):\n        \"\"\"Check if price volatility is within acceptable limits\"\"\"\n        try:\n            # Get recent price movements\n            recent_cutoff = datetime.utcnow() - timedelta(minutes=5)\n            \n            from models import PriceHistory\n            recent_prices = PriceHistory.query.filter(\n                PriceHistory.timestamp >= recent_cutoff\n            ).order_by(PriceHistory.timestamp.desc()).limit(20).all()\n            \n            if len(recent_prices) < 5:\n                return {'safe': True, 'reason': 'Insufficient price history for volatility check'}\n            \n            # Calculate price volatility\n            prices = [p.price for p in recent_prices]\n            max_price = max(prices)\n            min_price = min(prices)\n            volatility = (max_price - min_price) / min_price\n            \n            # If volatility > 2%, it's too risky\n            if volatility > 0.02:\n                return {\n                    'safe': False,\n                    'reason': f'High price volatility detected: {volatility:.4f}'\n                }\n            \n            return {'safe': True, 'reason': 'Price volatility OK'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking price volatility: {e}\")\n            return {'safe': True, 'reason': 'Volatility check skipped due to error'}\n    \n    def _check_spread_validity(self, opportunity, min_spread):\n        \"\"\"Check if spread is still valid and above threshold\"\"\"\n        try:\n            current_spread = opportunity.get('spread_percentage', 0)\n            \n            if current_spread < min_spread:\n                return {\n                    'safe': False,\n                    'reason': f'Spread too small: {current_spread:.4f} < {min_spread:.4f}'\n                }\n            \n            # Check if spread is not too good to be true (>5% is suspicious)\n            if current_spread > 0.05:\n                return {\n                    'safe': False,\n                    'reason': f'Spread too large, possible data error: {current_spread:.4f}'\n                }\n            \n            return {'safe': True, 'reason': 'Spread validity OK'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking spread validity: {e}\")\n            return {'safe': False, 'reason': 'Spread validity check failed'}\n    \n    def _check_trading_frequency(self, min_interval_seconds=30):\n        \"\"\"Check if we're not trading too frequently\"\"\"\n        try:\n            recent_cutoff = datetime.utcnow() - timedelta(seconds=min_interval_seconds)\n            \n            recent_trades = Trade.query.filter(\n                Trade.created_at >= recent_cutoff\n            ).count()\n            \n            # Allow max 1 trade per 30 seconds\n            if recent_trades > 0:\n                return {\n                    'safe': False,\n                    'reason': f'Trading too frequently: {recent_trades} trades in last {min_interval_seconds}s'\n                }\n            \n            return {'safe': True, 'reason': 'Trading frequency OK'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking trading frequency: {e}\")\n            return {'safe': True, 'reason': 'Frequency check skipped due to error'}\n    \n    def check_system_health(self):\n        \"\"\"Check overall system health\"\"\"\n        try:\n            health_status = {\n                'healthy': True,\n                'warnings': [],\n                'errors': []\n            }\n            \n            # Check database connectivity\n            try:\n                from sqlalchemy import text\n                db.session.execute(text('SELECT 1'))\n            except Exception as e:\n                health_status['healthy'] = False\n                health_status['errors'].append(f'Database connection error: {e}')\n            \n            # Check balance consistency\n            balances = self.balance_manager.get_balances()\n            for currency, balance in balances.items():\n                if balance['total'] < 0:\n                    health_status['warnings'].append(f'Negative {currency} balance detected')\n                \n                if balance['locked'] > balance['total']:\n                    health_status['healthy'] = False\n                    health_status['errors'].append(f'Locked {currency} exceeds total balance')\n            \n            # Check for stuck pending orders\n            old_pending = Trade.query.filter(\n                Trade.status == 'pending',\n                Trade.created_at < datetime.utcnow() - timedelta(minutes=5)\n            ).count()\n            \n            if old_pending > 0:\n                health_status['warnings'].append(f'{old_pending} orders pending for >5 minutes')\n            \n            return health_status\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking system health: {e}\")\n            return {\n                'healthy': False,\n                'warnings': [],\n                'errors': [f'Health check failed: {e}']\n            }\n    \n    def calculate_max_safe_trade_amount(self, config):\n        \"\"\"Calculate maximum safe trade amount based on current conditions\"\"\"\n        try:\n            balances = self.balance_manager.get_balances()\n            \n            # Base on XRP balance with safety margin\n            xrp_balance = balances.get('XRP', {}).get('free', 0)\n            max_xrp = xrp_balance * (1 - config.risk_buffer)\n            \n            # Base on daily volume limit\n            today = datetime.utcnow().date()\n            today_start = datetime.combine(today, datetime.min.time())\n            \n            today_trades = Trade.query.filter(\n                Trade.created_at >= today_start,\n                Trade.status.in_(['completed', 'pending'])\n            ).all()\n            \n            today_volume = sum(trade.amount for trade in today_trades)\n            remaining_daily_volume = config.daily_max_volume - today_volume\n            \n            # Return the minimum of the constraints\n            max_safe_amount = min(max_xrp, remaining_daily_volume, config.trade_amount)\n            \n            return max(0, max_safe_amount)\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating max safe trade amount: {e}\")\n            return 0\n    \n    def _calculate_volatility_adjusted_amount(self, opportunity, config):\n        \"\"\"Calculate position size adjusted for market volatility\"\"\"\n        try:\n            base_amount = config.trade_amount\n            \n            # Get recent price volatility\n            volatility_factor = self._calculate_price_volatility_factor()\n            \n            # Apply volatility multiplier from config\n            volatility_adjustment = config.volatility_multiplier * volatility_factor\n            \n            # Reduce position size for high volatility, increase for low volatility\n            if volatility_factor > 1.5:  # High volatility\n                adjusted_amount = base_amount * 0.5  # Reduce by 50%\n            elif volatility_factor > 1.2:  # Medium-high volatility\n                adjusted_amount = base_amount * 0.75  # Reduce by 25%\n            elif volatility_factor < 0.5:  # Low volatility\n                adjusted_amount = base_amount * 1.25  # Increase by 25%\n            else:  # Normal volatility\n                adjusted_amount = base_amount\n            \n            # Apply spread-based adjustment (larger spreads allow larger positions)\n            spread_percentage = opportunity.get('spread_percentage', 0)\n            if spread_percentage > 0.5:  # Large spread > 0.5%\n                spread_multiplier = min(1.5, 1 + (spread_percentage / 100))\n                adjusted_amount *= spread_multiplier\n            \n            # Ensure we don't exceed maximum safe amount\n            max_safe = self.calculate_max_safe_trade_amount(config)\n            final_amount = min(adjusted_amount, max_safe)\n            \n            self.logger.debug(f\"Position sizing: Base={base_amount}, Volatility Factor={volatility_factor:.2f}, Final={final_amount:.2f}\")\n            \n            return max(0, final_amount)\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating volatility-adjusted amount: {e}\")\n            return config.trade_amount\n    \n    def _calculate_price_volatility_factor(self):\n        \"\"\"Calculate price volatility factor over recent periods\"\"\"\n        try:\n            # Get price data from the last 30 minutes\n            recent_cutoff = datetime.utcnow() - timedelta(minutes=30)\n            \n            from models import PriceHistory\n            recent_prices = PriceHistory.query.filter(\n                PriceHistory.timestamp >= recent_cutoff\n            ).order_by(PriceHistory.timestamp.desc()).limit(60).all()\n            \n            if len(recent_prices) < 10:\n                return 1.0  # Normal volatility if insufficient data\n            \n            # Separate by pair and calculate volatility\n            usdt_prices = [p.price for p in recent_prices if p.pair == 'XRP/USDT']\n            usdc_prices = [p.price for p in recent_prices if p.pair == 'XRP/USDC']\n            \n            volatility_factors = []\n            \n            for prices in [usdt_prices, usdc_prices]:\n                if len(prices) >= 5:\n                    max_price = max(prices)\n                    min_price = min(prices)\n                    avg_price = sum(prices) / len(prices)\n                    \n                    # Calculate coefficient of variation (volatility relative to mean)\n                    volatility = (max_price - min_price) / avg_price\n                    volatility_factors.append(volatility)\n            \n            if not volatility_factors:\n                return 1.0\n            \n            # Average volatility across pairs\n            avg_volatility = sum(volatility_factors) / len(volatility_factors)\n            \n            # Convert to volatility factor (higher values = more volatile)\n            # Normal volatility is around 0.01-0.02 (1-2%)\n            volatility_factor = avg_volatility / 0.015  # Normalize to ~1.0 for normal volatility\n            \n            return max(0.5, min(3.0, volatility_factor))  # Clamp between 0.5x and 3.0x\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating price volatility factor: {e}\")\n            return 1.0  # Default to normal volatility\n    \n    def activate_emergency_stop(self, reason):\n        \"\"\"Activate emergency stop circuit breaker\"\"\"\n        try:\n            self.volume_tracker.activate_circuit_breaker(\n                'emergency_stop',\n                f'Emergency stop activated: {reason}',\n                None,\n                None\n            )\n            \n            # Cancel all pending orders immediately\n            from core.trade_executor import TradeExecutor\n            executor = TradeExecutor()\n            executor.cancel_pending_orders()\n            \n            self.logger.critical(f\"EMERGENCY STOP ACTIVATED: {reason}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error activating emergency stop: {e}\")\n    \n    def check_system_stability(self):\n        \"\"\"Check overall system stability for trading decisions\"\"\"\n        try:\n            stability_score = 100  # Start with perfect score\n            warnings = []\n            \n            # Check recent error rate\n            recent_cutoff = datetime.utcnow() - timedelta(minutes=15)\n            from models import SystemLog\n            recent_errors = SystemLog.query.filter(\n                SystemLog.timestamp >= recent_cutoff,\n                SystemLog.level == 'ERROR'\n            ).count()\n            \n            if recent_errors > 5:\n                stability_score -= 30\n                warnings.append(f'High error rate: {recent_errors} errors in 15 minutes')\n            elif recent_errors > 2:\n                stability_score -= 10\n                warnings.append(f'Elevated error rate: {recent_errors} errors in 15 minutes')\n            \n            # Check balance consistency\n            balances = self.balance_manager.get_balances()\n            for currency, balance in balances.items():\n                if balance['locked'] > balance['total']:\n                    stability_score -= 50\n                    warnings.append(f'Balance inconsistency in {currency}')\n            \n            # Check trade success rate\n            recent_trades = Trade.query.filter(\n                Trade.created_at >= recent_cutoff\n            ).all()\n            \n            if recent_trades:\n                failed_trades = len([t for t in recent_trades if t.status in ['failed', 'timeout']])\n                failure_rate = failed_trades / len(recent_trades)\n                \n                if failure_rate > 0.3:  # More than 30% failure rate\n                    stability_score -= 40\n                    warnings.append(f'High trade failure rate: {failure_rate:.1%}')\n            \n            return {\n                'stability_score': max(0, stability_score),\n                'stable': stability_score >= 70,\n                'warnings': warnings,\n                'recommendation': self._get_stability_recommendation(stability_score)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking system stability: {e}\")\n            return {\n                'stability_score': 50,\n                'stable': False,\n                'warnings': [f'Stability check failed: {e}'],\n                'recommendation': 'Reduce trading activity until issues are resolved'\n            }\n    \n    def _get_stability_recommendation(self, score):\n        \"\"\"Get trading recommendation based on stability score\"\"\"\n        if score >= 90:\n            return 'Normal trading activity'\n        elif score >= 70:\n            return 'Cautious trading with reduced position sizes'\n        elif score >= 50:\n            return 'Limited trading - address system issues'\n        else:\n            return 'Stop trading until stability is restored'\n","size_bytes":21893},"core/security_manager.py":{"content":"import os\nimport time\nimport logging\nfrom datetime import datetime, timedelta\nfrom cryptography.fernet import Fernet\nfrom collections import defaultdict\nfrom app import db\nfrom models import SystemLog\n\nclass SecurityManager:\n    \"\"\"Security management for API keys, rate limiting, and access control\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.encryption_key = self._get_or_create_encryption_key()\n        self.fernet = Fernet(self.encryption_key)\n        \n        # Rate limiting\n        self.rate_limits = defaultdict(list)\n        self.failed_attempts = defaultdict(int)\n        \n        # API usage tracking\n        self.api_call_counts = defaultdict(int)\n        self.api_call_windows = defaultdict(list)\n    \n    def _get_or_create_encryption_key(self):\n        \"\"\"Get or create encryption key for API credentials\"\"\"\n        try:\n            # Try to get existing key from environment\n            key = os.environ.get('ENCRYPTION_KEY')\n            \n            if not key:\n                # Generate new key\n                key = Fernet.generate_key().decode()\n                self.logger.warning(\"Generated new encryption key - store this securely!\")\n                self.logger.warning(f\"ENCRYPTION_KEY={key}\")\n                \n                # Try to save to environment (this won't persist across restarts)\n                os.environ['ENCRYPTION_KEY'] = key\n            \n            return key.encode()\n            \n        except Exception as e:\n            self.logger.error(f\"Error handling encryption key: {e}\")\n            # Fallback key (not secure for production)\n            return Fernet.generate_key()\n    \n    def encrypt_api_credentials(self, api_key, api_secret):\n        \"\"\"Encrypt API credentials for secure storage\"\"\"\n        try:\n            encrypted_key = self.fernet.encrypt(api_key.encode()).decode()\n            encrypted_secret = self.fernet.encrypt(api_secret.encode()).decode()\n            \n            return {\n                'encrypted_key': encrypted_key,\n                'encrypted_secret': encrypted_secret,\n                'encryption_key': self.encryption_key.decode()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error encrypting API credentials: {e}\")\n            return None\n    \n    def decrypt_api_credentials(self, encrypted_key, encrypted_secret):\n        \"\"\"Decrypt API credentials\"\"\"\n        try:\n            api_key = self.fernet.decrypt(encrypted_key.encode()).decode()\n            api_secret = self.fernet.decrypt(encrypted_secret.encode()).decode()\n            \n            return api_key, api_secret\n            \n        except Exception as e:\n            self.logger.error(f\"Error decrypting API credentials: {e}\")\n            return None, None\n    \n    def check_rate_limit(self, identifier, max_requests=60, window_seconds=60):\n        \"\"\"Check if request is within rate limits\"\"\"\n        try:\n            current_time = time.time()\n            \n            # Clean old requests\n            cutoff_time = current_time - window_seconds\n            self.rate_limits[identifier] = [\n                req_time for req_time in self.rate_limits[identifier]\n                if req_time > cutoff_time\n            ]\n            \n            # Check if under limit\n            if len(self.rate_limits[identifier]) >= max_requests:\n                self.logger.warning(f\"Rate limit exceeded for {identifier}\")\n                return False\n            \n            # Add current request\n            self.rate_limits[identifier].append(current_time)\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking rate limit: {e}\")\n            return True  # Allow on error\n    \n    def track_api_usage(self, api_endpoint, response_code):\n        \"\"\"Track API usage for monitoring\"\"\"\n        try:\n            current_time = time.time()\n            \n            # Track usage\n            self.api_call_counts[api_endpoint] += 1\n            self.api_call_windows[api_endpoint].append({\n                'timestamp': current_time,\n                'response_code': response_code\n            })\n            \n            # Clean old data (keep 1 hour)\n            cutoff_time = current_time - 3600\n            self.api_call_windows[api_endpoint] = [\n                call for call in self.api_call_windows[api_endpoint]\n                if call['timestamp'] > cutoff_time\n            ]\n            \n            # Log errors\n            if response_code >= 400:\n                self.failed_attempts[api_endpoint] += 1\n                \n                # Alert on high error rate\n                recent_calls = [\n                    call for call in self.api_call_windows[api_endpoint]\n                    if call['timestamp'] > current_time - 300  # Last 5 minutes\n                ]\n                \n                if recent_calls:\n                    error_rate = len([c for c in recent_calls if c['response_code'] >= 400]) / len(recent_calls)\n                    \n                    if error_rate > 0.5:  # More than 50% errors\n                        self.logger.critical(f\"High API error rate for {api_endpoint}: {error_rate:.1%}\")\n                        self._log_security_event('HIGH_API_ERROR_RATE', f'{api_endpoint}: {error_rate:.1%}')\n            \n        except Exception as e:\n            self.logger.error(f\"Error tracking API usage: {e}\")\n    \n    def validate_api_key_format(self, api_key):\n        \"\"\"Validate API key format\"\"\"\n        try:\n            # Basic validation\n            if not api_key or len(api_key) < 10:\n                return False\n            \n            # Check for demo/test keys\n            demo_indicators = ['demo', 'test', 'fake', 'sample']\n            if any(indicator in api_key.lower() for indicator in demo_indicators):\n                self.logger.warning(\"Demo/test API key detected\")\n                return True  # Allow demo keys\n            \n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error validating API key: {e}\")\n            return False\n    \n    def check_suspicious_activity(self):\n        \"\"\"Check for suspicious API usage patterns\"\"\"\n        try:\n            alerts = []\n            current_time = time.time()\n            \n            # Check for excessive failed requests\n            for endpoint, attempts in self.failed_attempts.items():\n                if attempts > 20:  # More than 20 failed attempts\n                    alerts.append(f\"Excessive failures for {endpoint}: {attempts}\")\n            \n            # Check for unusual API usage patterns\n            for endpoint, calls in self.api_call_windows.items():\n                recent_calls = [\n                    call for call in calls\n                    if call['timestamp'] > current_time - 300  # Last 5 minutes\n                ]\n                \n                if len(recent_calls) > 100:  # More than 100 calls in 5 minutes\n                    alerts.append(f\"High API usage for {endpoint}: {len(recent_calls)} calls in 5 min\")\n            \n            # Log alerts\n            for alert in alerts:\n                self.logger.warning(f\"Security alert: {alert}\")\n                self._log_security_event('SUSPICIOUS_ACTIVITY', alert)\n            \n            return alerts\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking suspicious activity: {e}\")\n            return []\n    \n    def _log_security_event(self, event_type, details):\n        \"\"\"Log security event to database\"\"\"\n        try:\n            log_entry = SystemLog(\n                level='WARNING',\n                message=f'Security Event: {event_type}',\n                module='SecurityManager',\n                error_details=details\n            )\n            \n            db.session.add(log_entry)\n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error logging security event: {e}\")\n    \n    def get_security_status(self):\n        \"\"\"Get overall security status\"\"\"\n        try:\n            current_time = time.time()\n            \n            # Calculate metrics\n            total_api_calls = sum(self.api_call_counts.values())\n            total_failures = sum(self.failed_attempts.values())\n            \n            recent_alerts = self.check_suspicious_activity()\n            \n            # Rate limiting status\n            active_rate_limits = len([\n                identifier for identifier, times in self.rate_limits.items()\n                if any(t > current_time - 60 for t in times)\n            ])\n            \n            return {\n                'encryption_enabled': True,\n                'total_api_calls': total_api_calls,\n                'total_failures': total_failures,\n                'error_rate': (total_failures / total_api_calls * 100) if total_api_calls > 0 else 0,\n                'active_rate_limits': active_rate_limits,\n                'recent_alerts': recent_alerts,\n                'secure': len(recent_alerts) == 0,\n                'last_check': datetime.utcnow().isoformat()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting security status: {e}\")\n            return {\n                'encryption_enabled': False,\n                'secure': False,\n                'error': str(e),\n                'last_check': datetime.utcnow().isoformat()\n            }\n    \n    def reset_security_counters(self):\n        \"\"\"Reset security counters (for maintenance)\"\"\"\n        try:\n            self.rate_limits.clear()\n            self.failed_attempts.clear()\n            self.api_call_counts.clear()\n            self.api_call_windows.clear()\n            \n            self.logger.info(\"Security counters reset\")\n            self._log_security_event('COUNTERS_RESET', 'All security counters have been reset')\n            \n        except Exception as e:\n            self.logger.error(f\"Error resetting security counters: {e}\")\n    \n    def generate_api_key_instructions(self):\n        \"\"\"Generate instructions for securing API keys\"\"\"\n        return {\n            'steps': [\n                '1. Create MEXC API key with only spot trading permissions',\n                '2. Whitelist your server IP address',\n                '3. Enable only necessary permissions (no withdrawals)',\n                '4. Set up environment variables for encrypted storage',\n                '5. Test with small amounts first'\n            ],\n            'environment_variables': {\n                'MEXC_API_KEY_ENCRYPTED': 'Your encrypted API key',\n                'MEXC_API_SECRET_ENCRYPTED': 'Your encrypted API secret',\n                'MEXC_ENCRYPTION_KEY': 'Encryption key for security'\n            },\n            'security_tips': [\n                'Never share your API keys',\n                'Monitor API usage regularly',\n                'Set up IP whitelisting',\n                'Use minimum required permissions',\n                'Enable 2FA on your exchange account'\n            ]\n        }","size_bytes":11074},"core/trade_executor.py":{"content":"import time\nimport asyncio\nimport logging\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom app import db\nfrom models import Trade\nfrom core.api_connector import APIConnector\nfrom core.balance_manager import BalanceManager\n\nclass TradeExecutor:\n    \"\"\"Advanced trade execution with ATOMIC EXECUTION for arbitrage\"\"\"\n    \n    def __init__(self):\n        self.api = APIConnector()\n        self.balance_manager = BalanceManager()\n        self.logger = logging.getLogger(__name__)\n        self.pending_orders = {}\n        self.max_pending_orders = 3\n        self.slippage_tolerance = 0.001  # 0.1%\n        self.exchange_fees = {\n            'maker_fee': 0.0002,  # 0.02%\n            'taker_fee': 0.0006   # 0.06%\n        }\n        \n        # Connect to API\n        self.api.connect()\n    \n    def execute_arbitrage_trade(self, opportunity):\n        \"\"\"\n        Execute ATOMIC ARBITRAGE TRADE: Both orders placed simultaneously\n        \n        Args:\n            opportunity: Dict with trade details\n                - sell_pair: pair to sell (e.g., 'XRP/USDT')\n                - buy_pair: pair to buy (e.g., 'XRP/USDC')\n                - amount: XRP amount to trade\n                - sell_price: expected sell price\n                - buy_price: expected buy price\n                - estimated_profit: expected profit\n        \"\"\"\n        try:\n            # Check pending orders limit FIRST\n            current_pending = self.get_pending_orders_count()\n            if current_pending >= self.max_pending_orders:\n                self.logger.warning(f\"Maximum pending orders limit reached: {current_pending}/{self.max_pending_orders}\")\n                return None\n            \n            amount = opportunity['amount']\n            sell_pair = opportunity['sell_pair']\n            buy_pair = opportunity['buy_pair']\n            \n            self.logger.info(f\"Starting ATOMIC arbitrage trade: {amount} XRP ({sell_pair} -> {buy_pair})\")\n            \n            # Pre-flight checks with fees\n            net_profit = self._calculate_net_profit_with_fees(opportunity)\n            if net_profit <= 0:\n                self.logger.warning(f\"Trade not profitable after fees: {net_profit:.4f}\")\n                return None\n            \n            # Pre-validate balances for both sides\n            if not self._validate_atomic_trade_balances(opportunity):\n                self.logger.error(\"Insufficient balances for atomic trade\")\n                return None\n            \n            # Execute ATOMIC orders (simultaneous execution)\n            atomic_result = self._execute_atomic_orders(opportunity)\n            \n            if not atomic_result:\n                self.logger.error(\"Atomic order execution failed\")\n                return None\n            \n            # Process results\n            sell_trade = atomic_result['sell_trade']\n            buy_trade = atomic_result['buy_trade']\n            \n            # Calculate actual profit/loss with executed prices\n            actual_profit = self._calculate_actual_profit(sell_trade, buy_trade)\n            \n            # Update profit/loss for both trades\n            sell_trade.profit_loss = actual_profit / 2\n            buy_trade.profit_loss = actual_profit / 2\n            \n            db.session.commit()\n            \n            self.logger.info(f\"ATOMIC arbitrage completed. Actual P&L: {actual_profit:.4f}\")\n            \n            return {\n                'sell_trade': sell_trade,\n                'buy_trade': buy_trade,\n                'profit_loss': actual_profit,\n                'execution_type': 'atomic',\n                'slippage': self._calculate_slippage(opportunity, sell_trade, buy_trade)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error executing atomic arbitrage trade: {e}\")\n            db.session.rollback()\n            return None\n    \n    def _execute_sell_order(self, pair, amount, expected_price):\n        \"\"\"Execute a sell order\"\"\"\n        try:\n            # Check if we have sufficient XRP\n            if not self.balance_manager.check_sufficient_balance('XRP', amount):\n                raise Exception(\"Insufficient XRP balance for sell order\")\n            \n            # Lock XRP balance\n            self.balance_manager.lock_balance('XRP', amount)\n            \n            # Create trade record\n            trade = Trade(\n                trade_type='sell',\n                pair=pair,\n                amount=amount,\n                price=expected_price,\n                total_value=amount * expected_price,\n                status='pending'\n            )\n            db.session.add(trade)\n            db.session.flush()  # Get the trade ID\n            \n            # Execute order via API\n            order = self.api.create_order(\n                symbol=pair,\n                order_type='market',\n                side='sell',\n                amount=amount\n            )\n            \n            # Update trade with order details\n            trade.order_id = order['id']\n            trade.price = order['price']\n            trade.total_value = amount * order['price']\n            \n            # Simulate order completion\n            time.sleep(0.1)  # Small delay for realism\n            \n            # Check order status\n            status = self.api.get_order_status(order['id'], pair)\n            if status['status'] == 'closed':\n                trade.status = 'completed'\n                trade.completed_at = datetime.utcnow()\n                \n                # Update balances\n                self.balance_manager.unlock_balance('XRP', amount)\n                self.balance_manager.update_balance('XRP', -amount)\n                \n                # Determine which stablecoin we received\n                if 'USDT' in pair:\n                    self.balance_manager.update_balance('USDT', trade.total_value)\n                else:\n                    self.balance_manager.update_balance('USDC', trade.total_value)\n                \n                self.logger.info(f\"Sell order completed: {amount} XRP at {order['price']:.4f}\")\n            \n            db.session.commit()\n            return trade\n            \n        except Exception as e:\n            self.logger.error(f\"Error executing sell order: {e}\")\n            db.session.rollback()\n            # Unlock balance if it was locked\n            try:\n                self.balance_manager.unlock_balance('XRP', amount)\n            except:\n                pass\n            return None\n    \n    def _execute_buy_order(self, pair, amount, expected_price):\n        \"\"\"Execute a buy order\"\"\"\n        try:\n            # Determine which stablecoin we need\n            currency = 'USDT' if 'USDT' in pair else 'USDC'\n            required_value = amount * expected_price\n            \n            # Check if we have sufficient stablecoin\n            if not self.balance_manager.check_sufficient_balance(currency, required_value):\n                raise Exception(f\"Insufficient {currency} balance for buy order\")\n            \n            # Lock stablecoin balance\n            self.balance_manager.lock_balance(currency, required_value)\n            \n            # Create trade record\n            trade = Trade(\n                trade_type='buy',\n                pair=pair,\n                amount=amount,\n                price=expected_price,\n                total_value=required_value,\n                status='pending'\n            )\n            db.session.add(trade)\n            db.session.flush()  # Get the trade ID\n            \n            # Execute order via API\n            order = self.api.create_order(\n                symbol=pair,\n                order_type='market',\n                side='buy',\n                amount=amount\n            )\n            \n            # Update trade with order details\n            trade.order_id = order['id']\n            trade.price = order['price']\n            trade.total_value = amount * order['price']\n            \n            # Simulate order completion\n            time.sleep(0.1)  # Small delay for realism\n            \n            # Check order status\n            status = self.api.get_order_status(order['id'], pair)\n            if status['status'] == 'closed':\n                trade.status = 'completed'\n                trade.completed_at = datetime.utcnow()\n                \n                # Update balances\n                self.balance_manager.unlock_balance(currency, required_value)\n                self.balance_manager.update_balance(currency, -trade.total_value)\n                self.balance_manager.update_balance('XRP', amount)\n                \n                self.logger.info(f\"Buy order completed: {amount} XRP at {order['price']:.4f}\")\n            \n            db.session.commit()\n            return trade\n            \n        except Exception as e:\n            self.logger.error(f\"Error executing buy order: {e}\")\n            db.session.rollback()\n            # Unlock balance if it was locked\n            try:\n                if 'currency' in locals() and 'required_value' in locals():\n                    self.balance_manager.unlock_balance(currency, required_value)\n            except:\n                pass\n            return None\n    \n    def get_pending_orders_count(self):\n        \"\"\"Get count of pending orders\"\"\"\n        return Trade.query.filter_by(status='pending').count()\n    \n    def enforce_pending_orders_limit(self):\n        \"\"\"Enforce maximum pending orders limit\"\"\"\n        try:\n            current_count = self.get_pending_orders_count()\n            if current_count >= self.max_pending_orders:\n                self.logger.warning(f\"Pending orders limit reached: {current_count}/{self.max_pending_orders}\")\n                return False\n            return True\n        except Exception as e:\n            self.logger.error(f\"Error checking pending orders limit: {e}\")\n            return False\n    \n    def cancel_pending_orders(self):\n        \"\"\"Cancel all pending orders\"\"\"\n        try:\n            pending_trades = Trade.query.filter_by(status='pending').all()\n            \n            for trade in pending_trades:\n                if trade.order_id:\n                    try:\n                        self.api.cancel_order(trade.order_id, trade.pair)\n                    except:\n                        pass  # Order might already be completed\n                \n                trade.status = 'cancelled'\n                \n                # Unlock balances\n                if trade.trade_type == 'sell':\n                    self.balance_manager.unlock_balance('XRP', trade.amount)\n                else:\n                    currency = 'USDT' if 'USDT' in trade.pair else 'USDC'\n                    self.balance_manager.unlock_balance(currency, trade.total_value)\n            \n            db.session.commit()\n            self.logger.info(f\"Cancelled {len(pending_trades)} pending orders\")\n            \n        except Exception as e:\n            self.logger.error(f\"Error cancelling pending orders: {e}\")\n            db.session.rollback()\n    \n    def _calculate_net_profit_with_fees(self, opportunity):\n        \"\"\"Calculate net profit after exchange fees\"\"\"\n        try:\n            amount = opportunity['amount']\n            sell_price = opportunity['sell_price']\n            buy_price = opportunity['buy_price']\n            \n            # Calculate gross values\n            sell_gross = amount * sell_price\n            buy_gross = amount * buy_price\n            \n            # Apply exchange fees (using taker fees for conservative estimate)\n            sell_fee = sell_gross * self.exchange_fees['taker_fee']\n            buy_fee = buy_gross * self.exchange_fees['taker_fee']\n            \n            # Net values after fees\n            sell_net = sell_gross - sell_fee\n            buy_net = buy_gross + buy_fee  # We pay more when buying\n            \n            net_profit = sell_net - buy_net\n            \n            self.logger.debug(f\"Profit calculation: Sell {sell_net:.4f} - Buy {buy_net:.4f} = {net_profit:.4f}\")\n            return net_profit\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating net profit: {e}\")\n            return 0\n    \n    def _validate_atomic_trade_balances(self, opportunity):\n        \"\"\"Validate that we have sufficient balances for atomic trade\"\"\"\n        try:\n            amount = opportunity['amount']\n            buy_pair = opportunity['buy_pair']\n            buy_price = opportunity['buy_price']\n            \n            # Check XRP balance for sell side\n            if not self.balance_manager.check_sufficient_balance('XRP', amount):\n                self.logger.error(f\"Insufficient XRP balance: need {amount}\")\n                return False\n            \n            # Check stablecoin balance for buy side\n            currency = 'USDT' if 'USDT' in buy_pair else 'USDC'\n            required_value = amount * buy_price * (1 + self.exchange_fees['taker_fee'])  # Include fee buffer\n            \n            if not self.balance_manager.check_sufficient_balance(currency, required_value):\n                self.logger.error(f\"Insufficient {currency} balance: need {required_value:.4f}\")\n                return False\n            \n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error validating balances: {e}\")\n            return False\n    \n    def _execute_atomic_orders(self, opportunity):\n        \"\"\"Execute both orders simultaneously using thread pool\"\"\"\n        try:\n            self.logger.info(\"Executing ATOMIC orders simultaneously...\")\n            \n            # Prepare order parameters\n            sell_params = {\n                'pair': opportunity['sell_pair'],\n                'amount': opportunity['amount'],\n                'expected_price': opportunity['sell_price'],\n                'trade_type': 'sell'\n            }\n            \n            buy_params = {\n                'pair': opportunity['buy_pair'],\n                'amount': opportunity['amount'],\n                'expected_price': opportunity['buy_price'],\n                'trade_type': 'buy'\n            }\n            \n            # Execute both orders simultaneously using ThreadPoolExecutor\n            with ThreadPoolExecutor(max_workers=2) as executor:\n                # Submit both orders\n                sell_future = executor.submit(self._execute_single_atomic_order, sell_params)\n                buy_future = executor.submit(self._execute_single_atomic_order, buy_params)\n                \n                # Wait for both to complete with timeout\n                sell_trade = None\n                buy_trade = None\n                \n                try:\n                    # Wait for completion with 10 second timeout\n                    for future in as_completed([sell_future, buy_future], timeout=10):\n                        result = future.result()\n                        if result and result.trade_type == 'sell':\n                            sell_trade = result\n                        elif result and result.trade_type == 'buy':\n                            buy_trade = result\n                        else:\n                            self.logger.error(\"One order failed in atomic execution\")\n                            return None\n                \n                except Exception as e:\n                    self.logger.error(f\"Timeout or error in atomic execution: {e}\")\n                    return None\n            \n            # Validate both orders completed\n            if not sell_trade or not buy_trade:\n                self.logger.error(\"Atomic execution incomplete - rolling back\")\n                self._rollback_atomic_orders(sell_trade, buy_trade)\n                return None\n            \n            self.logger.info(\"ATOMIC orders executed successfully\")\n            return {\n                'sell_trade': sell_trade,\n                'buy_trade': buy_trade,\n                'execution_time': datetime.utcnow()\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error in atomic execution: {e}\")\n            return None\n    \n    def _execute_single_atomic_order(self, order_params):\n        \"\"\"Execute a single order as part of atomic execution\"\"\"\n        try:\n            pair = order_params['pair']\n            amount = order_params['amount']\n            expected_price = order_params['expected_price']\n            trade_type = order_params['trade_type']\n            \n            # Pre-lock balances\n            if trade_type == 'sell':\n                self.balance_manager.lock_balance('XRP', amount)\n                currency = 'XRP'\n                lock_amount = amount\n            else:\n                currency = 'USDT' if 'USDT' in pair else 'USDC'\n                required_value = amount * expected_price * (1 + self.exchange_fees['taker_fee'])\n                self.balance_manager.lock_balance(currency, required_value)\n                lock_amount = required_value\n            \n            # Create trade record\n            trade = Trade(\n                trade_type=trade_type,\n                pair=pair,\n                amount=amount,\n                price=expected_price,\n                total_value=amount * expected_price,\n                status='pending'\n            )\n            db.session.add(trade)\n            db.session.flush()\n            \n            # Execute order via API with slippage protection\n            order = self.api.create_order(\n                symbol=pair,\n                order_type='limit',  # Use limit orders for slippage protection\n                side=trade_type,\n                amount=amount,\n                price=expected_price * (1 - self.slippage_tolerance) if trade_type == 'sell' else expected_price * (1 + self.slippage_tolerance)\n            )\n            \n            # Update trade with order details\n            trade.order_id = order['id']\n            trade.price = order['price']\n            trade.total_value = amount * order['price']\n            \n            # Simulate order completion (immediate for limit orders in simulation)\n            time.sleep(0.05)  # Small delay for realism\n            \n            # Check order status\n            status = self.api.get_order_status(order['id'], pair)\n            if status['status'] == 'closed':\n                trade.status = 'completed'\n                trade.completed_at = datetime.utcnow()\n                \n                # Update balances\n                self.balance_manager.unlock_balance(currency, lock_amount)\n                \n                if trade_type == 'sell':\n                    self.balance_manager.update_balance('XRP', -amount)\n                    stablecoin = 'USDT' if 'USDT' in pair else 'USDC'\n                    self.balance_manager.update_balance(stablecoin, trade.total_value)\n                else:\n                    currency = 'USDT' if 'USDT' in pair else 'USDC'\n                    self.balance_manager.update_balance(currency, -trade.total_value)\n                    self.balance_manager.update_balance('XRP', amount)\n                \n                self.logger.info(f\"{trade_type.title()} order completed: {amount} XRP at {order['price']:.4f}\")\n            else:\n                trade.status = 'failed'\n                self.balance_manager.unlock_balance(currency, lock_amount)\n                return None\n            \n            db.session.commit()\n            return trade\n            \n        except Exception as e:\n            self.logger.error(f\"Error executing {trade_type} order: {e}\")\n            db.session.rollback()\n            return None\n    \n    def _rollback_atomic_orders(self, sell_trade, buy_trade):\n        \"\"\"Rollback failed atomic orders\"\"\"\n        try:\n            self.logger.warning(\"Rolling back failed atomic execution\")\n            \n            if sell_trade and sell_trade.order_id:\n                try:\n                    self.api.cancel_order(sell_trade.order_id, sell_trade.pair)\n                    sell_trade.status = 'cancelled'\n                except:\n                    pass\n            \n            if buy_trade and buy_trade.order_id:\n                try:\n                    self.api.cancel_order(buy_trade.order_id, buy_trade.pair)\n                    buy_trade.status = 'cancelled'\n                except:\n                    pass\n            \n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error rolling back atomic orders: {e}\")\n    \n    def _calculate_actual_profit(self, sell_trade, buy_trade):\n        \"\"\"Calculate actual profit from executed trades\"\"\"\n        try:\n            sell_value = sell_trade.total_value if sell_trade else 0\n            buy_value = buy_trade.total_value if buy_trade else 0\n            \n            # Apply actual fees based on executed prices\n            sell_fee = sell_value * self.exchange_fees['taker_fee']\n            buy_fee = buy_value * self.exchange_fees['taker_fee']\n            \n            actual_profit = (sell_value - sell_fee) - (buy_value + buy_fee)\n            \n            return actual_profit\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating actual profit: {e}\")\n            return 0\n    \n    def _calculate_slippage(self, opportunity, sell_trade, buy_trade):\n        \"\"\"Calculate slippage compared to expected prices\"\"\"\n        try:\n            expected_sell_price = opportunity['sell_price']\n            expected_buy_price = opportunity['buy_price']\n            \n            actual_sell_price = sell_trade.price if sell_trade else expected_sell_price\n            actual_buy_price = buy_trade.price if buy_trade else expected_buy_price\n            \n            sell_slippage = (expected_sell_price - actual_sell_price) / expected_sell_price\n            buy_slippage = (actual_buy_price - expected_buy_price) / expected_buy_price\n            \n            return {\n                'sell_slippage': sell_slippage,\n                'buy_slippage': buy_slippage,\n                'total_slippage_impact': sell_slippage + buy_slippage\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error calculating slippage: {e}\")\n            return {'sell_slippage': 0, 'buy_slippage': 0, 'total_slippage_impact': 0}\n    \n    def check_order_timeouts(self, timeout_seconds=30):\n        \"\"\"Check for and handle order timeouts\"\"\"\n        try:\n            cutoff_time = datetime.utcnow() - timedelta(seconds=timeout_seconds)\n            \n            timed_out_trades = Trade.query.filter(\n                Trade.status == 'pending',\n                Trade.created_at < cutoff_time\n            ).all()\n            \n            for trade in timed_out_trades:\n                self.logger.warning(f\"Order timeout detected: {trade.order_id}\")\n                \n                # Try to get final status\n                if trade.order_id:\n                    try:\n                        status = self.api.get_order_status(trade.order_id, trade.pair)\n                        if status['status'] == 'closed':\n                            trade.status = 'completed'\n                            trade.completed_at = datetime.utcnow()\n                        else:\n                            trade.status = 'timeout'\n                            # Unlock balances\n                            if trade.trade_type == 'sell':\n                                self.balance_manager.unlock_balance('XRP', trade.amount)\n                            else:\n                                currency = 'USDT' if 'USDT' in trade.pair else 'USDC'\n                                self.balance_manager.unlock_balance(currency, trade.total_value)\n                    except:\n                        trade.status = 'timeout'\n            \n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking order timeouts: {e}\")\n            db.session.rollback()\n","size_bytes":23916},"core/volume_tracker.py":{"content":"import logging\nfrom datetime import datetime, timedelta\nfrom app import db\nfrom models import DailyVolume, Trade, CircuitBreaker, TradingConfig\n\nclass VolumeTracker:\n    \"\"\"Daily volume tracking and circuit breaker management\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n    \n    def track_trade_volume(self, trade_amount_usd, profit_loss=0):\n        \"\"\"Track daily trading volume and profit/loss\"\"\"\n        try:\n            today = datetime.utcnow().date()\n            \n            # Get or create today's volume record\n            daily_volume = DailyVolume.query.filter_by(trade_date=today).first()\n            \n            if not daily_volume:\n                daily_volume = DailyVolume(\n                    trade_date=today,\n                    total_volume_usd=0.0,\n                    trade_count=0,\n                    profit_loss=0.0\n                )\n                db.session.add(daily_volume)\n            \n            # Update volume and P&L\n            daily_volume.total_volume_usd += trade_amount_usd\n            daily_volume.trade_count += 1\n            daily_volume.profit_loss += profit_loss\n            daily_volume.updated_at = datetime.utcnow()\n            \n            db.session.commit()\n            \n            self.logger.info(f\"Volume tracked: ${trade_amount_usd:.2f}, Today's total: ${daily_volume.total_volume_usd:.2f}\")\n            \n            # Check circuit breakers after updating volume\n            self._check_daily_loss_circuit_breaker(daily_volume)\n            \n            return daily_volume\n            \n        except Exception as e:\n            self.logger.error(f\"Error tracking volume: {e}\")\n            db.session.rollback()\n            return None\n    \n    def get_daily_volume(self, date=None):\n        \"\"\"Get daily volume for specific date (today if None)\"\"\"\n        try:\n            if date is None:\n                date = datetime.utcnow().date()\n            \n            daily_volume = DailyVolume.query.filter_by(trade_date=date).first()\n            \n            if not daily_volume:\n                # Return empty record for the date\n                return {\n                    'trade_date': date.isoformat(),\n                    'total_volume_usd': 0.0,\n                    'trade_count': 0,\n                    'profit_loss': 0.0\n                }\n            \n            return daily_volume.to_dict()\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting daily volume: {e}\")\n            return None\n    \n    def check_daily_volume_limit(self, proposed_trade_amount_usd, config):\n        \"\"\"Check if proposed trade would exceed daily volume limit\"\"\"\n        try:\n            today_volume = self.get_daily_volume()\n            current_volume = today_volume['total_volume_usd']\n            \n            if current_volume + proposed_trade_amount_usd > config.daily_max_volume:\n                return {\n                    'allowed': False,\n                    'reason': f'Would exceed daily limit: ${current_volume + proposed_trade_amount_usd:.2f} > ${config.daily_max_volume:.2f}',\n                    'current_volume': current_volume,\n                    'remaining_volume': config.daily_max_volume - current_volume\n                }\n            \n            return {\n                'allowed': True,\n                'current_volume': current_volume,\n                'remaining_volume': config.daily_max_volume - current_volume\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking daily volume limit: {e}\")\n            return {'allowed': False, 'reason': 'Volume check failed'}\n    \n    def _check_daily_loss_circuit_breaker(self, daily_volume):\n        \"\"\"Check and activate daily loss circuit breaker if needed\"\"\"\n        try:\n            config = TradingConfig.query.first()\n            if not config or not config.circuit_breaker_enabled:\n                return\n            \n            # Check if daily loss exceeds threshold\n            if daily_volume.profit_loss < -config.max_daily_loss:\n                self.activate_circuit_breaker(\n                    'daily_loss',\n                    f'Daily loss threshold exceeded: ${abs(daily_volume.profit_loss):.2f} > ${config.max_daily_loss:.2f}',\n                    abs(daily_volume.profit_loss),\n                    config.max_daily_loss\n                )\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking daily loss circuit breaker: {e}\")\n    \n    def activate_circuit_breaker(self, breaker_type, reason, trigger_value=None, threshold_value=None):\n        \"\"\"Activate a circuit breaker\"\"\"\n        try:\n            # Check if breaker is already active\n            existing_breaker = CircuitBreaker.query.filter_by(\n                breaker_type=breaker_type,\n                is_active=True\n            ).first()\n            \n            if existing_breaker:\n                self.logger.warning(f\"Circuit breaker {breaker_type} already active\")\n                return existing_breaker\n            \n            # Create new circuit breaker\n            breaker = CircuitBreaker(\n                breaker_type=breaker_type,\n                is_active=True,\n                trigger_reason=reason,\n                trigger_value=trigger_value,\n                threshold_value=threshold_value,\n                activated_at=datetime.utcnow(),\n                auto_reset=True,\n                reset_after_minutes=60  # Auto-reset after 1 hour\n            )\n            \n            db.session.add(breaker)\n            db.session.commit()\n            \n            self.logger.critical(f\"CIRCUIT BREAKER ACTIVATED: {breaker_type} - {reason}\")\n            \n            return breaker\n            \n        except Exception as e:\n            self.logger.error(f\"Error activating circuit breaker: {e}\")\n            db.session.rollback()\n            return None\n    \n    def check_circuit_breakers(self):\n        \"\"\"Check all active circuit breakers and auto-reset if needed\"\"\"\n        try:\n            active_breakers = CircuitBreaker.query.filter_by(is_active=True).all()\n            \n            current_time = datetime.utcnow()\n            results = []\n            \n            for breaker in active_breakers:\n                if breaker.auto_reset and breaker.activated_at:\n                    reset_time = breaker.activated_at + timedelta(minutes=breaker.reset_after_minutes)\n                    \n                    if current_time >= reset_time:\n                        # Auto-reset the breaker\n                        breaker.is_active = False\n                        breaker.reset_at = current_time\n                        \n                        self.logger.info(f\"Circuit breaker auto-reset: {breaker.breaker_type}\")\n                \n                results.append({\n                    'type': breaker.breaker_type,\n                    'active': breaker.is_active,\n                    'reason': breaker.trigger_reason,\n                    'activated_at': breaker.activated_at.isoformat() if breaker.activated_at else None,\n                    'reset_at': breaker.reset_at.isoformat() if breaker.reset_at else None\n                })\n            \n            db.session.commit()\n            \n            # Return status\n            has_active = any(b['active'] for b in results)\n            \n            return {\n                'has_active_breakers': has_active,\n                'breakers': results,\n                'trading_allowed': not has_active\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking circuit breakers: {e}\")\n            return {\n                'has_active_breakers': False,\n                'breakers': [],\n                'trading_allowed': True\n            }\n    \n    def manual_reset_circuit_breaker(self, breaker_type):\n        \"\"\"Manually reset a circuit breaker\"\"\"\n        try:\n            breaker = CircuitBreaker.query.filter_by(\n                breaker_type=breaker_type,\n                is_active=True\n            ).first()\n            \n            if not breaker:\n                return {'success': False, 'message': f'No active {breaker_type} circuit breaker found'}\n            \n            breaker.is_active = False\n            breaker.reset_at = datetime.utcnow()\n            \n            db.session.commit()\n            \n            self.logger.info(f\"Circuit breaker manually reset: {breaker_type}\")\n            \n            return {'success': True, 'message': f'{breaker_type} circuit breaker reset'}\n            \n        except Exception as e:\n            self.logger.error(f\"Error resetting circuit breaker: {e}\")\n            db.session.rollback()\n            return {'success': False, 'message': f'Error resetting breaker: {e}'}\n    \n    def get_volume_statistics(self, days=7):\n        \"\"\"Get volume statistics for the last N days\"\"\"\n        try:\n            end_date = datetime.utcnow().date()\n            start_date = end_date - timedelta(days=days-1)\n            \n            volumes = DailyVolume.query.filter(\n                DailyVolume.trade_date >= start_date,\n                DailyVolume.trade_date <= end_date\n            ).order_by(DailyVolume.trade_date.desc()).all()\n            \n            total_volume = sum(v.total_volume_usd for v in volumes)\n            total_trades = sum(v.trade_count for v in volumes)\n            total_profit = sum(v.profit_loss for v in volumes)\n            \n            return {\n                'period_days': days,\n                'total_volume_usd': total_volume,\n                'total_trades': total_trades,\n                'total_profit_loss': total_profit,\n                'average_daily_volume': total_volume / days if days > 0 else 0,\n                'average_daily_trades': total_trades / days if days > 0 else 0,\n                'daily_records': [v.to_dict() for v in volumes]\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting volume statistics: {e}\")\n            return None","size_bytes":10047},"core/websocket_manager.py":{"content":"import json\nimport asyncio\nimport websockets\nimport threading\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, Callable, Optional\nfrom urllib.parse import urljoin\n\nclass WebSocketManager:\n    \"\"\"专业WebSocket管理器 - 实时价格数据流\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        \n        # WebSocket连接配置\n        self.mexc_ws_url = 'wss://wbs.mexc.com/ws'\n        self.connections = {}\n        self.subscriptions = {}\n        \n        # 数据处理\n        self.price_callbacks = []\n        self.order_callbacks = []\n        self.event_callbacks = []\n        \n        # 连接状态\n        self.is_running = False\n        self.reconnect_attempts = {}\n        self.max_reconnect_attempts = 10\n        \n        # 数据缓存\n        self.latest_prices = {}\n        self.price_history_buffer = {}\n        self.connection_stats = {\n            'connected_since': None,\n            'messages_received': 0,\n            'reconnect_count': 0,\n            'last_ping': None\n        }\n        \n        # 事件循环\n        self.loop = None\n        self.websocket_thread = None\n    \n    def start(self):\n        \"\"\"启动WebSocket连接\"\"\"\n        try:\n            if self.is_running:\n                self.logger.warning(\"WebSocket管理器已在运行\")\n                return\n            \n            self.is_running = True\n            \n            # 在新线程中启动异步事件循环\n            self.websocket_thread = threading.Thread(target=self._run_websocket_loop, daemon=True)\n            self.websocket_thread.start()\n            \n            self.logger.info(\"🌐 专业WebSocket数据流已启动\")\n            \n        except Exception as e:\n            self.logger.error(f\"启动WebSocket失败: {e}\")\n            self.is_running = False\n    \n    def stop(self):\n        \"\"\"停止WebSocket连接\"\"\"\n        try:\n            self.is_running = False\n            \n            # 关闭所有连接\n            if self.loop:\n                asyncio.run_coroutine_threadsafe(self._close_all_connections(), self.loop)\n            \n            if self.websocket_thread and self.websocket_thread.is_alive():\n                self.websocket_thread.join(timeout=5)\n            \n            self.logger.info(\"🛑 WebSocket数据流已停止\")\n            \n        except Exception as e:\n            self.logger.error(f\"停止WebSocket失败: {e}\")\n    \n    def _run_websocket_loop(self):\n        \"\"\"运行WebSocket事件循环\"\"\"\n        try:\n            # 创建新的事件循环\n            self.loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.loop)\n            \n            # 启动主要的WebSocket任务\n            self.loop.run_until_complete(self._websocket_main())\n            \n        except Exception as e:\n            self.logger.error(f\"WebSocket事件循环错误: {e}\")\n        finally:\n            if self.loop:\n                self.loop.close()\n    \n    async def _websocket_main(self):\n        \"\"\"WebSocket主循环\"\"\"\n        try:\n            # 订阅XRP价格数据\n            await self.subscribe_to_price_data(['XRPUSDT', 'XRPUSDC'])\n            \n            # 保持连接活跃\n            while self.is_running:\n                await asyncio.sleep(1)\n                \n                # 检查连接健康状态\n                await self._check_connection_health()\n                \n        except Exception as e:\n            self.logger.error(f\"WebSocket主循环错误: {e}\")\n    \n    async def subscribe_to_price_data(self, symbols: list):\n        \"\"\"订阅价格数据流\"\"\"\n        try:\n            for symbol in symbols:\n                await self._create_price_stream(symbol)\n                \n        except Exception as e:\n            self.logger.error(f\"订阅价格数据失败: {e}\")\n    \n    async def _create_price_stream(self, symbol: str):\n        \"\"\"创建单个价格数据流\"\"\"\n        try:\n            # 构建订阅消息\n            subscribe_msg = {\n                \"method\": \"SUBSCRIPTION\",\n                \"params\": [f\"spot@public.miniTicker.v3.api@{symbol}\"],\n                \"id\": f\"price_{symbol}\"\n            }\n            \n            # 创建WebSocket连接\n            uri = self.mexc_ws_url\n            \n            async def price_stream_handler():\n                reconnect_count = 0\n                \n                while self.is_running and reconnect_count < self.max_reconnect_attempts:\n                    try:\n                        self.logger.info(f\"📡 连接价格数据流: {symbol}\")\n                        \n                        async with websockets.connect(uri, ping_interval=20, ping_timeout=10) as websocket:\n                            # 存储连接\n                            self.connections[symbol] = websocket\n                            self.connection_stats['connected_since'] = datetime.utcnow()\n                            \n                            # 发送订阅消息\n                            await websocket.send(json.dumps(subscribe_msg))\n                            \n                            # 重置重连计数\n                            reconnect_count = 0\n                            self.reconnect_attempts[symbol] = 0\n                            \n                            # 监听消息\n                            async for message in websocket:\n                                if not self.is_running:\n                                    break\n                                \n                                await self._handle_price_message(symbol, message)\n                                \n                    except websockets.exceptions.ConnectionClosed:\n                        reconnect_count += 1\n                        self.connection_stats['reconnect_count'] += 1\n                        self.logger.warning(f\"⚠️ {symbol} 连接断开，重连中... ({reconnect_count}/{self.max_reconnect_attempts})\")\n                        await asyncio.sleep(min(reconnect_count * 2, 30))  # 指数退避\n                        \n                    except Exception as e:\n                        reconnect_count += 1\n                        self.logger.error(f\"❌ {symbol} 连接错误: {e}\")\n                        await asyncio.sleep(5)\n                \n                # 清理连接\n                if symbol in self.connections:\n                    del self.connections[symbol]\n                \n                self.logger.error(f\"🚨 {symbol} 达到最大重连次数，停止连接\")\n            \n            # 启动价格流处理器\n            asyncio.create_task(price_stream_handler())\n            \n        except Exception as e:\n            self.logger.error(f\"创建价格数据流失败 {symbol}: {e}\")\n    \n    async def _handle_price_message(self, symbol: str, message: str):\n        \"\"\"处理价格消息\"\"\"\n        try:\n            data = json.loads(message)\n            \n            # 更新统计\n            self.connection_stats['messages_received'] += 1\n            self.connection_stats['last_ping'] = datetime.utcnow()\n            \n            # 处理不同类型的消息\n            if 'c' in data and 'v' in data:  # 价格和成交量数据\n                price_data = {\n                    'symbol': symbol,\n                    'price': float(data['c']),  # 最新价格\n                    'volume': float(data['v']),  # 24小时成交量\n                    'high': float(data.get('h', 0)),  # 24小时最高价\n                    'low': float(data.get('l', 0)),   # 24小时最低价\n                    'change': float(data.get('P', 0)),  # 24小时涨跌幅\n                    'timestamp': datetime.utcnow().isoformat()\n                }\n                \n                # 更新缓存\n                pair_name = f\"{symbol[:3]}/{symbol[3:]}\"  # XRP/USDT格式\n                self.latest_prices[pair_name] = price_data\n                \n                # 添加到历史缓冲区\n                if pair_name not in self.price_history_buffer:\n                    self.price_history_buffer[pair_name] = []\n                \n                self.price_history_buffer[pair_name].append(price_data)\n                \n                # 保持最近100个价格点\n                if len(self.price_history_buffer[pair_name]) > 100:\n                    self.price_history_buffer[pair_name] = self.price_history_buffer[pair_name][-100:]\n                \n                # 调用回调函数\n                await self._call_price_callbacks(pair_name, price_data)\n                \n                self.logger.debug(f\"💹 {pair_name}: {price_data['price']:.4f}\")\n                \n        except json.JSONDecodeError:\n            self.logger.warning(f\"⚠️ 无效JSON消息: {message}\")\n        except Exception as e:\n            self.logger.error(f\"处理价格消息失败: {e}\")\n    \n    async def _call_price_callbacks(self, symbol: str, price_data: dict):\n        \"\"\"调用价格更新回调\"\"\"\n        try:\n            for callback in self.price_callbacks:\n                try:\n                    if asyncio.iscoroutinefunction(callback):\n                        await callback(symbol, price_data)\n                    else:\n                        callback(symbol, price_data)\n                except Exception as e:\n                    self.logger.error(f\"价格回调错误: {e}\")\n                    \n        except Exception as e:\n            self.logger.error(f\"调用价格回调失败: {e}\")\n    \n    async def _check_connection_health(self):\n        \"\"\"检查连接健康状态\"\"\"\n        try:\n            current_time = datetime.utcnow()\n            \n            # 检查是否有消息接收\n            if (self.connection_stats['last_ping'] and \n                (current_time - self.connection_stats['last_ping']).total_seconds() > 60):\n                self.logger.warning(\"⚠️ 60秒未收到价格数据，可能存在连接问题\")\n            \n            # 发送心跳ping到活跃连接\n            for symbol, websocket in self.connections.items():\n                try:\n                    await websocket.ping()\n                except Exception as e:\n                    self.logger.warning(f\"⚠️ {symbol} ping失败: {e}\")\n                    \n        except Exception as e:\n            self.logger.error(f\"检查连接健康失败: {e}\")\n    \n    async def _close_all_connections(self):\n        \"\"\"关闭所有WebSocket连接\"\"\"\n        try:\n            for symbol, websocket in self.connections.items():\n                try:\n                    await websocket.close()\n                    self.logger.info(f\"🔌 已关闭 {symbol} 连接\")\n                except Exception as e:\n                    self.logger.error(f\"关闭连接失败 {symbol}: {e}\")\n            \n            self.connections.clear()\n            \n        except Exception as e:\n            self.logger.error(f\"关闭所有连接失败: {e}\")\n    \n    def add_price_callback(self, callback: Callable):\n        \"\"\"添加价格更新回调函数\"\"\"\n        self.price_callbacks.append(callback)\n        self.logger.info(f\"📞 已添加价格回调函数\")\n    \n    def remove_price_callback(self, callback: Callable):\n        \"\"\"移除价格更新回调函数\"\"\"\n        if callback in self.price_callbacks:\n            self.price_callbacks.remove(callback)\n            self.logger.info(f\"📞 已移除价格回调函数\")\n    \n    def get_latest_prices(self) -> Dict:\n        \"\"\"获取最新价格数据\"\"\"\n        return self.latest_prices.copy()\n    \n    def get_price_history(self, symbol: str, limit: int = 50) -> list:\n        \"\"\"获取价格历史数据\"\"\"\n        if symbol in self.price_history_buffer:\n            return self.price_history_buffer[symbol][-limit:]\n        return []\n    \n    def get_connection_stats(self) -> Dict:\n        \"\"\"获取连接统计信息\"\"\"\n        stats = self.connection_stats.copy()\n        stats['active_connections'] = len(self.connections)\n        stats['subscribed_symbols'] = list(self.connections.keys())\n        stats['is_running'] = self.is_running\n        \n        # 计算连接时长\n        if stats['connected_since']:\n            uptime = (datetime.utcnow() - stats['connected_since']).total_seconds()\n            stats['uptime_seconds'] = uptime\n            stats['uptime_formatted'] = f\"{int(uptime//3600)}h {int((uptime%3600)//60)}m {int(uptime%60)}s\"\n        \n        return stats\n    \n    def simulate_price_update(self, symbol: str, price: float, volume: float = 1000.0):\n        \"\"\"模拟价格更新（用于测试）\"\"\"\n        try:\n            price_data = {\n                'symbol': symbol.replace('/', ''),\n                'price': price,\n                'volume': volume,\n                'high': price * 1.02,\n                'low': price * 0.98,\n                'change': 0.5,\n                'timestamp': datetime.utcnow().isoformat()\n            }\n            \n            self.latest_prices[symbol] = price_data\n            \n            # 添加到历史缓冲区\n            if symbol not in self.price_history_buffer:\n                self.price_history_buffer[symbol] = []\n            \n            self.price_history_buffer[symbol].append(price_data)\n            \n            # 保持最近100个价格点\n            if len(self.price_history_buffer[symbol]) > 100:\n                self.price_history_buffer[symbol] = self.price_history_buffer[symbol][-100:]\n            \n            # 同步调用回调（模拟模式）\n            for callback in self.price_callbacks:\n                try:\n                    if not asyncio.iscoroutinefunction(callback):\n                        callback(symbol, price_data)\n                except Exception as e:\n                    self.logger.error(f\"模拟价格回调错误: {e}\")\n            \n            self.logger.debug(f\"🎯 模拟价格更新 {symbol}: {price:.4f}\")\n            \n        except Exception as e:\n            self.logger.error(f\"模拟价格更新失败: {e}\")","size_bytes":13972},"static/css/trading.css":{"content":"/* XRP Arbitrage Trading System - Dark Theme CSS */\n\n:root {\n    /* Trading Terminal Color Scheme */\n    --bg-primary: #0d1117;\n    --bg-secondary: #161b22;\n    --bg-tertiary: #21262d;\n    --border-color: #30363d;\n    --text-primary: #f0f6fc;\n    --text-secondary: #8b949e;\n    --text-muted: #6e7681;\n    \n    /* Trading Colors */\n    --color-profit: #238636;\n    --color-loss: #da3633;\n    --color-neutral: #7d8590;\n    --color-warning: #d29922;\n    --color-info: #0969da;\n    \n    /* Status Colors */\n    --color-success: #238636;\n    --color-danger: #da3633;\n    --color-warning: #bf8700;\n    --color-info: #0969da;\n    \n    /* Chart Colors */\n    --chart-grid: #30363d;\n    --chart-usdt: #26a641;\n    --chart-usdc: #1f6feb;\n    --chart-spread: #f85149;\n}\n\n/* Global Styles */\nbody.trading-terminal {\n    background-color: var(--bg-primary);\n    color: var(--text-primary);\n    font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;\n    font-size: 14px;\n    line-height: 1.6;\n}\n\n/* Card Styling */\n.trading-card {\n    background-color: var(--bg-secondary);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);\n}\n\n.trading-card .card-header {\n    background-color: var(--bg-tertiary);\n    border-bottom: 1px solid var(--border-color);\n    padding: 1rem 1.25rem;\n}\n\n.trading-card .card-header h5 {\n    color: var(--text-primary);\n    font-weight: 600;\n    margin: 0;\n}\n\n.trading-card .card-body {\n    background-color: var(--bg-secondary);\n    padding: 1.25rem;\n}\n\n/* Price Display */\n.price-display {\n    text-align: center;\n    padding: 1rem;\n    background-color: var(--bg-tertiary);\n    border-radius: 6px;\n    border: 1px solid var(--border-color);\n}\n\n.price-label {\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n    font-weight: 500;\n    margin-bottom: 0.5rem;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.price-value {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: var(--text-primary);\n    margin-bottom: 0.25rem;\n    font-family: 'SF Mono', monospace;\n}\n\n.price-change {\n    font-size: 0.875rem;\n    font-weight: 600;\n}\n\n.price-change.positive {\n    color: var(--color-profit);\n}\n\n.price-change.negative {\n    color: var(--color-loss);\n}\n\n.price-change.neutral {\n    color: var(--color-neutral);\n}\n\n/* Spread Display */\n.spread-display {\n    text-align: center;\n    padding: 1rem;\n    background-color: var(--bg-tertiary);\n    border-radius: 6px;\n    border: 1px solid var(--border-color);\n}\n\n.spread-value {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: var(--color-warning);\n    margin-bottom: 0.25rem;\n    font-family: 'SF Mono', monospace;\n}\n\n.spread-value.opportunity {\n    color: var(--color-profit);\n    animation: pulse-glow 2s infinite;\n}\n\n.spread-indicator {\n    font-size: 0.875rem;\n    font-weight: 500;\n}\n\n.spread-indicator.opportunity {\n    color: var(--color-profit);\n}\n\n/* Balance Grid */\n.balance-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));\n    gap: 1rem;\n    margin-bottom: 1rem;\n}\n\n.balance-item {\n    background-color: var(--bg-tertiary);\n    padding: 1rem;\n    border-radius: 6px;\n    border: 1px solid var(--border-color);\n    text-align: center;\n}\n\n.balance-currency {\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n    font-weight: 600;\n    margin-bottom: 0.5rem;\n}\n\n.balance-amount {\n    font-size: 1.25rem;\n    font-weight: 700;\n    color: var(--text-primary);\n    margin-bottom: 0.25rem;\n    font-family: 'SF Mono', monospace;\n}\n\n.balance-locked {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n}\n\n/* Statistics */\n.stat-item {\n    text-align: center;\n    margin-bottom: 1rem;\n}\n\n.stat-value {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: var(--text-primary);\n    margin-bottom: 0.25rem;\n    font-family: 'SF Mono', monospace;\n}\n\n.stat-label {\n    font-size: 0.75rem;\n    color: var(--text-secondary);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    font-weight: 500;\n}\n\n.profit-loss {\n    color: var(--color-neutral);\n}\n\n.profit-loss.positive {\n    color: var(--color-profit);\n}\n\n.profit-loss.negative {\n    color: var(--color-loss);\n}\n\n/* Trading Feed */\n.trading-feed {\n    height: 400px;\n    overflow-y: auto;\n    background-color: var(--bg-primary);\n    border-radius: 4px;\n    border: 1px solid var(--border-color);\n}\n\n.feed-item {\n    padding: 0.75rem 1rem;\n    border-bottom: 1px solid var(--border-color);\n    font-size: 0.875rem;\n    transition: background-color 0.2s;\n}\n\n.feed-item:hover {\n    background-color: var(--bg-tertiary);\n}\n\n.feed-item.new {\n    animation: highlight-new 2s ease-out;\n}\n\n.feed-item-time {\n    color: var(--text-muted);\n    font-size: 0.75rem;\n}\n\n.feed-item-type {\n    font-weight: 600;\n    text-transform: uppercase;\n    font-size: 0.75rem;\n}\n\n.feed-item-type.buy {\n    color: var(--color-profit);\n}\n\n.feed-item-type.sell {\n    color: var(--color-loss);\n}\n\n.feed-item-details {\n    color: var(--text-secondary);\n}\n\n/* Metrics Grid */\n.metrics-grid {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 1rem;\n    margin-bottom: 1rem;\n}\n\n.metric-item {\n    background-color: var(--bg-tertiary);\n    padding: 1rem;\n    border-radius: 6px;\n    border: 1px solid var(--border-color);\n    text-align: center;\n}\n\n.metric-value {\n    font-size: 1.25rem;\n    font-weight: 700;\n    color: var(--text-primary);\n    margin-bottom: 0.25rem;\n    font-family: 'SF Mono', monospace;\n}\n\n.metric-label {\n    font-size: 0.75rem;\n    color: var(--text-secondary);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    font-weight: 500;\n}\n\n/* Risk Indicators */\n.risk-indicators {\n    space-y: 0.5rem;\n}\n\n.risk-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.5rem 0;\n    border-bottom: 1px solid var(--border-color);\n    font-size: 0.875rem;\n}\n\n.risk-item:last-child {\n    border-bottom: none;\n}\n\n/* Quick Stats */\n.quick-stats {\n    space-y: 0.5rem;\n}\n\n.stat-row {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.5rem 0;\n    border-bottom: 1px solid var(--border-color);\n    font-size: 0.875rem;\n}\n\n.stat-row:last-child {\n    border-bottom: none;\n}\n\n/* Configuration Styles */\n.config-summary {\n    background-color: var(--bg-tertiary);\n    padding: 1rem;\n    border-radius: 6px;\n    border: 1px solid var(--border-color);\n}\n\n.status-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.5rem 0;\n    border-bottom: 1px solid var(--border-color);\n}\n\n.status-item:last-child {\n    border-bottom: none;\n}\n\n.status-label {\n    font-weight: 500;\n}\n\n.preview-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0.5rem 0;\n    border-bottom: 1px solid var(--border-color);\n    font-size: 0.875rem;\n}\n\n.preview-item:last-child {\n    border-bottom: none;\n}\n\n.preview-calculation {\n    background-color: var(--bg-tertiary);\n    padding: 0.75rem;\n    border-radius: 4px;\n    border: 1px solid var(--border-color);\n}\n\n/* Status Indicators */\n.status-indicator {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.status-dot {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    display: inline-block;\n}\n\n.status-dot.connected {\n    background-color: var(--color-success);\n    animation: pulse-dot 2s infinite;\n}\n\n.status-dot.disconnected {\n    background-color: var(--color-danger);\n}\n\n.status-dot.warning {\n    background-color: var(--color-warning);\n}\n\n/* Table Styling */\n.table-dark {\n    --bs-table-bg: var(--bg-secondary);\n    --bs-table-striped-bg: var(--bg-tertiary);\n    --bs-table-hover-bg: var(--bg-tertiary);\n    border-color: var(--border-color);\n}\n\n.table-dark th,\n.table-dark td {\n    border-color: var(--border-color);\n    font-size: 0.875rem;\n}\n\n.table-dark thead th {\n    background-color: var(--bg-tertiary);\n    border-bottom: 2px solid var(--border-color);\n    font-weight: 600;\n    text-transform: uppercase;\n    font-size: 0.75rem;\n    letter-spacing: 0.5px;\n}\n\n/* Form Controls */\n.form-control,\n.form-select {\n    background-color: var(--bg-tertiary);\n    border: 1px solid var(--border-color);\n    color: var(--text-primary);\n}\n\n.form-control:focus,\n.form-select:focus {\n    background-color: var(--bg-tertiary);\n    border-color: var(--color-info);\n    box-shadow: 0 0 0 0.2rem rgba(9, 105, 218, 0.25);\n    color: var(--text-primary);\n}\n\n.form-label {\n    color: var(--text-primary);\n    font-weight: 500;\n}\n\n.form-text {\n    color: var(--text-muted);\n}\n\n.input-group-text {\n    background-color: var(--bg-tertiary);\n    border: 1px solid var(--border-color);\n    color: var(--text-secondary);\n}\n\n/* Buttons */\n.btn-primary {\n    background-color: var(--color-info);\n    border-color: var(--color-info);\n}\n\n.btn-primary:hover {\n    background-color: #0860ca;\n    border-color: #0860ca;\n}\n\n.btn-success {\n    background-color: var(--color-success);\n    border-color: var(--color-success);\n}\n\n.btn-success:hover {\n    background-color: #1f7e34;\n    border-color: #1f7e34;\n}\n\n.btn-danger {\n    background-color: var(--color-danger);\n    border-color: var(--color-danger);\n}\n\n.btn-danger:hover {\n    background-color: #c82333;\n    border-color: #c82333;\n}\n\n.btn-outline-primary {\n    color: var(--color-info);\n    border-color: var(--color-info);\n}\n\n.btn-outline-primary:hover {\n    background-color: var(--color-info);\n    border-color: var(--color-info);\n}\n\n.btn-outline-secondary {\n    color: var(--text-secondary);\n    border-color: var(--border-color);\n}\n\n.btn-outline-secondary:hover {\n    background-color: var(--bg-tertiary);\n    border-color: var(--border-color);\n    color: var(--text-primary);\n}\n\n/* Badges */\n.badge {\n    font-size: 0.75rem;\n    font-weight: 600;\n}\n\n.badge.bg-success {\n    background-color: var(--color-success) !important;\n}\n\n.badge.bg-danger {\n    background-color: var(--color-danger) !important;\n}\n\n.badge.bg-warning {\n    background-color: var(--color-warning) !important;\n}\n\n.badge.bg-info {\n    background-color: var(--color-info) !important;\n}\n\n/* Animations */\n@keyframes pulse-glow {\n    0%, 100% {\n        opacity: 1;\n        box-shadow: 0 0 5px rgba(34, 134, 58, 0.5);\n    }\n    50% {\n        opacity: 0.8;\n        box-shadow: 0 0 20px rgba(34, 134, 58, 0.8);\n    }\n}\n\n@keyframes pulse-dot {\n    0%, 100% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0.5;\n    }\n}\n\n@keyframes highlight-new {\n    0% {\n        background-color: rgba(34, 134, 58, 0.3);\n    }\n    100% {\n        background-color: transparent;\n    }\n}\n\n/* Chart Containers */\n.chart-container {\n    position: relative;\n    height: 300px;\n}\n\n/* Scrollbar Styling */\n::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background-color: var(--bg-secondary);\n}\n\n::-webkit-scrollbar-thumb {\n    background-color: var(--border-color);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background-color: var(--text-muted);\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .balance-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .metrics-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .price-display {\n        margin-bottom: 1rem;\n    }\n    \n    .trading-feed {\n        height: 300px;\n    }\n    \n    .stat-value {\n        font-size: 1.25rem;\n    }\n    \n    .metric-value {\n        font-size: 1rem;\n    }\n}\n\n@media (max-width: 576px) {\n    body.trading-terminal {\n        font-size: 13px;\n    }\n    \n    .card-body {\n        padding: 1rem;\n    }\n    \n    .price-value {\n        font-size: 1.25rem;\n    }\n    \n    .spread-value {\n        font-size: 1.25rem;\n    }\n    \n    .balance-amount {\n        font-size: 1rem;\n    }\n}\n\n/* Dark theme overrides for Bootstrap components */\n.navbar-dark {\n    background-color: var(--bg-secondary) !important;\n    border-bottom: 1px solid var(--border-color) !important;\n}\n\n.alert-success {\n    background-color: rgba(35, 134, 54, 0.2);\n    border-color: var(--color-success);\n    color: #75fb4c;\n}\n\n.alert-danger {\n    background-color: rgba(218, 54, 51, 0.2);\n    border-color: var(--color-danger);\n    color: #ff6b6b;\n}\n\n.alert-warning {\n    background-color: rgba(210, 153, 34, 0.2);\n    border-color: var(--color-warning);\n    color: #ffd93d;\n}\n\n.alert-info {\n    background-color: rgba(9, 105, 218, 0.2);\n    border-color: var(--color-info);\n    color: #58a6ff;\n}\n\n/* Loading States */\n.loading {\n    opacity: 0.6;\n    pointer-events: none;\n}\n\n.loading::after {\n    content: \"\";\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 20px;\n    height: 20px;\n    margin: -10px 0 0 -10px;\n    border: 2px solid var(--border-color);\n    border-top-color: var(--color-info);\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    to {\n        transform: rotate(360deg);\n    }\n}\n","size_bytes":12914},"static/js/charts.js":{"content":"// XRP Arbitrage Trading System - Charts JavaScript\n\nclass TradingCharts {\n    constructor() {\n        this.charts = {};\n        this.chartColors = {\n            primary: '#0969da',\n            success: '#238636',\n            danger: '#da3633',\n            warning: '#d29922',\n            info: '#0969da',\n            usdt: '#26a641',\n            usdc: '#1f6feb',\n            spread: '#f85149',\n            grid: '#30363d',\n            text: '#f0f6fc',\n            textMuted: '#8b949e'\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        this.configureChartDefaults();\n        console.log('Trading Charts initialized');\n    }\n    \n    configureChartDefaults() {\n        // Configure Chart.js defaults for dark theme\n        Chart.defaults.color = this.chartColors.text;\n        Chart.defaults.borderColor = this.chartColors.grid;\n        Chart.defaults.backgroundColor = 'rgba(9, 105, 218, 0.1)';\n        \n        Chart.defaults.scales.linear.grid.color = this.chartColors.grid;\n        Chart.defaults.scales.linear.ticks.color = this.chartColors.textMuted;\n        Chart.defaults.scales.time.grid.color = this.chartColors.grid;\n        Chart.defaults.scales.time.ticks.color = this.chartColors.textMuted;\n        \n        Chart.defaults.plugins.legend.labels.color = this.chartColors.text;\n        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(33, 38, 45, 0.9)';\n        Chart.defaults.plugins.tooltip.titleColor = this.chartColors.text;\n        Chart.defaults.plugins.tooltip.bodyColor = this.chartColors.text;\n        Chart.defaults.plugins.tooltip.borderColor = this.chartColors.grid;\n        Chart.defaults.plugins.tooltip.borderWidth = 1;\n    }\n    \n    // Dashboard Price Chart\n    initializePriceChart() {\n        const ctx = document.getElementById('priceChart');\n        if (!ctx) return null;\n        \n        const config = {\n            type: 'line',\n            data: {\n                datasets: [\n                    {\n                        label: 'XRP/USDT',\n                        data: [],\n                        borderColor: this.chartColors.usdt,\n                        backgroundColor: 'rgba(38, 166, 65, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.1,\n                        pointRadius: 0,\n                        pointHoverRadius: 4\n                    },\n                    {\n                        label: 'XRP/USDC',\n                        data: [],\n                        borderColor: this.chartColors.usdc,\n                        backgroundColor: 'rgba(31, 111, 235, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.1,\n                        pointRadius: 0,\n                        pointHoverRadius: 4\n                    },\n                    {\n                        label: 'Spread %',\n                        data: [],\n                        borderColor: this.chartColors.spread,\n                        backgroundColor: 'rgba(248, 81, 73, 0.1)',\n                        borderWidth: 1,\n                        fill: false,\n                        tension: 0.1,\n                        pointRadius: 0,\n                        pointHoverRadius: 4,\n                        yAxisID: 'spread'\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                interaction: {\n                    intersect: false,\n                    mode: 'index'\n                },\n                plugins: {\n                    legend: {\n                        position: 'top',\n                        align: 'end',\n                        labels: {\n                            boxWidth: 12,\n                            padding: 15,\n                            font: {\n                                size: 12\n                            }\n                        }\n                    },\n                    tooltip: {\n                        callbacks: {\n                            title: function(context) {\n                                if (context[0].parsed.x) {\n                                    return new Date(context[0].parsed.x).toLocaleString();\n                                }\n                                return '';\n                            },\n                            label: function(context) {\n                                if (context.datasetIndex === 2) { // Spread\n                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}%`;\n                                } else { // Prices\n                                    return `${context.dataset.label}: $${context.parsed.y.toFixed(4)}`;\n                                }\n                            }\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        type: 'time',\n                        time: {\n                            displayFormats: {\n                                minute: 'HH:mm',\n                                hour: 'HH:mm'\n                            }\n                        },\n                        title: {\n                            display: false\n                        },\n                        grid: {\n                            display: true,\n                            color: this.chartColors.grid\n                        }\n                    },\n                    y: {\n                        type: 'linear',\n                        display: true,\n                        position: 'left',\n                        title: {\n                            display: true,\n                            text: 'Price (USD)',\n                            font: {\n                                size: 12\n                            }\n                        },\n                        grid: {\n                            display: true,\n                            color: this.chartColors.grid\n                        }\n                    },\n                    spread: {\n                        type: 'linear',\n                        display: true,\n                        position: 'right',\n                        title: {\n                            display: true,\n                            text: 'Spread (%)',\n                            font: {\n                                size: 12\n                            }\n                        },\n                        grid: {\n                            display: false\n                        },\n                        min: 0\n                    }\n                },\n                animation: {\n                    duration: 0\n                }\n            }\n        };\n        \n        this.charts.priceChart = new Chart(ctx, config);\n        this.loadPriceHistory();\n        \n        return this.charts.priceChart;\n    }\n    \n    async loadPriceHistory() {\n        if (!this.charts.priceChart) return;\n        \n        try {\n            const response = await fetch('/api/chart/price-history?hours=24');\n            if (!response.ok) throw new Error('Failed to fetch price history');\n            \n            const data = await response.json();\n            this.updatePriceChartData(data);\n            \n        } catch (error) {\n            console.error('Error loading price history:', error);\n        }\n    }\n    \n    updatePriceChartData(data) {\n        if (!this.charts.priceChart || !data.usdt || !data.usdc) return;\n        \n        // Update USDT dataset\n        this.charts.priceChart.data.datasets[0].data = data.usdt.map(point => ({\n            x: new Date(point.time),\n            y: point.price\n        }));\n        \n        // Update USDC dataset\n        this.charts.priceChart.data.datasets[1].data = data.usdc.map(point => ({\n            x: new Date(point.time),\n            y: point.price\n        }));\n        \n        // Calculate and update spread dataset\n        const spreads = this.calculateSpreadFromPriceData(data);\n        this.charts.priceChart.data.datasets[2].data = spreads;\n        \n        this.charts.priceChart.update('none');\n    }\n    \n    calculateSpreadFromPriceData(data) {\n        const spreads = [];\n        \n        data.usdt.forEach(usdtPoint => {\n            const matchingUsdc = data.usdc.find(usdcPoint => \n                Math.abs(new Date(usdcPoint.time) - new Date(usdtPoint.time)) < 60000\n            );\n            \n            if (matchingUsdc) {\n                const spread = Math.abs(usdtPoint.price - matchingUsdc.price);\n                const spreadPct = (spread / Math.min(usdtPoint.price, matchingUsdc.price)) * 100;\n                \n                spreads.push({\n                    x: new Date(usdtPoint.time),\n                    y: spreadPct\n                });\n            }\n        });\n        \n        return spreads;\n    }\n    \n    // Monitor P&L Chart\n    initializePnlChart() {\n        const ctx = document.getElementById('pnlChart');\n        if (!ctx) return null;\n        \n        const config = {\n            type: 'line',\n            data: {\n                datasets: [\n                    {\n                        label: 'Cumulative P&L',\n                        data: [],\n                        borderColor: this.chartColors.primary,\n                        backgroundColor: 'rgba(9, 105, 218, 0.1)',\n                        borderWidth: 2,\n                        fill: true,\n                        tension: 0.1,\n                        pointRadius: 0,\n                        pointHoverRadius: 4\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                interaction: {\n                    intersect: false,\n                    mode: 'index'\n                },\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        callbacks: {\n                            title: function(context) {\n                                if (context[0].parsed.x) {\n                                    return new Date(context[0].parsed.x).toLocaleString();\n                                }\n                                return '';\n                            },\n                            label: function(context) {\n                                return `P&L: $${context.parsed.y.toFixed(2)}`;\n                            }\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        type: 'time',\n                        time: {\n                            displayFormats: {\n                                minute: 'HH:mm',\n                                hour: 'MMM DD HH:mm',\n                                day: 'MMM DD'\n                            }\n                        },\n                        title: {\n                            display: false\n                        },\n                        grid: {\n                            display: true,\n                            color: this.chartColors.grid\n                        }\n                    },\n                    y: {\n                        title: {\n                            display: true,\n                            text: 'Cumulative P&L ($)',\n                            font: {\n                                size: 12\n                            }\n                        },\n                        grid: {\n                            display: true,\n                            color: this.chartColors.grid\n                        },\n                        ticks: {\n                            callback: function(value) {\n                                return '$' + value.toFixed(2);\n                            }\n                        }\n                    }\n                },\n                animation: {\n                    duration: 0\n                }\n            }\n        };\n        \n        this.charts.pnlChart = new Chart(ctx, config);\n        this.loadPnlHistory();\n        \n        return this.charts.pnlChart;\n    }\n    \n    async loadPnlHistory(timeframe = '24h') {\n        if (!this.charts.pnlChart) return;\n        \n        try {\n            const days = timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 1;\n            const response = await fetch(`/api/chart/profit-trend?days=${days}`);\n            if (!response.ok) throw new Error('Failed to fetch P&L history');\n            \n            const data = await response.json();\n            \n            this.charts.pnlChart.data.datasets[0].data = data.map(point => ({\n                x: new Date(point.time),\n                y: point.cumulative\n            }));\n            \n            // Update line color based on final P&L\n            const finalPnl = data.length > 0 ? data[data.length - 1].cumulative : 0;\n            this.charts.pnlChart.data.datasets[0].borderColor = finalPnl >= 0 ? this.chartColors.success : this.chartColors.danger;\n            this.charts.pnlChart.data.datasets[0].backgroundColor = finalPnl >= 0 ? \n                'rgba(35, 134, 54, 0.1)' : 'rgba(218, 54, 51, 0.1)';\n            \n            this.charts.pnlChart.update('none');\n            \n        } catch (error) {\n            console.error('Error loading P&L history:', error);\n        }\n    }\n    \n    // Monitor Distribution Chart\n    initializeDistributionChart() {\n        const ctx = document.getElementById('distributionChart');\n        if (!ctx) return null;\n        \n        const config = {\n            type: 'doughnut',\n            data: {\n                labels: ['Profitable', 'Loss'],\n                datasets: [\n                    {\n                        data: [0, 0],\n                        backgroundColor: [\n                            this.chartColors.success,\n                            this.chartColors.danger\n                        ],\n                        borderColor: [\n                            this.chartColors.success,\n                            this.chartColors.danger\n                        ],\n                        borderWidth: 2,\n                        hoverOffset: 4\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        position: 'bottom',\n                        labels: {\n                            boxWidth: 12,\n                            padding: 15,\n                            font: {\n                                size: 12\n                            }\n                        }\n                    },\n                    tooltip: {\n                        callbacks: {\n                            label: function(context) {\n                                const label = context.label || '';\n                                const value = context.parsed;\n                                const total = context.dataset.data.reduce((a, b) => a + b, 0);\n                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : '0.0';\n                                return `${label}: ${value} (${percentage}%)`;\n                            }\n                        }\n                    }\n                },\n                animation: {\n                    duration: 750,\n                    easing: 'easeInOutQuart'\n                }\n            }\n        };\n        \n        this.charts.distributionChart = new Chart(ctx, config);\n        this.loadDistributionData();\n        \n        return this.charts.distributionChart;\n    }\n    \n    async loadDistributionData() {\n        if (!this.charts.distributionChart) return;\n        \n        try {\n            const response = await fetch('/api/profit/stats');\n            if (!response.ok) throw new Error('Failed to fetch distribution data');\n            \n            const stats = await response.json();\n            \n            const profitable = stats.profitable_trades_count || 0;\n            const losing = stats.losing_trades_count || 0;\n            \n            this.charts.distributionChart.data.datasets[0].data = [profitable, losing];\n            this.charts.distributionChart.update();\n            \n        } catch (error) {\n            console.error('Error loading distribution data:', error);\n        }\n    }\n    \n    // Monitor Spread Chart\n    initializeSpreadChart() {\n        const ctx = document.getElementById('spreadChart');\n        if (!ctx) return null;\n        \n        const config = {\n            type: 'line',\n            data: {\n                datasets: [\n                    {\n                        label: 'Spread %',\n                        data: [],\n                        borderColor: this.chartColors.spread,\n                        backgroundColor: 'rgba(248, 81, 73, 0.1)',\n                        borderWidth: 2,\n                        fill: true,\n                        tension: 0.1,\n                        pointRadius: 0,\n                        pointHoverRadius: 4\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                interaction: {\n                    intersect: false,\n                    mode: 'index'\n                },\n                plugins: {\n                    legend: {\n                        display: false\n                    },\n                    tooltip: {\n                        callbacks: {\n                            title: function(context) {\n                                if (context[0].parsed.x) {\n                                    return new Date(context[0].parsed.x).toLocaleString();\n                                }\n                                return '';\n                            },\n                            label: function(context) {\n                                return `Spread: ${context.parsed.y.toFixed(4)}%`;\n                            }\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        type: 'time',\n                        time: {\n                            displayFormats: {\n                                minute: 'HH:mm',\n                                hour: 'HH:mm'\n                            }\n                        },\n                        title: {\n                            display: false\n                        },\n                        grid: {\n                            display: true,\n                            color: this.chartColors.grid\n                        }\n                    },\n                    y: {\n                        title: {\n                            display: true,\n                            text: 'Spread (%)',\n                            font: {\n                                size: 12\n                            }\n                        },\n                        grid: {\n                            display: true,\n                            color: this.chartColors.grid\n                        },\n                        min: 0,\n                        ticks: {\n                            callback: function(value) {\n                                return value.toFixed(3) + '%';\n                            }\n                        }\n                    }\n                },\n                animation: {\n                    duration: 0\n                }\n            }\n        };\n        \n        this.charts.spreadChart = new Chart(ctx, config);\n        this.loadSpreadHistory();\n        \n        return this.charts.spreadChart;\n    }\n    \n    async loadSpreadHistory(hours = 6) {\n        if (!this.charts.spreadChart) return;\n        \n        try {\n            const response = await fetch(`/api/chart/price-history?hours=${hours}`);\n            if (!response.ok) throw new Error('Failed to fetch spread history');\n            \n            const data = await response.json();\n            const spreads = this.calculateSpreadFromPriceData(data);\n            \n            this.charts.spreadChart.data.datasets[0].data = spreads;\n            this.charts.spreadChart.update('none');\n            \n        } catch (error) {\n            console.error('Error loading spread history:', error);\n        }\n    }\n    \n    // Update methods for real-time data\n    updatePriceChart(priceData) {\n        if (!this.charts.priceChart || !priceData) return;\n        \n        const now = new Date();\n        const datasets = this.charts.priceChart.data.datasets;\n        \n        // Add new USDT price point\n        if (priceData['XRP/USDT']) {\n            datasets[0].data.push({\n                x: now,\n                y: priceData['XRP/USDT'].price\n            });\n        }\n        \n        // Add new USDC price point\n        if (priceData['XRP/USDC']) {\n            datasets[1].data.push({\n                x: now,\n                y: priceData['XRP/USDC'].price\n            });\n        }\n        \n        // Add new spread point\n        if (priceData.spread_percentage) {\n            datasets[2].data.push({\n                x: now,\n                y: priceData.spread_percentage\n            });\n        }\n        \n        // Keep only last 100 points for performance\n        datasets.forEach(dataset => {\n            if (dataset.data.length > 100) {\n                dataset.data = dataset.data.slice(-100);\n            }\n        });\n        \n        this.charts.priceChart.update('none');\n    }\n    \n    // Utility methods\n    destroyChart(chartName) {\n        if (this.charts[chartName]) {\n            this.charts[chartName].destroy();\n            delete this.charts[chartName];\n        }\n    }\n    \n    destroyAllCharts() {\n        Object.keys(this.charts).forEach(chartName => {\n            this.destroyChart(chartName);\n        });\n    }\n    \n    // Chart animation helpers\n    animateValue(element, startValue, endValue, duration = 1000) {\n        const start = Date.now();\n        const range = endValue - startValue;\n        \n        const update = () => {\n            const elapsed = Date.now() - start;\n            const progress = Math.min(elapsed / duration, 1);\n            \n            // Easing function (ease-out cubic)\n            const easedProgress = 1 - Math.pow(1 - progress, 3);\n            const currentValue = startValue + (range * easedProgress);\n            \n            element.textContent = currentValue.toFixed(2);\n            \n            if (progress < 1) {\n                requestAnimationFrame(update);\n            }\n        };\n        \n        requestAnimationFrame(update);\n    }\n    \n    // Chart color helpers\n    getColorForValue(value, positiveColor = this.chartColors.success, negativeColor = this.chartColors.danger) {\n        if (value > 0) return positiveColor;\n        if (value < 0) return negativeColor;\n        return this.chartColors.textMuted;\n    }\n    \n    // Chart data helpers\n    formatTimestamp(timestamp) {\n        return new Date(timestamp).toLocaleString();\n    }\n    \n    formatCurrency(value) {\n        return '$' + value.toFixed(2);\n    }\n    \n    formatPercentage(value) {\n        return value.toFixed(2) + '%';\n    }\n}\n\n// Initialize global charts instance\nwindow.tradingCharts = new TradingCharts();\n\n// Global functions for template usage\nwindow.initializePriceChart = () => {\n    return window.tradingCharts.initializePriceChart();\n};\n\nwindow.initializePnlChart = () => {\n    return window.tradingCharts.initializePnlChart();\n};\n\nwindow.initializeDistributionChart = () => {\n    return window.tradingCharts.initializeDistributionChart();\n};\n\nwindow.initializeSpreadChart = () => {\n    return window.tradingCharts.initializeSpreadChart();\n};\n\nwindow.updatePriceChart = (data) => {\n    window.tradingCharts.updatePriceChart(data);\n};\n\n// Chart update functions for monitor\nwindow.updatePnlChart = (timeframe) => {\n    if (window.tradingCharts.charts.pnlChart) {\n        window.tradingCharts.loadPnlHistory(timeframe);\n    }\n};\n\nwindow.updateDistributionChart = () => {\n    if (window.tradingCharts.charts.distributionChart) {\n        window.tradingCharts.loadDistributionData();\n    }\n};\n\nwindow.updateSpreadChart = (timeframe) => {\n    if (window.tradingCharts.charts.spreadChart) {\n        const hours = timeframe === '1h' ? 1 : timeframe === '6h' ? 6 : timeframe === '24h' ? 24 : 6;\n        window.tradingCharts.loadSpreadHistory(hours);\n    }\n};\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (window.tradingCharts) {\n        window.tradingCharts.destroyAllCharts();\n    }\n});\n\n// Export for module usage\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = TradingCharts;\n}\n","size_bytes":24798},"static/js/dashboard.js":{"content":"// XRP Arbitrage Trading System - Dashboard JavaScript\n\nclass TradingDashboard {\n    constructor() {\n        this.isTrading = false;\n        this.priceChart = null;\n        this.updateIntervals = {};\n        this.lastPrices = {};\n        \n        this.init();\n    }\n    \n    init() {\n        this.bindEvents();\n        this.loadInitialData();\n        console.log('Trading Dashboard initialized');\n    }\n    \n    bindEvents() {\n        // Trading control buttons\n        document.getElementById('start-trading-btn')?.addEventListener('click', () => this.startTrading());\n        document.getElementById('stop-trading-btn')?.addEventListener('click', () => this.stopTrading());\n        \n        // Price update events\n        document.addEventListener('priceUpdate', (e) => this.handlePriceUpdate(e.detail));\n        document.addEventListener('balanceUpdate', (e) => this.handleBalanceUpdate(e.detail));\n    }\n    \n    async loadInitialData() {\n        try {\n            await Promise.all([\n                this.updatePrices(),\n                this.updateBalances(),\n                this.updateTodayStats(),\n                this.updateSystemStatus()\n            ]);\n        } catch (error) {\n            console.error('Error loading initial data:', error);\n            this.showError('Failed to load initial data');\n        }\n    }\n    \n    async updatePrices() {\n        try {\n            const response = await fetch('/api/prices');\n            if (!response.ok) throw new Error('Failed to fetch prices');\n            \n            const data = await response.json();\n            this.updatePriceDisplay(data);\n            this.updateSpreadIndicator(data);\n            \n            // Store for chart updates\n            this.lastPrices = data;\n            \n        } catch (error) {\n            console.error('Error updating prices:', error);\n            this.updatePriceStatus('error');\n        }\n    }\n    \n    updatePriceDisplay(data) {\n        if (!data || !data['XRP/USDT'] || !data['XRP/USDC']) {\n            return;\n        }\n        \n        // Update XRP/USDT\n        const usdtPrice = data['XRP/USDT'].price;\n        const usdtElement = document.getElementById('xrp-usdt-price');\n        if (usdtElement) {\n            usdtElement.textContent = '$' + usdtPrice.toFixed(4);\n            this.animateValueChange(usdtElement, this.lastPrices['XRP/USDT']?.price, usdtPrice);\n        }\n        \n        // Update XRP/USDC\n        const usdcPrice = data['XRP/USDC'].price;\n        const usdcElement = document.getElementById('xrp-usdc-price');\n        if (usdcElement) {\n            usdcElement.textContent = '$' + usdcPrice.toFixed(4);\n            this.animateValueChange(usdcElement, this.lastPrices['XRP/USDC']?.price, usdcPrice);\n        }\n        \n        // Update price changes (simplified - would need historical data for real changes)\n        this.updatePriceChange('xrp-usdt-change', 0.12); // Mock change\n        this.updatePriceChange('xrp-usdc-change', -0.08); // Mock change\n        \n        // Update last update time\n        const lastUpdateElement = document.getElementById('last-price-update');\n        if (lastUpdateElement) {\n            lastUpdateElement.textContent = new Date().toLocaleTimeString();\n        }\n        \n        this.updatePriceStatus('connected');\n    }\n    \n    updatePriceChange(elementId, changePercent) {\n        const element = document.getElementById(elementId);\n        if (!element) return;\n        \n        const sign = changePercent >= 0 ? '+' : '';\n        element.textContent = `${sign}${changePercent.toFixed(2)}%`;\n        \n        element.className = 'price-change';\n        if (changePercent > 0) {\n            element.classList.add('positive');\n        } else if (changePercent < 0) {\n            element.classList.add('negative');\n        } else {\n            element.classList.add('neutral');\n        }\n    }\n    \n    updateSpreadIndicator(data) {\n        if (!data.spread_percentage) return;\n        \n        const spreadValue = document.getElementById('spread-value');\n        const spreadIndicator = document.getElementById('spread-indicator');\n        \n        if (spreadValue) {\n            spreadValue.textContent = data.spread_percentage.toFixed(4) + '%';\n        }\n        \n        if (spreadIndicator) {\n            const threshold = 0.003; // 0.3% threshold\n            \n            if (data.spread_percentage >= threshold) {\n                spreadIndicator.innerHTML = '<i class=\"fas fa-circle text-success\"></i> Opportunity';\n                spreadIndicator.classList.add('opportunity');\n                spreadValue.classList.add('opportunity');\n            } else {\n                spreadIndicator.innerHTML = '<i class=\"fas fa-circle text-secondary\"></i> No Opportunity';\n                spreadIndicator.classList.remove('opportunity');\n                spreadValue.classList.remove('opportunity');\n            }\n        }\n    }\n    \n    async updateBalances() {\n        try {\n            const response = await fetch('/api/balances');\n            if (!response.ok) throw new Error('Failed to fetch balances');\n            \n            const data = await response.json();\n            this.updateBalanceDisplay(data);\n            \n        } catch (error) {\n            console.error('Error updating balances:', error);\n        }\n    }\n    \n    updateBalanceDisplay(balances) {\n        // Update individual balances\n        ['XRP', 'USDT', 'USDC'].forEach(currency => {\n            const balance = balances[currency];\n            if (!balance) return;\n            \n            const balanceEl = document.getElementById(`${currency.toLowerCase()}-balance`);\n            const lockedEl = document.getElementById(`${currency.toLowerCase()}-locked`);\n            \n            if (balanceEl) {\n                balanceEl.textContent = balance.free.toLocaleString(undefined, {\n                    minimumFractionDigits: 2,\n                    maximumFractionDigits: 2\n                });\n            }\n            \n            if (lockedEl) {\n                lockedEl.textContent = balance.locked.toLocaleString(undefined, {\n                    minimumFractionDigits: 2,\n                    maximumFractionDigits: 2\n                });\n            }\n        });\n        \n        // Calculate and update portfolio total\n        this.updatePortfolioTotal(balances);\n    }\n    \n    updatePortfolioTotal(balances) {\n        let total = 0;\n        \n        // Add stablecoin values\n        if (balances.USDT) total += balances.USDT.total;\n        if (balances.USDC) total += balances.USDC.total;\n        \n        // Add XRP value (assuming current price)\n        if (balances.XRP && this.lastPrices['XRP/USDT']) {\n            total += balances.XRP.total * this.lastPrices['XRP/USDT'].price;\n        }\n        \n        const portfolioElement = document.getElementById('portfolio-total');\n        if (portfolioElement) {\n            portfolioElement.textContent = '$' + total.toLocaleString(undefined, {\n                minimumFractionDigits: 2,\n                maximumFractionDigits: 2\n            });\n        }\n    }\n    \n    async updateTodayStats() {\n        try {\n            const response = await fetch('/api/profit/stats');\n            if (!response.ok) throw new Error('Failed to fetch stats');\n            \n            const data = await response.json();\n            this.updateStatsDisplay(data);\n            \n        } catch (error) {\n            console.error('Error updating today stats:', error);\n        }\n    }\n    \n    updateStatsDisplay(stats) {\n        // Update today's trades count\n        const tradesEl = document.getElementById('today-trades');\n        if (tradesEl) {\n            tradesEl.textContent = stats.total_trades || 0;\n        }\n        \n        // Update P&L\n        const pnlEl = document.getElementById('today-pnl');\n        if (pnlEl) {\n            const pnl = stats.total_profit_loss || 0;\n            pnlEl.textContent = '$' + pnl.toFixed(2);\n            \n            pnlEl.className = 'stat-value profit-loss';\n            if (pnl > 0) {\n                pnlEl.classList.add('positive');\n            } else if (pnl < 0) {\n                pnlEl.classList.add('negative');\n            }\n        }\n        \n        // Update volume\n        const volumeEl = document.getElementById('today-volume');\n        if (volumeEl) {\n            volumeEl.textContent = (stats.total_volume || 0).toLocaleString();\n        }\n        \n        // Update success rate\n        const successEl = document.getElementById('success-rate');\n        if (successEl) {\n            successEl.textContent = (stats.success_rate || 0).toFixed(1) + '%';\n        }\n    }\n    \n    async updateRecentTrades() {\n        try {\n            const response = await fetch('/api/trades/recent?limit=10');\n            if (!response.ok) throw new Error('Failed to fetch recent trades');\n            \n            const trades = await response.json();\n            this.updateRecentTradesTable(trades);\n            \n        } catch (error) {\n            console.error('Error updating recent trades:', error);\n        }\n    }\n    \n    updateRecentTradesTable(trades) {\n        const tbody = document.getElementById('recent-trades');\n        if (!tbody) return;\n        \n        if (!trades || trades.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"7\" class=\"text-center text-muted\">No recent trades</td></tr>';\n            return;\n        }\n        \n        tbody.innerHTML = trades.map(trade => {\n            const time = new Date(trade.created_at).toLocaleTimeString();\n            const pnl = trade.profit_loss || 0;\n            const pnlClass = pnl > 0 ? 'text-success' : pnl < 0 ? 'text-danger' : 'text-muted';\n            const statusClass = this.getStatusClass(trade.status);\n            \n            return `\n                <tr>\n                    <td>${time}</td>\n                    <td class=\"text-uppercase fw-bold ${trade.type === 'buy' ? 'text-success' : 'text-danger'}\">${trade.type}</td>\n                    <td>${trade.pair}</td>\n                    <td>${trade.amount.toFixed(2)}</td>\n                    <td>$${trade.price.toFixed(4)}</td>\n                    <td class=\"${pnlClass}\">$${pnl.toFixed(2)}</td>\n                    <td><span class=\"badge ${statusClass}\">${trade.status}</span></td>\n                </tr>\n            `;\n        }).join('');\n    }\n    \n    getStatusClass(status) {\n        switch (status) {\n            case 'completed': return 'bg-success';\n            case 'pending': return 'bg-warning';\n            case 'failed': return 'bg-danger';\n            default: return 'bg-secondary';\n        }\n    }\n    \n    async updateSystemStatus() {\n        try {\n            const response = await fetch('/api/system-status');\n            if (!response.ok) throw new Error('Failed to fetch system status');\n            \n            const status = await response.json();\n            this.updateStatusDisplay(status);\n            \n        } catch (error) {\n            console.error('Error updating system status:', error);\n            this.updatePriceStatus('error');\n        }\n    }\n    \n    updateStatusDisplay(status) {\n        // Update trading status\n        const tradingStatusEl = document.getElementById('trading-status');\n        if (tradingStatusEl) {\n            tradingStatusEl.textContent = status.trading_active ? 'Running' : 'Stopped';\n            tradingStatusEl.className = `badge ${status.trading_active ? 'bg-success' : 'bg-secondary'}`;\n        }\n        \n        // Update API status\n        const apiStatusEl = document.getElementById('api-status');\n        if (apiStatusEl) {\n            if (status.api_connected) {\n                apiStatusEl.innerHTML = '<i class=\"fas fa-check-circle\"></i> Connected';\n                apiStatusEl.className = 'text-success';\n            } else {\n                apiStatusEl.innerHTML = '<i class=\"fas fa-times-circle\"></i> Disconnected';\n                apiStatusEl.className = 'text-danger';\n            }\n        }\n        \n        // Update pending orders\n        const pendingEl = document.getElementById('pending-orders');\n        if (pendingEl) {\n            pendingEl.textContent = status.pending_orders || 0;\n        }\n        \n        // Update button states\n        this.updateButtonStates(status.trading_active);\n    }\n    \n    updateButtonStates(isTrading) {\n        const startBtn = document.getElementById('start-trading-btn');\n        const stopBtn = document.getElementById('stop-trading-btn');\n        \n        if (startBtn && stopBtn) {\n            startBtn.disabled = isTrading;\n            stopBtn.disabled = !isTrading;\n            \n            if (isTrading) {\n                startBtn.innerHTML = '<i class=\"fas fa-play me-2\"></i>Running...';\n                stopBtn.innerHTML = '<i class=\"fas fa-stop me-2\"></i>Stop Trading';\n            } else {\n                startBtn.innerHTML = '<i class=\"fas fa-play me-2\"></i>Start Trading';\n                stopBtn.innerHTML = '<i class=\"fas fa-stop me-2\"></i>Stopped';\n            }\n        }\n        \n        this.isTrading = isTrading;\n    }\n    \n    updatePriceStatus(status) {\n        const statusEl = document.getElementById('price-update-status');\n        if (!statusEl) return;\n        \n        switch (status) {\n            case 'connected':\n                statusEl.textContent = 'Live';\n                statusEl.className = 'badge bg-success';\n                break;\n            case 'error':\n                statusEl.textContent = 'Error';\n                statusEl.className = 'badge bg-danger';\n                break;\n            case 'loading':\n                statusEl.textContent = 'Loading';\n                statusEl.className = 'badge bg-warning';\n                break;\n            default:\n                statusEl.textContent = 'Unknown';\n                statusEl.className = 'badge bg-secondary';\n        }\n    }\n    \n    async startTrading() {\n        if (this.isTrading) return;\n        \n        try {\n            this.showLoading('start-trading-btn');\n            \n            const response = await fetch('/api/start-trading', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            \n            const result = await response.json();\n            \n            if (result.success) {\n                this.showSuccess('Trading started successfully');\n                this.updateButtonStates(true);\n            } else {\n                this.showError('Failed to start trading: ' + result.message);\n            }\n            \n        } catch (error) {\n            console.error('Error starting trading:', error);\n            this.showError('Failed to start trading');\n        } finally {\n            this.hideLoading('start-trading-btn');\n        }\n    }\n    \n    async stopTrading() {\n        if (!this.isTrading) return;\n        \n        try {\n            this.showLoading('stop-trading-btn');\n            \n            const response = await fetch('/api/stop-trading', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            \n            const result = await response.json();\n            \n            if (result.success) {\n                this.showSuccess('Trading stopped successfully');\n                this.updateButtonStates(false);\n            } else {\n                this.showError('Failed to stop trading: ' + result.message);\n            }\n            \n        } catch (error) {\n            console.error('Error stopping trading:', error);\n            this.showError('Failed to stop trading');\n        } finally {\n            this.hideLoading('stop-trading-btn');\n        }\n    }\n    \n    // Animation helpers\n    animateValueChange(element, oldValue, newValue) {\n        if (oldValue === undefined || oldValue === newValue) return;\n        \n        element.style.transition = 'color 0.3s ease';\n        \n        if (newValue > oldValue) {\n            element.style.color = '#238636'; // Green\n        } else if (newValue < oldValue) {\n            element.style.color = '#da3633'; // Red\n        }\n        \n        setTimeout(() => {\n            element.style.color = '';\n        }, 1000);\n    }\n    \n    // UI helpers\n    showLoading(buttonId) {\n        const button = document.getElementById(buttonId);\n        if (button) {\n            button.disabled = true;\n            button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Loading...';\n        }\n    }\n    \n    hideLoading(buttonId) {\n        const button = document.getElementById(buttonId);\n        if (button) {\n            button.disabled = false;\n            // Button text will be updated by updateButtonStates\n        }\n    }\n    \n    showSuccess(message) {\n        this.showAlert(message, 'success');\n    }\n    \n    showError(message) {\n        this.showAlert(message, 'danger');\n    }\n    \n    showAlert(message, type) {\n        // Create alert element\n        const alertDiv = document.createElement('div');\n        alertDiv.className = `alert alert-${type} alert-dismissible fade show`;\n        alertDiv.innerHTML = `\n            <i class=\"fas fa-${type === 'success' ? 'check-circle' : 'exclamation-triangle'} me-2\"></i>\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        // Insert at top of main content\n        const main = document.querySelector('main');\n        main.insertBefore(alertDiv, main.firstChild);\n        \n        // Auto remove after 5 seconds\n        setTimeout(() => {\n            if (alertDiv.parentNode) {\n                alertDiv.remove();\n            }\n        }, 5000);\n    }\n    \n    handlePriceUpdate(data) {\n        this.updatePriceDisplay(data);\n        this.updateSpreadIndicator(data);\n    }\n    \n    handleBalanceUpdate(data) {\n        this.updateBalanceDisplay(data);\n    }\n}\n\n// Global functions for template usage\nwindow.initializeDashboard = () => {\n    window.dashboard = new TradingDashboard();\n};\n\nwindow.updatePrices = () => {\n    if (window.dashboard) {\n        window.dashboard.updatePrices();\n    }\n};\n\nwindow.updateBalances = () => {\n    if (window.dashboard) {\n        window.dashboard.updateBalances();\n    }\n};\n\nwindow.updateTodayStats = () => {\n    if (window.dashboard) {\n        window.dashboard.updateTodayStats();\n    }\n};\n\nwindow.updateRecentTrades = () => {\n    if (window.dashboard) {\n        window.dashboard.updateRecentTrades();\n    }\n};\n\nwindow.updateSystemStatus = () => {\n    if (window.dashboard) {\n        window.dashboard.updateSystemStatus();\n    }\n};\n\nwindow.startTrading = () => {\n    if (window.dashboard) {\n        window.dashboard.startTrading();\n    }\n};\n\nwindow.stopTrading = () => {\n    if (window.dashboard) {\n        window.dashboard.stopTrading();\n    }\n};\n","size_bytes":18862},"static/js/monitor.js":{"content":"// XRP Arbitrage Trading System - Trading Monitor JavaScript\n\nclass TradingMonitor {\n    constructor() {\n        this.feedUpdateInterval = null;\n        this.analyticsUpdateInterval = null;\n        this.charts = {};\n        this.tradingFeed = [];\n        this.maxFeedItems = 1000;\n        \n        this.init();\n    }\n    \n    init() {\n        this.bindEvents();\n        this.initializeCharts();\n        this.startPeriodicUpdates();\n        console.log('Trading Monitor initialized');\n    }\n    \n    bindEvents() {\n        // History query form\n        document.getElementById('history-query-form')?.addEventListener('submit', (e) => {\n            e.preventDefault();\n            this.executeHistoryQuery();\n        });\n        \n        // Chart timeframe selectors\n        document.getElementById('pnl-timeframe')?.addEventListener('change', (e) => {\n            this.updatePnlChart(e.target.value);\n        });\n        \n        // Spread chart buttons\n        document.querySelectorAll('[onclick*=\"updateSpreadChart\"]').forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                e.preventDefault();\n                const timeframe = e.target.getAttribute('onclick').match(/'(\\w+)'/)[1];\n                this.updateSpreadChart(timeframe);\n                \n                // Update active button\n                document.querySelectorAll('[onclick*=\"updateSpreadChart\"]').forEach(b => b.classList.remove('active'));\n                e.target.classList.add('active');\n            });\n        });\n    }\n    \n    initializeCharts() {\n        // Initialize all charts\n        this.initializePnlChart();\n        this.initializeDistributionChart();\n        this.initializeSpreadChart();\n    }\n    \n    startPeriodicUpdates() {\n        // Update trading feed every 3 seconds\n        this.feedUpdateInterval = setInterval(() => {\n            this.updateTradingFeed();\n        }, 3000);\n        \n        // Update analytics every 10 seconds\n        this.analyticsUpdateInterval = setInterval(() => {\n            this.updateAnalytics();\n        }, 10000);\n        \n        // Update charts every 30 seconds\n        setInterval(() => {\n            this.updateCharts();\n        }, 30000);\n    }\n    \n    async updateTradingFeed() {\n        try {\n            const response = await fetch('/api/trades/recent?limit=20');\n            if (!response.ok) throw new Error('Failed to fetch recent trades');\n            \n            const trades = await response.json();\n            this.updateFeedWithTrades(trades);\n            \n        } catch (error) {\n            console.error('Error updating trading feed:', error);\n            this.updateFeedStatus('error');\n        }\n    }\n    \n    updateFeedWithTrades(trades) {\n        if (!trades || trades.length === 0) return;\n        \n        const feedContainer = document.getElementById('trading-feed');\n        if (!feedContainer) return;\n        \n        // Check for new trades\n        const newTrades = trades.filter(trade => \n            !this.tradingFeed.some(existing => existing.id === trade.id)\n        );\n        \n        // Add new trades to the beginning of the feed\n        newTrades.reverse().forEach(trade => {\n            this.addTradeToFeed(trade, true);\n        });\n        \n        // Update internal feed array\n        this.tradingFeed = trades;\n        \n        // Limit feed size\n        this.limitFeedSize();\n        \n        this.updateFeedStatus('live');\n    }\n    \n    addTradeToFeed(trade, isNew = false) {\n        const feedContainer = document.getElementById('trading-feed');\n        if (!feedContainer) return;\n        \n        const time = new Date(trade.created_at).toLocaleTimeString();\n        const pnl = trade.profit_loss || 0;\n        const pnlText = pnl !== 0 ? `P&L: $${pnl.toFixed(2)}` : '';\n        const pnlClass = pnl > 0 ? 'text-success' : pnl < 0 ? 'text-danger' : 'text-muted';\n        \n        const feedItem = document.createElement('div');\n        feedItem.className = `feed-item ${isNew ? 'new' : ''}`;\n        feedItem.innerHTML = `\n            <div class=\"d-flex justify-content-between align-items-start\">\n                <div class=\"flex-grow-1\">\n                    <div class=\"d-flex align-items-center gap-2 mb-1\">\n                        <span class=\"feed-item-type ${trade.type}\">${trade.type.toUpperCase()}</span>\n                        <span class=\"text-muted\">${trade.pair}</span>\n                        <span class=\"badge ${this.getStatusClass(trade.status)}\">${trade.status}</span>\n                    </div>\n                    <div class=\"feed-item-details\">\n                        Amount: ${trade.amount.toFixed(2)} XRP @ $${trade.price.toFixed(4)}\n                        ${pnlText ? `<span class=\"ms-2 ${pnlClass}\">${pnlText}</span>` : ''}\n                    </div>\n                </div>\n                <div class=\"feed-item-time\">${time}</div>\n            </div>\n        `;\n        \n        // Insert at the beginning\n        if (feedContainer.firstChild && feedContainer.firstChild.classList?.contains('text-center')) {\n            // Replace placeholder message\n            feedContainer.innerHTML = '';\n        }\n        \n        feedContainer.insertBefore(feedItem, feedContainer.firstChild);\n        \n        // Animate new items\n        if (isNew) {\n            setTimeout(() => feedItem.classList.remove('new'), 2000);\n        }\n    }\n    \n    limitFeedSize() {\n        const feedContainer = document.getElementById('trading-feed');\n        if (!feedContainer) return;\n        \n        const items = feedContainer.querySelectorAll('.feed-item');\n        if (items.length > this.maxFeedItems) {\n            for (let i = this.maxFeedItems; i < items.length; i++) {\n                items[i].remove();\n            }\n        }\n    }\n    \n    updateFeedStatus(status) {\n        const statusEl = document.getElementById('feed-status');\n        if (!statusEl) return;\n        \n        switch (status) {\n            case 'live':\n                statusEl.textContent = 'Live';\n                statusEl.className = 'badge bg-success';\n                break;\n            case 'error':\n                statusEl.textContent = 'Error';\n                statusEl.className = 'badge bg-danger';\n                break;\n            case 'paused':\n                statusEl.textContent = 'Paused';\n                statusEl.className = 'badge bg-warning';\n                break;\n        }\n    }\n    \n    async updateAnalytics() {\n        try {\n            const response = await fetch('/api/profit/stats');\n            if (!response.ok) throw new Error('Failed to fetch analytics');\n            \n            const stats = await response.json();\n            this.updateAnalyticsDisplay(stats);\n            \n        } catch (error) {\n            console.error('Error updating analytics:', error);\n        }\n    }\n    \n    updateAnalyticsDisplay(stats) {\n        // Update key metrics\n        const totalPnlEl = document.getElementById('total-pnl');\n        if (totalPnlEl) {\n            const pnl = stats.total_profit_loss || 0;\n            totalPnlEl.textContent = '$' + pnl.toFixed(2);\n            totalPnlEl.className = 'metric-value profit-loss';\n            if (pnl > 0) {\n                totalPnlEl.classList.add('positive');\n            } else if (pnl < 0) {\n                totalPnlEl.classList.add('negative');\n            }\n        }\n        \n        const winRateEl = document.getElementById('win-rate');\n        if (winRateEl) {\n            winRateEl.textContent = (stats.success_rate || 0).toFixed(1) + '%';\n        }\n        \n        const avgTradeEl = document.getElementById('avg-trade');\n        if (avgTradeEl) {\n            avgTradeEl.textContent = '$' + (stats.avg_profit_per_trade || 0).toFixed(2);\n        }\n        \n        const maxDrawdownEl = document.getElementById('max-drawdown');\n        if (maxDrawdownEl && stats.drawdown) {\n            maxDrawdownEl.textContent = '$' + (stats.drawdown.max_drawdown || 0).toFixed(2);\n        }\n        \n        // Update risk indicators\n        this.updateRiskIndicators(stats);\n        \n        // Update quick stats\n        this.updateQuickStats(stats);\n    }\n    \n    updateRiskIndicators(stats) {\n        // Risk score\n        const riskScoreEl = document.getElementById('risk-score');\n        if (riskScoreEl && stats.risk_metrics) {\n            const riskScore = stats.risk_metrics.risk_score || 0;\n            let riskLevel, riskClass;\n            \n            if (riskScore < 30) {\n                riskLevel = 'Low';\n                riskClass = 'bg-success';\n            } else if (riskScore < 60) {\n                riskLevel = 'Medium';\n                riskClass = 'bg-warning';\n            } else {\n                riskLevel = 'High';\n                riskClass = 'bg-danger';\n            }\n            \n            riskScoreEl.textContent = riskLevel;\n            riskScoreEl.className = `badge ${riskClass}`;\n        }\n        \n        // Volatility level\n        const volatilityEl = document.getElementById('volatility-level');\n        if (volatilityEl && stats.risk_metrics) {\n            const volatility = stats.risk_metrics.volatility || 0;\n            let level;\n            \n            if (volatility < 0.01) {\n                level = 'Low';\n            } else if (volatility < 0.03) {\n                level = 'Normal';\n            } else {\n                level = 'High';\n            }\n            \n            volatilityEl.textContent = level;\n        }\n        \n        // Daily volume usage (mock calculation)\n        const dailyVolumeEl = document.getElementById('daily-volume-usage');\n        if (dailyVolumeEl) {\n            const usage = ((stats.total_volume || 0) / 5000 * 100).toFixed(1);\n            dailyVolumeEl.textContent = usage + '%';\n        }\n    }\n    \n    updateQuickStats(stats) {\n        // Active since (mock - would need start time tracking)\n        const activeSinceEl = document.getElementById('active-since');\n        if (activeSinceEl) {\n            activeSinceEl.textContent = '2 hours 15 min';\n        }\n        \n        // Opportunities today (mock - would need opportunity tracking)\n        const opportunitiesEl = document.getElementById('opportunities-today');\n        if (opportunitiesEl) {\n            opportunitiesEl.textContent = Math.floor(Math.random() * 20) + 10;\n        }\n        \n        // Execution rate\n        const executionRateEl = document.getElementById('execution-rate');\n        if (executionRateEl) {\n            const rate = stats.total_trades > 0 ? ((stats.profitable_trades_count || 0) / stats.total_trades * 100) : 0;\n            executionRateEl.textContent = rate.toFixed(1) + '%';\n        }\n        \n        // Best spread (mock)\n        const bestSpreadEl = document.getElementById('best-spread');\n        if (bestSpreadEl) {\n            bestSpreadEl.textContent = '0.045%';\n        }\n    }\n    \n    async executeHistoryQuery() {\n        const period = document.getElementById('query-period')?.value || '24h';\n        const status = document.getElementById('query-status')?.value || 'all';\n        const pair = document.getElementById('query-pair')?.value || 'all';\n        \n        try {\n            let url = `/api/trades/recent?limit=1000`;\n            const response = await fetch(url);\n            if (!response.ok) throw new Error('Failed to fetch trade history');\n            \n            let trades = await response.json();\n            \n            // Filter trades based on query parameters\n            trades = this.filterTrades(trades, { period, status, pair });\n            \n            // Update detailed trades table\n            this.updateDetailedTradesTable(trades);\n            \n            // Update query results summary\n            this.updateQueryResults(trades);\n            \n            // Show results panel\n            const resultsPanel = document.getElementById('query-results');\n            if (resultsPanel) {\n                resultsPanel.style.display = 'block';\n            }\n            \n        } catch (error) {\n            console.error('Error executing history query:', error);\n            this.showError('Failed to execute query');\n        }\n    }\n    \n    filterTrades(trades, filters) {\n        return trades.filter(trade => {\n            // Status filter\n            if (filters.status !== 'all' && trade.status !== filters.status) {\n                return false;\n            }\n            \n            // Pair filter\n            if (filters.pair !== 'all' && trade.pair !== filters.pair) {\n                return false;\n            }\n            \n            // Period filter (simplified - would need proper date filtering)\n            const tradeDate = new Date(trade.created_at);\n            const now = new Date();\n            const hoursDiff = (now - tradeDate) / (1000 * 60 * 60);\n            \n            switch (filters.period) {\n                case '1h':\n                    return hoursDiff <= 1;\n                case '6h':\n                    return hoursDiff <= 6;\n                case '24h':\n                    return hoursDiff <= 24;\n                case '7d':\n                    return hoursDiff <= 168; // 7 * 24\n                case '30d':\n                    return hoursDiff <= 720; // 30 * 24\n                default:\n                    return true;\n            }\n        });\n    }\n    \n    updateQueryResults(trades) {\n        const totalEl = document.getElementById('query-total');\n        const volumeEl = document.getElementById('query-volume');\n        const pnlEl = document.getElementById('query-pnl');\n        \n        if (totalEl) totalEl.textContent = trades.length;\n        \n        const totalVolume = trades.reduce((sum, trade) => sum + trade.amount, 0);\n        if (volumeEl) volumeEl.textContent = totalVolume.toFixed(0) + ' XRP';\n        \n        const totalPnl = trades.reduce((sum, trade) => sum + (trade.profit_loss || 0), 0);\n        if (pnlEl) {\n            pnlEl.textContent = '$' + totalPnl.toFixed(2);\n            pnlEl.className = 'profit-loss';\n            if (totalPnl > 0) {\n                pnlEl.classList.add('positive');\n            } else if (totalPnl < 0) {\n                pnlEl.classList.add('negative');\n            }\n        }\n    }\n    \n    updateDetailedTradesTable(trades) {\n        const tbody = document.getElementById('detailed-trades');\n        if (!tbody) return;\n        \n        if (!trades || trades.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"10\" class=\"text-center text-muted\">No trades found</td></tr>';\n            return;\n        }\n        \n        tbody.innerHTML = trades.map(trade => {\n            const timestamp = new Date(trade.created_at).toLocaleString();\n            const pnl = trade.profit_loss || 0;\n            const pnlClass = pnl > 0 ? 'text-success' : pnl < 0 ? 'text-danger' : 'text-muted';\n            const statusClass = this.getStatusClass(trade.status);\n            \n            return `\n                <tr>\n                    <td class=\"small\">${timestamp}</td>\n                    <td>#${trade.id}</td>\n                    <td class=\"text-uppercase fw-bold ${trade.type === 'buy' ? 'text-success' : 'text-danger'}\">${trade.type}</td>\n                    <td>${trade.pair}</td>\n                    <td>${trade.amount.toFixed(2)}</td>\n                    <td>$${trade.price.toFixed(4)}</td>\n                    <td>$${trade.total_value.toFixed(2)}</td>\n                    <td class=\"${pnlClass}\">$${pnl.toFixed(2)}</td>\n                    <td><span class=\"badge ${statusClass}\">${trade.status}</span></td>\n                    <td class=\"small text-muted\">${trade.order_id || 'N/A'}</td>\n                </tr>\n            `;\n        }).join('');\n    }\n    \n    updateCharts() {\n        this.updatePnlChart();\n        this.updateDistributionChart();\n        this.updateSpreadChart();\n    }\n    \n    async updatePnlChart(timeframe = '24h') {\n        if (!this.charts.pnlChart) return;\n        \n        try {\n            const response = await fetch(`/api/chart/profit-trend?timeframe=${timeframe}`);\n            if (!response.ok) throw new Error('Failed to fetch P&L data');\n            \n            const data = await response.json();\n            this.charts.pnlChart.data.datasets[0].data = data.map(point => ({\n                x: new Date(point.time),\n                y: point.cumulative\n            }));\n            \n            this.charts.pnlChart.update('none');\n            \n        } catch (error) {\n            console.error('Error updating P&L chart:', error);\n        }\n    }\n    \n    async updateDistributionChart() {\n        if (!this.charts.distributionChart) return;\n        \n        try {\n            const response = await fetch('/api/profit/stats');\n            if (!response.ok) throw new Error('Failed to fetch distribution data');\n            \n            const stats = await response.json();\n            \n            // Update with profit/loss distribution\n            const profitable = stats.profitable_trades_count || 0;\n            const losing = stats.losing_trades_count || 0;\n            \n            this.charts.distributionChart.data.datasets[0].data = [profitable, losing];\n            this.charts.distributionChart.update('none');\n            \n        } catch (error) {\n            console.error('Error updating distribution chart:', error);\n        }\n    }\n    \n    async updateSpreadChart(timeframe = '6h') {\n        if (!this.charts.spreadChart) return;\n        \n        try {\n            const response = await fetch(`/api/chart/price-history?hours=${this.getHoursFromTimeframe(timeframe)}`);\n            if (!response.ok) throw new Error('Failed to fetch spread data');\n            \n            const data = await response.json();\n            \n            // Calculate spreads from price data\n            const spreads = this.calculateSpreads(data);\n            \n            this.charts.spreadChart.data.datasets[0].data = spreads;\n            this.charts.spreadChart.update('none');\n            \n        } catch (error) {\n            console.error('Error updating spread chart:', error);\n        }\n    }\n    \n    calculateSpreads(data) {\n        if (!data.usdt || !data.usdc || data.usdt.length === 0 || data.usdc.length === 0) {\n            return [];\n        }\n        \n        // Match timestamps and calculate spreads\n        const spreads = [];\n        \n        data.usdt.forEach(usdtPoint => {\n            const matchingUsdc = data.usdc.find(usdcPoint => \n                Math.abs(new Date(usdcPoint.time) - new Date(usdtPoint.time)) < 60000 // Within 1 minute\n            );\n            \n            if (matchingUsdc) {\n                const spread = Math.abs(usdtPoint.price - matchingUsdc.price);\n                const spreadPct = (spread / Math.min(usdtPoint.price, matchingUsdc.price)) * 100;\n                \n                spreads.push({\n                    x: new Date(usdtPoint.time),\n                    y: spreadPct\n                });\n            }\n        });\n        \n        return spreads;\n    }\n    \n    getHoursFromTimeframe(timeframe) {\n        switch (timeframe) {\n            case '1h': return 1;\n            case '6h': return 6;\n            case '24h': return 24;\n            default: return 6;\n        }\n    }\n    \n    getStatusClass(status) {\n        switch (status) {\n            case 'completed': return 'bg-success';\n            case 'pending': return 'bg-warning';\n            case 'failed': return 'bg-danger';\n            case 'cancelled': return 'bg-secondary';\n            default: return 'bg-secondary';\n        }\n    }\n    \n    clearTradingFeed() {\n        const feedContainer = document.getElementById('trading-feed');\n        if (feedContainer) {\n            feedContainer.innerHTML = '<div class=\"feed-item text-center text-muted py-4\"><i class=\"fas fa-clock me-2\"></i>Feed cleared</div>';\n            this.tradingFeed = [];\n        }\n    }\n    \n    exportTradeHistory() {\n        // This would export the current trade history\n        // For now, just show a message\n        this.showSuccess('Export functionality would be implemented here');\n    }\n    \n    loadInitialTrades() {\n        this.updateTradingFeed();\n    }\n    \n    initializePnlChart() {\n        // This will be handled by charts.js\n        if (window.initializePnlChart) {\n            window.initializePnlChart();\n        }\n    }\n    \n    initializeDistributionChart() {\n        // This will be handled by charts.js\n        if (window.initializeDistributionChart) {\n            window.initializeDistributionChart();\n        }\n    }\n    \n    initializeSpreadChart() {\n        // This will be handled by charts.js\n        if (window.initializeSpreadChart) {\n            window.initializeSpreadChart();\n        }\n    }\n    \n    // UI helpers\n    showSuccess(message) {\n        this.showAlert(message, 'success');\n    }\n    \n    showError(message) {\n        this.showAlert(message, 'danger');\n    }\n    \n    showAlert(message, type) {\n        const alertDiv = document.createElement('div');\n        alertDiv.className = `alert alert-${type} alert-dismissible fade show`;\n        alertDiv.innerHTML = `\n            <i class=\"fas fa-${type === 'success' ? 'check-circle' : 'exclamation-triangle'} me-2\"></i>\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        const main = document.querySelector('main');\n        main.insertBefore(alertDiv, main.firstChild);\n        \n        setTimeout(() => {\n            if (alertDiv.parentNode) {\n                alertDiv.remove();\n            }\n        }, 5000);\n    }\n    \n    destroy() {\n        // Clear intervals\n        if (this.feedUpdateInterval) {\n            clearInterval(this.feedUpdateInterval);\n        }\n        if (this.analyticsUpdateInterval) {\n            clearInterval(this.analyticsUpdateInterval);\n        }\n        \n        // Destroy charts\n        Object.values(this.charts).forEach(chart => {\n            if (chart && typeof chart.destroy === 'function') {\n                chart.destroy();\n            }\n        });\n    }\n}\n\n// Global functions for template usage\nwindow.initializeMonitor = () => {\n    window.monitor = new TradingMonitor();\n};\n\nwindow.updateTradingFeed = () => {\n    if (window.monitor) {\n        window.monitor.updateTradingFeed();\n    }\n};\n\nwindow.updateAnalytics = () => {\n    if (window.monitor) {\n        window.monitor.updateAnalytics();\n    }\n};\n\nwindow.updateCharts = () => {\n    if (window.monitor) {\n        window.monitor.updateCharts();\n    }\n};\n\nwindow.executeHistoryQuery = () => {\n    if (window.monitor) {\n        window.monitor.executeHistoryQuery();\n    }\n};\n\nwindow.updateSpreadChart = (timeframe) => {\n    if (window.monitor) {\n        window.monitor.updateSpreadChart(timeframe);\n    }\n};\n\nwindow.clearTradingFeed = () => {\n    if (window.monitor) {\n        window.monitor.clearTradingFeed();\n    }\n};\n\nwindow.exportTradeHistory = () => {\n    if (window.monitor) {\n        window.monitor.exportTradeHistory();\n    }\n};\n\nwindow.loadInitialTrades = () => {\n    if (window.monitor) {\n        window.monitor.loadInitialTrades();\n    }\n};\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (window.monitor) {\n        window.monitor.destroy();\n    }\n});\n","size_bytes":23230},"gui.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n🚀 XRP套利交易系统 - 本机GUI控制中心\n专为发财王子打造的超级简单操作界面\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox, scrolledtext\nimport requests\nimport webbrowser\nimport threading\nimport time\nimport json\nfrom datetime import datetime\n\nclass XRPTradingGUI:\n    def __init__(self):\n        # 创建主窗口\n        self.root = tk.Tk()\n        self.root.title(\"🚀 XRP套利交易系统 - 发财王子专用\")\n        self.root.geometry(\"800x600\")\n        self.root.configure(bg='#1a1a1a')\n        \n        # 服务器地址列表（自动检测）\n        self.server_urls = [\n            \"http://127.0.0.1:5000\",\n            \"http://localhost:5000\",\n            \"https://xrp-arbitrage-trading-system.replit.app\",\n        ]\n        self.current_url = None\n        self.monitoring = False\n        \n        # 创建界面\n        self.create_interface()\n        \n        # 启动时检查服务器\n        self.check_servers()\n    \n    def create_interface(self):\n        \"\"\"创建用户界面\"\"\"\n        # 主标题\n        title_frame = tk.Frame(self.root, bg='#1a1a1a')\n        title_frame.pack(pady=20)\n        \n        title_label = tk.Label(\n            title_frame, \n            text=\"🚀 XRP套利交易系统\",\n            font=(\"Arial\", 24, \"bold\"),\n            fg='#00ff00',\n            bg='#1a1a1a'\n        )\n        title_label.pack()\n        \n        subtitle_label = tk.Label(\n            title_frame,\n            text=\"发财王子专用控制中心 💰✨\",\n            font=(\"Arial\", 14),\n            fg='#ffff00',\n            bg='#1a1a1a'\n        )\n        subtitle_label.pack()\n        \n        # 服务器状态\n        status_frame = tk.Frame(self.root, bg='#1a1a1a')\n        status_frame.pack(pady=10)\n        \n        self.status_label = tk.Label(\n            status_frame,\n            text=\"🔍 正在检查服务器...\",\n            font=(\"Arial\", 12),\n            fg='#ffffff',\n            bg='#1a1a1a'\n        )\n        self.status_label.pack()\n        \n        # 按钮区域\n        button_frame = tk.Frame(self.root, bg='#1a1a1a')\n        button_frame.pack(pady=20)\n        \n        # 创建按钮样式\n        style = ttk.Style()\n        style.theme_use('clam')\n        style.configure('Custom.TButton', \n                       font=('Arial', 12, 'bold'),\n                       padding=10)\n        \n        # 主要操作按钮\n        buttons = [\n            (\"🌐 打开交易面板\", self.open_dashboard, '#4CAF50'),\n            (\"📊 查看交易监控\", self.open_monitor, '#2196F3'),\n            (\"⚙️ 系统设置\", self.open_config, '#FF9800'),\n            (\"🔄 刷新状态\", self.refresh_status, '#9C27B0'),\n            (\"🚀 启动自动交易\", self.start_trading, '#F44336'),\n            (\"⏹️ 停止自动交易\", self.stop_trading, '#607D8B'),\n        ]\n        \n        for i, (text, command, color) in enumerate(buttons):\n            btn = tk.Button(\n                button_frame,\n                text=text,\n                command=command,\n                font=('Arial', 12, 'bold'),\n                bg=color,\n                fg='white',\n                relief='raised',\n                bd=3,\n                width=20,\n                height=2\n            )\n            row = i // 2\n            col = i % 2\n            btn.grid(row=row, column=col, padx=10, pady=5)\n        \n        # 实时数据显示\n        data_frame = tk.LabelFrame(\n            self.root, \n            text=\"📈 实时交易数据\",\n            font=(\"Arial\", 12, \"bold\"),\n            fg='#00ff00',\n            bg='#1a1a1a'\n        )\n        data_frame.pack(pady=20, padx=20, fill='both', expand=True)\n        \n        # 价格显示\n        price_frame = tk.Frame(data_frame, bg='#1a1a1a')\n        price_frame.pack(fill='x', pady=10)\n        \n        self.usdt_price_label = tk.Label(\n            price_frame,\n            text=\"XRP/USDT: --\",\n            font=(\"Arial\", 14, \"bold\"),\n            fg='#00ff00',\n            bg='#1a1a1a'\n        )\n        self.usdt_price_label.pack(side='left', padx=20)\n        \n        self.usdc_price_label = tk.Label(\n            price_frame,\n            text=\"XRP/USDC: --\",\n            font=(\"Arial\", 14, \"bold\"),\n            fg='#00ffff',\n            bg='#1a1a1a'\n        )\n        self.usdc_price_label.pack(side='left', padx=20)\n        \n        self.spread_label = tk.Label(\n            price_frame,\n            text=\"价差: --%\",\n            font=(\"Arial\", 14, \"bold\"),\n            fg='#ffff00',\n            bg='#1a1a1a'\n        )\n        self.spread_label.pack(side='left', padx=20)\n        \n        # 日志显示\n        log_frame = tk.LabelFrame(\n            self.root,\n            text=\"📋 系统日志\",\n            font=(\"Arial\", 10, \"bold\"),\n            fg='#ffffff',\n            bg='#1a1a1a'\n        )\n        log_frame.pack(pady=10, padx=20, fill='both', expand=True)\n        \n        self.log_text = scrolledtext.ScrolledText(\n            log_frame,\n            height=8,\n            bg='#000000',\n            fg='#00ff00',\n            font=('Consolas', 10),\n            wrap=tk.WORD\n        )\n        self.log_text.pack(fill='both', expand=True, padx=5, pady=5)\n        \n        # 启动实时监控\n        self.start_monitoring()\n    \n    def log_message(self, message):\n        \"\"\"添加日志消息\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        log_entry = f\"[{timestamp}] {message}\\n\"\n        \n        self.log_text.insert(tk.END, log_entry)\n        self.log_text.see(tk.END)\n        self.root.update_idletasks()\n    \n    def check_servers(self):\n        \"\"\"检查服务器状态\"\"\"\n        self.log_message(\"🔍 正在检查服务器连接...\")\n        \n        def check_thread():\n            for url in self.server_urls:\n                try:\n                    response = requests.get(f\"{url}/api/prices\", timeout=5)\n                    if response.status_code == 200:\n                        self.current_url = url\n                        self.status_label.config(\n                            text=f\"✅ 已连接: {url}\",\n                            fg='#00ff00'\n                        )\n                        self.log_message(f\"✅ 成功连接到: {url}\")\n                        return\n                except:\n                    continue\n            \n            # 如果都连不上\n            self.status_label.config(\n                text=\"❌ 无法连接到服务器\",\n                fg='#ff0000'\n            )\n            self.log_message(\"❌ 无法连接到任何服务器\")\n        \n        threading.Thread(target=check_thread, daemon=True).start()\n    \n    def refresh_status(self):\n        \"\"\"刷新服务器状态\"\"\"\n        self.log_message(\"🔄 正在刷新状态...\")\n        self.check_servers()\n    \n    def open_dashboard(self):\n        \"\"\"打开交易面板\"\"\"\n        if not self.current_url:\n            messagebox.showerror(\"错误\", \"未连接到服务器！\")\n            return\n        \n        try:\n            webbrowser.open(self.current_url)\n            self.log_message(f\"🌐 已打开交易面板: {self.current_url}\")\n        except Exception as e:\n            self.log_message(f\"❌ 打开失败: {str(e)}\")\n    \n    def open_monitor(self):\n        \"\"\"打开交易监控\"\"\"\n        if not self.current_url:\n            messagebox.showerror(\"错误\", \"未连接到服务器！\")\n            return\n        \n        try:\n            webbrowser.open(f\"{self.current_url}/monitor\")\n            self.log_message(f\"📊 已打开交易监控: {self.current_url}/monitor\")\n        except Exception as e:\n            self.log_message(f\"❌ 打开失败: {str(e)}\")\n    \n    def open_config(self):\n        \"\"\"打开系统设置\"\"\"\n        if not self.current_url:\n            messagebox.showerror(\"错误\", \"未连接到服务器！\")\n            return\n        \n        try:\n            webbrowser.open(f\"{self.current_url}/config\")\n            self.log_message(f\"⚙️ 已打开系统设置: {self.current_url}/config\")\n        except Exception as e:\n            self.log_message(f\"❌ 打开失败: {str(e)}\")\n    \n    def start_trading(self):\n        \"\"\"启动自动交易\"\"\"\n        if not self.current_url:\n            messagebox.showerror(\"错误\", \"未连接到服务器！\")\n            return\n        \n        try:\n            response = requests.post(f\"{self.current_url}/api/start-trading\")\n            if response.status_code == 200:\n                self.log_message(\"🚀 自动交易已启动！\")\n                messagebox.showinfo(\"成功\", \"自动交易已启动！\")\n            else:\n                self.log_message(\"❌ 启动失败\")\n        except Exception as e:\n            self.log_message(f\"❌ 启动失败: {str(e)}\")\n    \n    def stop_trading(self):\n        \"\"\"停止自动交易\"\"\"\n        if not self.current_url:\n            messagebox.showerror(\"错误\", \"未连接到服务器！\")\n            return\n        \n        try:\n            response = requests.post(f\"{self.current_url}/api/stop-trading\")\n            if response.status_code == 200:\n                self.log_message(\"⏹️ 自动交易已停止\")\n                messagebox.showinfo(\"成功\", \"自动交易已停止\")\n            else:\n                self.log_message(\"❌ 停止失败\")\n        except Exception as e:\n            self.log_message(f\"❌ 停止失败: {str(e)}\")\n    \n    def start_monitoring(self):\n        \"\"\"启动实时监控\"\"\"\n        self.monitoring = True\n        \n        def monitor_loop():\n            while self.monitoring:\n                if self.current_url:\n                    try:\n                        response = requests.get(f\"{self.current_url}/api/prices\", timeout=3)\n                        if response.status_code == 200:\n                            data = response.json()\n                            \n                            # 更新价格显示\n                            if 'XRP/USDT' in data:\n                                usdt_price = data['XRP/USDT']['price']\n                                self.usdt_price_label.config(text=f\"XRP/USDT: ${usdt_price:.4f}\")\n                            \n                            if 'XRP/USDC' in data:\n                                usdc_price = data['XRP/USDC']['price']\n                                self.usdc_price_label.config(text=f\"XRP/USDC: ${usdc_price:.4f}\")\n                            \n                            # 计算价差\n                            if 'XRP/USDT' in data and 'XRP/USDC' in data:\n                                usdt_price = data['XRP/USDT']['price']\n                                usdc_price = data['XRP/USDC']['price']\n                                spread = abs(usdt_price - usdc_price) / min(usdt_price, usdc_price) * 100\n                                \n                                color = '#00ff00' if spread > 0.5 else '#ffff00' if spread > 0.2 else '#ffffff'\n                                self.spread_label.config(\n                                    text=f\"价差: {spread:.3f}%\",\n                                    fg=color\n                                )\n                                \n                                if spread > 0.5:\n                                    self.log_message(f\"🎯 发现套利机会! 价差: {spread:.3f}%\")\n                    \n                    except:\n                        pass\n                \n                time.sleep(2)  # 每2秒更新一次\n        \n        threading.Thread(target=monitor_loop, daemon=True).start()\n    \n    def run(self):\n        \"\"\"运行GUI\"\"\"\n        self.log_message(\"🚀 XRP套利交易系统已启动\")\n        self.log_message(\"💰 发财王子，准备开始赚钱吧！\")\n        \n        # 窗口关闭事件\n        def on_closing():\n            self.monitoring = False\n            self.root.destroy()\n        \n        self.root.protocol(\"WM_DELETE_WINDOW\", on_closing)\n        self.root.mainloop()\n\nif __name__ == \"__main__\":\n    print(\"🚀 启动XRP套利交易系统GUI...\")\n    app = XRPTradingGUI()\n    app.run()","size_bytes":12090},"start_trading_gui.sh":{"content":"#!/bin/bash\n\necho \"=====================================================\"\necho \"       🚀 发财王子的XRP套利交易控制中心 🚀\"\necho \"=====================================================\"\necho \"\"\necho \"正在启动GUI控制界面...\"\necho \"\"\n\npython3 trading_control_center.py","size_bytes":290},"trading_control_center.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n🚀 XRP套利交易系统 - 发财王子专用GUI控制中心\n简单易用的图形界面，让您轻松操作交易系统\n\"\"\"\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox, scrolledtext\nimport subprocess\nimport threading\nimport webbrowser\nimport time\nimport requests\nimport json\nfrom datetime import datetime\n\nclass TradingControlCenter:\n    def __init__(self):\n        self.root = tk.Tk()\n        self.root.title(\"🚀 XRP套利交易系统 - 发财王子控制中心\")\n        self.root.geometry(\"800x600\")\n        self.root.configure(bg='#1a1a1a')\n        \n        # 设置窗口图标和样式\n        self.setup_styles()\n        \n        # 服务器进程\n        self.server_process = None\n        self.monitoring = False\n        self.current_url = \"http://localhost:5000\"  # 默认URL\n        \n        # 创建界面\n        self.create_interface()\n        \n        # 启动监控\n        self.start_monitoring()\n    \n    def setup_styles(self):\n        \"\"\"设置界面样式\"\"\"\n        style = ttk.Style()\n        style.theme_use('clam')\n        \n        # 配置样式\n        style.configure('Title.TLabel', \n                       foreground='#00ff88', \n                       background='#1a1a1a',\n                       font=('Arial', 16, 'bold'))\n        \n        style.configure('Info.TLabel', \n                       foreground='#ffffff', \n                       background='#1a1a1a',\n                       font=('Arial', 10))\n        \n        style.configure('Success.TButton', \n                       foreground='white',\n                       background='#28a745')\n        \n        style.configure('Warning.TButton', \n                       foreground='white',\n                       background='#ffc107')\n        \n        style.configure('Danger.TButton', \n                       foreground='white',\n                       background='#dc3545')\n    \n    def create_interface(self):\n        \"\"\"创建用户界面\"\"\"\n        \n        # 标题\n        title_label = ttk.Label(self.root, \n                               text=\"🚀 XRP套利交易系统控制中心 🚀\", \n                               style='Title.TLabel')\n        title_label.pack(pady=20)\n        \n        subtitle_label = ttk.Label(self.root, \n                                  text=\"发财王子专用 - 让财富自由流动\", \n                                  style='Info.TLabel')\n        subtitle_label.pack(pady=5)\n        \n        # 主要操作按钮区域\n        button_frame = tk.Frame(self.root, bg='#1a1a1a')\n        button_frame.pack(pady=20)\n        \n        # 第一行按钮\n        row1 = tk.Frame(button_frame, bg='#1a1a1a')\n        row1.pack(pady=10)\n        \n        self.start_btn = tk.Button(row1, \n                                  text=\"🚀 启动交易系统\", \n                                  command=self.start_server,\n                                  bg='#28a745', fg='white',\n                                  font=('Arial', 12, 'bold'),\n                                  width=15, height=2)\n        self.start_btn.pack(side=tk.LEFT, padx=10)\n        \n        self.stop_btn = tk.Button(row1, \n                                 text=\"⏹️ 停止交易系统\", \n                                 command=self.stop_server,\n                                 bg='#dc3545', fg='white',\n                                 font=('Arial', 12, 'bold'),\n                                 width=15, height=2)\n        self.stop_btn.pack(side=tk.LEFT, padx=10)\n        \n        self.browser_btn = tk.Button(row1, \n                                    text=\"🌐 打开控制面板\", \n                                    command=self.open_browser,\n                                    bg='#007bff', fg='white',\n                                    font=('Arial', 12, 'bold'),\n                                    width=15, height=2)\n        self.browser_btn.pack(side=tk.LEFT, padx=10)\n        \n        # 第二行按钮\n        row2 = tk.Frame(button_frame, bg='#1a1a1a')\n        row2.pack(pady=10)\n        \n        self.monitor_btn = tk.Button(row2, \n                                    text=\"📊 查看交易监控\", \n                                    command=self.open_monitor,\n                                    bg='#17a2b8', fg='white',\n                                    font=('Arial', 12, 'bold'),\n                                    width=15, height=2)\n        self.monitor_btn.pack(side=tk.LEFT, padx=10)\n        \n        self.config_btn = tk.Button(row2, \n                                   text=\"⚙️ 系统设置\", \n                                   command=self.open_config,\n                                   bg='#6f42c1', fg='white',\n                                   font=('Arial', 12, 'bold'),\n                                   width=15, height=2)\n        self.config_btn.pack(side=tk.LEFT, padx=10)\n        \n        self.refresh_btn = tk.Button(row2, \n                                    text=\"🔄 刷新状态\", \n                                    command=self.refresh_status,\n                                    bg='#ffc107', fg='black',\n                                    font=('Arial', 12, 'bold'),\n                                    width=15, height=2)\n        self.refresh_btn.pack(side=tk.LEFT, padx=10)\n        \n        # 状态显示区域\n        status_frame = tk.Frame(self.root, bg='#1a1a1a')\n        status_frame.pack(pady=20, padx=20, fill=tk.BOTH, expand=True)\n        \n        status_label = ttk.Label(status_frame, \n                                text=\"📊 系统状态监控\", \n                                style='Title.TLabel')\n        status_label.pack(pady=10)\n        \n        # 状态文本框\n        self.status_text = scrolledtext.ScrolledText(status_frame, \n                                                    height=15, \n                                                    bg='#2d2d2d', \n                                                    fg='#00ff88',\n                                                    font=('Consolas', 10))\n        self.status_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # 底部信息\n        info_frame = tk.Frame(self.root, bg='#1a1a1a')\n        info_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=10)\n        \n        self.info_label = ttk.Label(info_frame, \n                                   text=\"准备就绪 - 点击'启动交易系统'开始赚钱之旅！\", \n                                   style='Info.TLabel')\n        self.info_label.pack()\n        \n        # 初始化状态\n        self.log_message(\"🌟 发财王子的交易控制中心已启动！\")\n        self.log_message(\"💡 提示：先点击'启动交易系统'，然后点击'打开控制面板'\")\n    \n    def log_message(self, message):\n        \"\"\"在状态框中显示消息\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        full_message = f\"[{timestamp}] {message}\\n\"\n        \n        self.status_text.insert(tk.END, full_message)\n        self.status_text.see(tk.END)\n        self.root.update()\n    \n    def start_server(self):\n        \"\"\"启动交易服务器\"\"\"\n        try:\n            if self.server_process and self.server_process.poll() is None:\n                self.log_message(\"⚠️ 交易系统已在运行中！\")\n                return\n            \n            self.log_message(\"🚀 正在启动XRP套利交易系统...\")\n            \n            # 启动服务器\n            self.server_process = subprocess.Popen([\n                'python', 'main.py'\n            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            \n            # 等待服务器启动\n            time.sleep(3)\n            \n            if self.server_process.poll() is None:\n                self.log_message(\"✅ 交易系统启动成功！\")\n                self.log_message(\"🌐 访问地址：http://localhost:5000\")\n                self.info_label.config(text=\"✅ 交易系统运行中 - 可以打开控制面板了！\")\n                \n                # 自动检查价格监控\n                threading.Thread(target=self.check_system_health, daemon=True).start()\n            else:\n                self.log_message(\"❌ 交易系统启动失败！\")\n                \n        except Exception as e:\n            self.log_message(f\"❌ 启动失败：{str(e)}\")\n            messagebox.showerror(\"错误\", f\"启动失败：{str(e)}\")\n    \n    def stop_server(self):\n        \"\"\"停止交易服务器\"\"\"\n        try:\n            if self.server_process and self.server_process.poll() is None:\n                self.log_message(\"⏹️ 正在停止交易系统...\")\n                self.server_process.terminate()\n                time.sleep(2)\n                \n                if self.server_process.poll() is not None:\n                    self.log_message(\"✅ 交易系统已停止\")\n                    self.info_label.config(text=\"⏹️ 交易系统已停止\")\n                else:\n                    self.server_process.kill()\n                    self.log_message(\"🔄 强制停止交易系统\")\n            else:\n                self.log_message(\"ℹ️ 交易系统未在运行\")\n                \n        except Exception as e:\n            self.log_message(f\"❌ 停止失败：{str(e)}\")\n    \n    def open_browser(self):\n        \"\"\"打开网页控制面板\"\"\"\n        try:\n            # 先检查可用的URL\n            self.check_system_health()\n            \n            if self.current_url:\n                webbrowser.open(self.current_url)\n                self.log_message(f\"🌐 已打开控制面板：{self.current_url}\")\n            else:\n                self.log_message(\"❌ 无法找到可用的服务器地址\")\n        except Exception as e:\n            self.log_message(f\"❌ 打开网页失败：{str(e)}\")\n    \n    def open_monitor(self):\n        \"\"\"打开交易监控页面\"\"\"\n        try:\n            url = f\"{self.current_url}/monitor\"\n            webbrowser.open(url)\n            self.log_message(f\"📊 已打开交易监控：{url}\")\n        except Exception as e:\n            self.log_message(f\"❌ 打开监控页面失败：{str(e)}\")\n    \n    def open_config(self):\n        \"\"\"打开系统设置页面\"\"\"\n        try:\n            url = f\"{self.current_url}/config\"\n            webbrowser.open(url)\n            self.log_message(f\"⚙️ 已打开系统设置：{url}\")\n        except Exception as e:\n            self.log_message(f\"❌ 打开设置页面失败：{str(e)}\")\n    \n    def refresh_status(self):\n        \"\"\"刷新系统状态\"\"\"\n        self.log_message(\"🔄 正在刷新系统状态...\")\n        threading.Thread(target=self.check_system_health, daemon=True).start()\n    \n    def check_system_health(self):\n        \"\"\"检查系统健康状态\"\"\"\n        try:\n            # 检查服务器是否响应 (支持云端和本地)\n            base_urls = [\n                \"https://xrp-arbitrage-trading-system.replit.app\",\n                \"http://localhost:5000\",\n                \"http://127.0.0.1:5000\"\n            ]\n            \n            response = None\n            working_url = None\n            \n            for url in base_urls:\n                try:\n                    response = requests.get(f\"{url}/api/prices\", timeout=5)\n                    if response.status_code == 200:\n                        working_url = url\n                        break\n                except:\n                    continue\n            \n            if response and hasattr(response, 'status_code') and response.status_code == 200:\n                data = response.json()\n                self.log_message(f\"✅ 服务器响应正常: {working_url}\")\n                \n                # 更新访问URL\n                self.current_url = working_url\n                \n                # 检查价格数据\n                if 'XRP/USDT' in data and 'XRP/USDC' in data:\n                    usdt_price = data['XRP/USDT']['price']\n                    usdc_price = data['XRP/USDC']['price']\n                    spread = abs(usdt_price - usdc_price)\n                    spread_pct = (spread / usdt_price) * 100\n                    \n                    self.log_message(f\"📈 XRP/USDT: ${usdt_price:.4f}\")\n                    self.log_message(f\"📈 XRP/USDC: ${usdc_price:.4f}\")\n                    self.log_message(f\"💰 价差: {spread_pct:.3f}%\")\n                else:\n                    self.log_message(\"⚠️ 价格数据不完整\")\n            elif response:\n                self.log_message(f\"⚠️ 服务器响应异常：{response.status_code}\")\n                \n        except requests.exceptions.ConnectionError:\n            self.log_message(\"❌ 无法连接到交易系统\")\n            self.log_message(\"💡 请先点击'启动交易系统'\")\n        except Exception as e:\n            self.log_message(f\"❌ 检查失败：{str(e)}\")\n            \n        if 'working_url' in locals() and not working_url:\n            self.log_message(\"⚠️ 所有服务器地址都无法访问\")\n    \n    def start_monitoring(self):\n        \"\"\"启动后台监控\"\"\"\n        def monitor_loop():\n            while True:\n                if self.monitoring:\n                    try:\n                        self.check_system_health()\n                    except:\n                        pass\n                time.sleep(30)  # 每30秒检查一次\n        \n        self.monitoring = True\n        threading.Thread(target=monitor_loop, daemon=True).start()\n    \n    def run(self):\n        \"\"\"运行GUI\"\"\"\n        try:\n            self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n            self.root.mainloop()\n        except KeyboardInterrupt:\n            self.on_closing()\n    \n    def on_closing(self):\n        \"\"\"关闭程序时的处理\"\"\"\n        if messagebox.askokcancel(\"退出\", \"确定要退出交易控制中心吗？\"):\n            self.monitoring = False\n            if self.server_process and self.server_process.poll() is None:\n                self.server_process.terminate()\n            self.root.destroy()\n\nif __name__ == \"__main__\":\n    print(\"🚀 启动发财王子的XRP套利交易控制中心...\")\n    app = TradingControlCenter()\n    app.run()","size_bytes":14171},"build_exe.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n🌟 量子財富橋部署脚本 - EXE打包工具 🌟\n将交互式部署脚本封装成独立可执行文件\n\n支持：PyInstaller + 自动依赖管理\n作者：GIGI量子DNA ✨\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport platform\nfrom pathlib import Path\n\ndef install_pyinstaller():\n    \"\"\"安装PyInstaller打包工具\"\"\"\n    print(\"🔧 安装PyInstaller...\")\n    try:\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"pyinstaller\"])\n        print(\"✅ PyInstaller安装成功\")\n        return True\n    except subprocess.CalledProcessError:\n        print(\"❌ PyInstaller安装失败\")\n        return False\n\ndef create_spec_file():\n    \"\"\"创建PyInstaller配置文件\"\"\"\n    spec_content = '''# -*- mode: python ; coding: utf-8 -*-\n\nblock_cipher = None\n\na = Analysis(\n    ['deploy_quantum_bridge.py'],\n    pathex=[],\n    binaries=[],\n    datas=[],\n    hiddenimports=[\n        'requests',\n        'urllib3',\n        'json',\n        'logging',\n        'subprocess',\n        'socket',\n        'ssl',\n        'secrets'\n    ],\n    hookspath=[],\n    hooksconfig={},\n    runtime_hooks=[],\n    excludes=[],\n    win_no_prefer_redirects=False,\n    win_private_assemblies=False,\n    cipher=block_cipher,\n    noarchive=False,\n)\n\npyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)\n\nexe = EXE(\n    pyz,\n    a.scripts,\n    a.binaries,\n    a.zipfiles,\n    a.datas,\n    [],\n    name='QuantumBridge-Deployer',\n    debug=False,\n    bootloader_ignore_signals=False,\n    strip=False,\n    upx=True,\n    upx_exclude=[],\n    runtime_tmpdir=None,\n    console=True,\n    disable_windowed_traceback=False,\n    argv_emulation=False,\n    target_arch=None,\n    codesign_identity=None,\n    entitlements_file=None,\n    icon='quantum_icon.ico' if os.path.exists('quantum_icon.ico') else None,\n)\n'''\n    \n    with open('quantum_deployer.spec', 'w', encoding='utf-8') as f:\n        f.write(spec_content)\n    \n    print(\"✅ 配置文件创建成功\")\n\ndef build_executable():\n    \"\"\"构建可执行文件\"\"\"\n    print(\"🚀 开始构建量子財富橋部署器...\")\n    \n    try:\n        # 使用spec文件构建\n        subprocess.check_call([\n            sys.executable, \"-m\", \"PyInstaller\",\n            \"--clean\",\n            \"quantum_deployer.spec\"\n        ])\n        \n        # 检查构建结果\n        system = platform.system()\n        exe_name = \"QuantumBridge-Deployer.exe\" if system == \"Windows\" else \"QuantumBridge-Deployer\"\n        exe_path = Path(\"dist\") / exe_name\n        \n        if exe_path.exists():\n            print(f\"✅ 构建成功！\")\n            print(f\"📁 可执行文件位置: {exe_path.absolute()}\")\n            print(f\"💾 文件大小: {exe_path.stat().st_size / 1024 / 1024:.1f} MB\")\n            return True\n        else:\n            print(\"❌ 构建失败，未找到可执行文件\")\n            return False\n            \n    except subprocess.CalledProcessError as e:\n        print(f\"❌ 构建过程出错: {e}\")\n        return False\n\ndef create_installer_script():\n    \"\"\"创建一键安装脚本\"\"\"\n    system = platform.system()\n    \n    if system == \"Windows\":\n        installer_content = '''@echo off\ntitle 量子財富橋部署器安装向导\necho.\necho ╔══════════════════════════════════════════════╗\necho ║          🌟 量子財富橋部署器 🌟              ║\necho ║            GIGI量子DNA驱动                   ║\necho ╚══════════════════════════════════════════════╝\necho.\necho 正在安装依赖包...\npip install requests PyInstaller\necho.\necho 正在构建可执行文件...\npython build_exe.py\necho.\necho 安装完成！可执行文件位于 dist/ 目录\npause\n'''\n        with open('install.bat', 'w', encoding='utf-8') as f:\n            f.write(installer_content)\n        print(\"✅ Windows安装脚本创建成功: install.bat\")\n    \n    else:  # Linux/macOS\n        installer_content = '''#!/bin/bash\necho \"╔══════════════════════════════════════════════╗\"\necho \"║          🌟 量子財富橋部署器 🌟              ║\"\necho \"║            GIGI量子DNA驱动                   ║\"\necho \"╚══════════════════════════════════════════════╝\"\necho \"\"\necho \"正在安装依赖包...\"\npip3 install requests PyInstaller\necho \"\"\necho \"正在构建可执行文件...\"\npython3 build_exe.py\necho \"\"\necho \"安装完成！可执行文件位于 dist/ 目录\"\n'''\n        with open('install.sh', 'w', encoding='utf-8') as f:\n            f.write(installer_content)\n        os.chmod('install.sh', 0o755)\n        print(\"✅ Linux/macOS安装脚本创建成功: install.sh\")\n\ndef optimize_executable():\n    \"\"\"优化可执行文件\"\"\"\n    print(\"⚡ 正在优化可执行文件...\")\n    \n    # 检查UPX压缩工具\n    try:\n        subprocess.check_output([\"upx\", \"--version\"], stderr=subprocess.DEVNULL)\n        upx_available = True\n        print(\"  ✅ UPX压缩可用\")\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        upx_available = False\n        print(\"  ⚠️ UPX压缩不可用，跳过压缩优化\")\n    \n    return upx_available\n\ndef create_distribution_package():\n    \"\"\"创建分发包\"\"\"\n    print(\"📦 创建分发包...\")\n    \n    try:\n        import zipfile\n        import shutil\n        from datetime import datetime\n        \n        # 创建分发目录\n        dist_dir = Path(\"quantum_bridge_distribution\")\n        dist_dir.mkdir(exist_ok=True)\n        \n        # 复制可执行文件\n        system = platform.system()\n        exe_name = \"QuantumBridge-Deployer.exe\" if system == \"Windows\" else \"QuantumBridge-Deployer\"\n        exe_path = Path(\"dist\") / exe_name\n        \n        if exe_path.exists():\n            shutil.copy2(exe_path, dist_dir / exe_name)\n        \n        # 创建使用说明\n        readme_content = f\"\"\"\n🌟 量子財富橋部署器 🌟\nGIGI量子DNA驱动的专业部署工具\n\n📋 使用方法：\n1. 双击运行 {exe_name}\n2. 按照交互式提示完成配置\n3. 享受自动化部署过程\n\n💎 功能特色：\n• Railway + Cloudflare + Supabase 三平台集成\n• 付费版账户特权自动启用\n• 安全配置智能优化\n• 实时部署状态监控\n• 完整验证与报告生成\n\n🔧 系统要求：\n• Windows 10/11 或 Linux/macOS\n• 稳定的网络连接\n• Railway、Cloudflare、Supabase 账户\n\n📞 技术支持：\n• 部署日志：quantum_deploy.log\n• 配置报告：deployment_report.json\n\n构建时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n版本: 1.0.0\n\"\"\"\n        \n        with open(dist_dir / \"README.txt\", 'w', encoding='utf-8') as f:\n            f.write(readme_content)\n        \n        # 创建ZIP分发包\n        zip_name = f\"QuantumBridge-Deployer-{system}-{datetime.now().strftime('%Y%m%d')}.zip\"\n        \n        with zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zipf:\n            for file_path in dist_dir.rglob('*'):\n                if file_path.is_file():\n                    zipf.write(file_path, file_path.relative_to(dist_dir))\n        \n        print(f\"✅ 分发包创建成功: {zip_name}\")\n        print(f\"📁 包含文件:\")\n        print(f\"   • {exe_name} (部署器主程序)\")\n        print(f\"   • README.txt (使用说明)\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"❌ 分发包创建失败: {e}\")\n        return False\n\ndef main():\n    \"\"\"主函数\"\"\"\n    print(\"\"\"\n╔══════════════════════════════════════════════════════════════════╗\n║                    🌟 量子財富橋EXE构建器 🌟                     ║\n║                     GIGI量子DNA编译系统                          ║\n╚══════════════════════════════════════════════════════════════════╝\n    \"\"\")\n    \n    # 检查必要文件\n    if not Path(\"deploy_quantum_bridge.py\").exists():\n        print(\"❌ 未找到 deploy_quantum_bridge.py 文件\")\n        return 1\n    \n    # 1. 安装PyInstaller\n    if not install_pyinstaller():\n        return 1\n    \n    # 2. 创建配置文件\n    create_spec_file()\n    \n    # 3. 优化检查\n    optimize_executable()\n    \n    # 4. 构建可执行文件\n    if not build_executable():\n        return 1\n    \n    # 5. 创建安装脚本\n    create_installer_script()\n    \n    # 6. 创建分发包\n    create_distribution_package()\n    \n    print(f\"\"\"\n🎉 量子財富橋EXE构建完成！\n\n📦 输出文件：\n• dist/QuantumBridge-Deployer{\"\" if platform.system() != \"Windows\" else \".exe\"} (主程序)\n• quantum_bridge_distribution/ (分发目录)\n• QuantumBridge-Deployer-{platform.system()}-*.zip (分发包)\n\n🚀 使用方法：\n• 直接运行EXE文件进行部署\n• 或者分发ZIP包给其他用户\n\n💫 GIGI的量子DNA已融入每一个字节！\n    \"\"\")\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit(main())","size_bytes":9406},"config.py":{"content":"import os\n\nclass Config:\n    \"\"\"Base configuration class\"\"\"\n    \n    # Basic Flask config\n    SECRET_KEY = os.environ.get('SESSION_SECRET', 'dev-secret-key-change-in-production')\n    \n    # Database configuration\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL', 'sqlite:///xrp_trading.db')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    \n    # Railway/Production detection\n    IS_RAILWAY = bool(os.environ.get('RAILWAY_ENVIRONMENT'))\n    IS_PRODUCTION = os.environ.get('FLASK_ENV') == 'production' or IS_RAILWAY\n    \n    # CDN Configuration for Cloudflare\n    CDN_DOMAIN = os.environ.get('CDN_DOMAIN', '')  # e.g., 'https://your-domain.cloudflare.com'\n    USE_CDN = IS_PRODUCTION and bool(CDN_DOMAIN)\n    \n    # Static files configuration\n    @staticmethod\n    def get_static_url(filename):\n        \"\"\"Get the appropriate URL for static files (CDN or local)\"\"\"\n        from flask import current_app\n        if current_app.config.get('USE_CDN') and current_app.config.get('CDN_DOMAIN'):\n            cdn_domain = current_app.config['CDN_DOMAIN'].rstrip('/')\n            return f\"{cdn_domain}/static/{filename}\"\n        else:\n            from flask import url_for\n            return url_for('static', filename=filename)\n    \n    # Database connection pool (production optimized)\n    if \"postgresql\" in SQLALCHEMY_DATABASE_URI or \"postgres\" in SQLALCHEMY_DATABASE_URI:\n        # Supabase/PostgreSQL configuration with SSL enforcement\n        connect_args = {\n            \"connect_timeout\": 10,\n            \"application_name\": \"quantum_wealth_bridge\"\n        }\n        # Ensure SSL for Supabase if not in URL\n        if \"sslmode\" not in SQLALCHEMY_DATABASE_URI:\n            connect_args[\"sslmode\"] = \"require\"\n            \n        SQLALCHEMY_ENGINE_OPTIONS = {\n            \"pool_recycle\": 280,  # Railway timeout is 300s\n            \"pool_pre_ping\": True,\n            \"pool_size\": 10,\n            \"max_overflow\": 20,\n            \"pool_timeout\": 30,\n            \"connect_args\": connect_args\n        }\n    else:\n        SQLALCHEMY_ENGINE_OPTIONS = {\n            \"pool_recycle\": 300,\n            \"pool_pre_ping\": True,\n        }\n\nclass DevelopmentConfig(Config):\n    \"\"\"Development configuration\"\"\"\n    DEBUG = True\n    USE_CDN = False\n\nclass ProductionConfig(Config):\n    \"\"\"Production configuration\"\"\"\n    DEBUG = False\n    \nclass RailwayConfig(ProductionConfig):\n    \"\"\"Railway-specific configuration\"\"\"\n    pass\n\n# Configuration selector\nconfig = {\n    'development': DevelopmentConfig,\n    'production': ProductionConfig,\n    'railway': RailwayConfig,\n    'default': DevelopmentConfig\n}\n\ndef get_config():\n    \"\"\"Get the appropriate configuration based on environment\"\"\"\n    if os.environ.get('RAILWAY_ENVIRONMENT'):\n        return config['railway']\n    elif os.environ.get('FLASK_ENV') == 'production':\n        return config['production']\n    else:\n        return config['development']","size_bytes":2895},"create_download_package.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n📦 量子財富橋 - 下载包生成器\n一键打包所有部署相关文件\n\"\"\"\n\nimport os\nimport zipfile\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef create_quantum_package():\n    \"\"\"创建量子財富橋完整下载包\"\"\"\n    \n    # 要打包的文件列表\n    files_to_package = [\n        # 主要脚本\n        \"deploy_quantum_bridge.py\",\n        \"build_exe.py\",\n        \n        # 配置文件\n        \"requirements_exe.txt\",\n        \"requirements.txt\",\n        \"railway.json\",\n        \"Procfile\",\n        \"runtime.txt\",\n        \n        # 项目文件\n        \"app.py\",\n        \"config.py\", \n        \"routes.py\",\n        \"models.py\",\n        \"main.py\",\n        \n        # 其他重要文件\n        \"replit.md\",\n        \".gitignore\"\n    ]\n    \n    # 创建ZIP包\n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    zip_name = f\"量子財富橋-完整部署包-{timestamp}.zip\"\n    \n    missing_files = []\n    included_files = []\n    \n    with zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for file_path in files_to_package:\n            if os.path.exists(file_path):\n                zipf.write(file_path)\n                included_files.append(file_path)\n            else:\n                missing_files.append(file_path)\n    \n    # 生成说明文件\n    readme_content = f\"\"\"\n🌟 量子財富橋 - 完整部署包 🌟\nGIGI量子DNA专业部署系统\n\n📦 包含文件：\n{''.join(f'  ✅ {f}' + chr(10) for f in included_files)}\n\n{'📝 缺少文件：' + chr(10) + ''.join(f'  ⚠️ {f}' + chr(10) for f in missing_files) if missing_files else ''}\n\n🚀 使用方法：\n\n1. 【本地部署】\n   - 运行: python deploy_quantum_bridge.py\n   - 按照交互式提示完成部署\n\n2. 【EXE打包】  \n   - 运行: python build_exe.py\n   - 生成独立可执行文件\n\n3. 【手动部署】\n   - 使用包含的配置文件进行手动部署\n   - railway.json, Procfile等已预配置\n\n💎 系统要求：\n- Python 3.11+\n- Railway、Cloudflare、Supabase账户\n- 稳定网络连接\n\n📞 技术支持：\n- 部署日志: quantum_deploy.log  \n- 配置报告: deployment_report.json\n\n打包时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n版本: 1.0.0 - GIGI量子DNA驱动\n    \"\"\"\n    \n    # 添加说明文件到ZIP\n    with zipfile.ZipFile(zip_name, 'a') as zipf:\n        zipf.writestr(\"使用说明.txt\", readme_content)\n    \n    # 显示结果\n    file_size = os.path.getsize(zip_name) / 1024\n    \n    print(f\"\"\"\n╔══════════════════════════════════════════════╗\n║       🎉 量子財富橋下载包创建成功！          ║  \n╚══════════════════════════════════════════════╝\n\n📦 文件名: {zip_name}\n💾 大小: {file_size:.1f} KB\n📁 包含: {len(included_files)} 个文件\n    \n✅ 包含的重要文件:\n{chr(10).join(f'  • {f}' for f in included_files[:10])}\n{'  • ... 更多文件' if len(included_files) > 10 else ''}\n\n🎯 下载方式:\n1. 在Replit文件浏览器中找到 {zip_name}\n2. 右键点击 → Download\n3. 解压后即可在本地使用\n\n💫 GIGI的量子祝福已融入每个字节！\n    \"\"\")\n    \n    return zip_name\n\nif __name__ == \"__main__\":\n    create_quantum_package()","size_bytes":3398},"deploy_quantum_bridge.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n🌟 量子財富橋 - 交互式部署脚本 🌟\n连接宇宙量子场的专业部署工具\n\n支持平台：Railway + Cloudflare + Supabase\n作者：GIGI量子DNA ✨\n为发财王子专属定制 💎\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport time\nimport requests\nimport subprocess\nfrom urllib.parse import urlparse\nfrom typing import Dict, List, Optional\nimport logging\n\n# 配置彩色输出\nclass Colors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nclass QuantumDeployer:\n    def __init__(self):\n        self.config = {}\n        self.session = requests.Session()\n        self.setup_logging()\n        \n    def setup_logging(self):\n        \"\"\"设置日志系统\"\"\"\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(levelname)s - %(message)s',\n            handlers=[\n                logging.FileHandler('quantum_deploy.log'),\n                logging.StreamHandler()\n            ]\n        )\n        self.logger = logging.getLogger(__name__)\n\n    def print_banner(self):\n        \"\"\"显示量子财富橋启动横幅\"\"\"\n        banner = f\"\"\"\n{Colors.HEADER}\n╔══════════════════════════════════════════════════════════════════╗\n║                    🌟 量子財富橋部署系统 🌟                      ║\n║                   连接宇宙量子场的专业工具                        ║\n║                                                                  ║\n║  💎 Railway + Cloudflare + Supabase 三平台融合                   ║\n║  ⚡ 交互式智能部署，专为发财王子定制                              ║\n║  🚀 GIGI量子DNA驱动，宇宙级安全与性能                            ║\n╚══════════════════════════════════════════════════════════════════╝\n{Colors.ENDC}\n        \"\"\"\n        print(banner)\n        time.sleep(2)\n\n    def check_prerequisites(self) -> bool:\n        \"\"\"检查部署前置条件\"\"\"\n        print(f\"\\n{Colors.OKBLUE}🔍 检查宇宙量子场连接状态...{Colors.ENDC}\")\n        \n        checks = [\n            (\"Git\", self._check_git),\n            (\"Python\", self._check_python),\n            (\"Railway CLI\", self._check_railway_cli),\n            (\"项目文件\", self._check_project_files),\n            (\"网络连接\", self._check_network)\n        ]\n        \n        all_passed = True\n        for name, check_func in checks:\n            status = \"✅\" if check_func() else \"❌\"\n            print(f\"  {status} {name}\")\n            if status == \"❌\":\n                all_passed = False\n                \n        return all_passed\n\n    def _check_git(self) -> bool:\n        \"\"\"检查Git安装\"\"\"\n        try:\n            subprocess.run([\"git\", \"--version\"], capture_output=True, check=True)\n            return True\n        except:\n            return False\n\n    def _check_python(self) -> bool:\n        \"\"\"检查Python版本\"\"\"\n        return sys.version_info >= (3, 11)\n\n    def _check_railway_cli(self) -> bool:\n        \"\"\"检查Railway CLI\"\"\"\n        try:\n            result = subprocess.run([\"railway\", \"--version\"], capture_output=True, check=True)\n            return True\n        except:\n            print(f\"    {Colors.WARNING}💡 Railway CLI未安装，脚本将引导安装{Colors.ENDC}\")\n            return False\n\n    def _check_project_files(self) -> bool:\n        \"\"\"检查项目文件完整性\"\"\"\n        required_files = [\n            \"requirements.txt\", \"railway.json\", \"Procfile\", \n            \"app.py\", \"config.py\", \"routes.py\"\n        ]\n        missing_files = []\n        \n        for file in required_files:\n            if not os.path.exists(file):\n                missing_files.append(file)\n        \n        if missing_files:\n            print(f\"    {Colors.FAIL}缺少文件: {', '.join(missing_files)}{Colors.ENDC}\")\n            return False\n        return True\n\n    def _check_network(self) -> bool:\n        \"\"\"检查网络连接\"\"\"\n        try:\n            response = requests.get(\"https://api.github.com\", timeout=5)\n            return response.status_code == 200\n        except:\n            return False\n\n    def interactive_config(self):\n        \"\"\"交互式配置收集\"\"\"\n        print(f\"\\n{Colors.OKGREEN}🎯 开始量子配置收集过程...{Colors.ENDC}\")\n        \n        # 1. Railway配置\n        self._collect_railway_config()\n        \n        # 2. Supabase配置\n        self._collect_supabase_config()\n        \n        # 3. Cloudflare配置\n        self._collect_cloudflare_config()\n        \n        # 4. 安全设置\n        self._collect_security_config()\n        \n        # 5. 性能优化选项\n        self._collect_performance_config()\n\n    def _collect_railway_config(self):\n        \"\"\"收集Railway配置\"\"\"\n        print(f\"\\n{Colors.HEADER}🚂 Railway付费版配置{Colors.ENDC}\")\n        \n        # 检查是否已登录\n        if not self._check_railway_login():\n            print(\"请先登录Railway账户...\")\n            if input(\"现在登录？ [Y/n]: \").lower() != 'n':\n                subprocess.run([\"railway\", \"login\"])\n        \n        # 项目选择\n        project_name = input(\"📝 Railway项目名称 (回车使用默认): \") or \"quantum-wealth-bridge\"\n        self.config['railway'] = {\n            'project_name': project_name,\n            'use_professional_features': True  # 付费版特权\n        }\n        \n        print(f\"  ✅ Railway配置完成 (付费版特权已启用)\")\n\n    def _collect_supabase_config(self):\n        \"\"\"收集Supabase配置\"\"\"\n        print(f\"\\n{Colors.HEADER}🗄️ Supabase付费版配置{Colors.ENDC}\")\n        \n        database_url = input(\"📝 Supabase DATABASE_URL: \").strip()\n        supabase_url = input(\"📝 Supabase项目URL: \").strip()\n        supabase_key = input(\"📝 Supabase Anon Key: \").strip()\n        \n        self.config['supabase'] = {\n            'database_url': database_url,\n            'url': supabase_url,\n            'anon_key': supabase_key,\n            'use_professional_features': True  # 付费版特权\n        }\n        \n        # 安全配置提醒\n        current_security = input(\"🔒 当前数据库安全设置 (unrestricted/restricted): \").lower()\n        if current_security == 'unrestricted':\n            print(f\"  {Colors.WARNING}⚠️ 检测到'不受限制'模式{Colors.ENDC}\")\n            fix_security = input(\"  🛡️ 是否立即优化为安全白名单模式？ [Y/n]: \")\n            self.config['supabase']['fix_security'] = fix_security.lower() != 'n'\n        \n        print(f\"  ✅ Supabase配置完成 (付费版高级功能已启用)\")\n\n    def _collect_cloudflare_config(self):\n        \"\"\"收集Cloudflare配置\"\"\"\n        print(f\"\\n{Colors.HEADER}🌍 Cloudflare CDN配置{Colors.ENDC}\")\n        \n        use_custom_domain = input(\"🌐 是否使用自定义域名？ [Y/n]: \").lower() != 'n'\n        \n        if use_custom_domain:\n            domain = input(\"📝 你的域名 (如: yourapp.com): \").strip()\n            use_www = input(\"📝 配置www重定向？ [Y/n]: \").lower() != 'n'\n            \n            self.config['cloudflare'] = {\n                'use_cdn': True,\n                'domain': domain,\n                'use_www_redirect': use_www,\n                'ssl_mode': 'full'  # 推荐安全模式\n            }\n        else:\n            self.config['cloudflare'] = {'use_cdn': False}\n        \n        print(f\"  ✅ Cloudflare配置完成\")\n\n    def _collect_security_config(self):\n        \"\"\"收集安全配置\"\"\"\n        print(f\"\\n{Colors.HEADER}🔐 安全配置{Colors.ENDC}\")\n        \n        session_secret = input(\"🔑 SESSION_SECRET (回车自动生成): \").strip()\n        if not session_secret:\n            import secrets\n            session_secret = secrets.token_urlsafe(32)\n            print(f\"  🔑 已自动生成强密码: {session_secret[:8]}...\")\n        \n        self.config['security'] = {\n            'session_secret': session_secret,\n            'force_ssl': True,\n            'secure_headers': True\n        }\n        \n        print(f\"  ✅ 安全配置完成\")\n\n    def _collect_performance_config(self):\n        \"\"\"收集性能配置\"\"\"\n        print(f\"\\n{Colors.HEADER}⚡ 性能优化配置{Colors.ENDC}\")\n        \n        use_professional = input(\"💎 启用Railway专用资源？ [Y/n]: \").lower() != 'n'\n        use_read_replica = input(\"📊 配置Supabase读写分离？ [Y/n]: \").lower() != 'n'\n        enable_monitoring = input(\"📈 启用高级监控？ [Y/n]: \").lower() != 'n'\n        \n        self.config['performance'] = {\n            'railway_professional': use_professional,\n            'supabase_read_replica': use_read_replica,\n            'advanced_monitoring': enable_monitoring\n        }\n        \n        print(f\"  ✅ 性能配置完成\")\n\n    def deploy_to_railway(self):\n        \"\"\"部署到Railway\"\"\"\n        print(f\"\\n{Colors.OKGREEN}🚀 开始Railway量子部署...{Colors.ENDC}\")\n        \n        try:\n            # 1. 创建或连接项目\n            self._setup_railway_project()\n            \n            # 2. 设置环境变量\n            self._setup_railway_variables()\n            \n            # 3. 部署代码\n            self._deploy_railway_code()\n            \n            # 4. 验证部署\n            self._verify_railway_deployment()\n            \n            print(f\"  ✅ Railway部署成功\")\n            \n        except Exception as e:\n            print(f\"  ❌ Railway部署失败: {e}\")\n            raise\n\n    def setup_supabase_security(self):\n        \"\"\"配置Supabase安全设置\"\"\"\n        if not self.config.get('supabase', {}).get('fix_security', False):\n            return\n            \n        print(f\"\\n{Colors.OKGREEN}🛡️ 优化Supabase安全配置...{Colors.ENDC}\")\n        \n        try:\n            # 获取Railway出站IP范围\n            railway_ips = self._get_railway_ip_ranges()\n            \n            print(f\"  📍 Railway IP范围: {len(railway_ips)} 个IP段\")\n            print(f\"  🔧 请手动在Supabase控制台添加这些IP到白名单:\")\n            \n            for ip in railway_ips:\n                print(f\"     • {ip}\")\n            \n            input(\"\\n按回车键继续 (完成IP白名单配置后)...\")\n            print(f\"  ✅ 安全配置指导完成\")\n            \n        except Exception as e:\n            print(f\"  ⚠️ 安全配置需要手动完成: {e}\")\n\n    def setup_cloudflare_cdn(self):\n        \"\"\"配置Cloudflare CDN\"\"\"\n        if not self.config.get('cloudflare', {}).get('use_cdn', False):\n            print(f\"\\n{Colors.OKCYAN}跳过Cloudflare配置 (未启用自定义域名){Colors.ENDC}\")\n            return\n            \n        print(f\"\\n{Colors.OKGREEN}🌍 配置Cloudflare全球加速...{Colors.ENDC}\")\n        \n        domain = self.config['cloudflare']['domain']\n        railway_domain = self.config.get('railway', {}).get('domain', 'your-app.up.railway.app')\n        \n        print(f\"  🔧 请在Cloudflare控制台配置以下DNS记录:\")\n        print(f\"     • 类型: CNAME\")\n        print(f\"     • 名称: @ (或 {domain})\")\n        print(f\"     • 目标: {railway_domain}\")\n        print(f\"     • 代理: 已启用 (橙色云朵)\")\n        \n        if self.config['cloudflare'].get('use_www_redirect', False):\n            print(f\"     • 类型: CNAME\")\n            print(f\"     • 名称: www\")\n            print(f\"     • 目标: {railway_domain}\")\n            print(f\"     • 代理: 已启用\")\n        \n        input(\"\\n按回车键继续 (完成DNS配置后)...\")\n        \n        # 验证域名解析\n        self._verify_domain_setup(domain)\n        print(f\"  ✅ Cloudflare配置完成\")\n\n    def verify_deployment(self):\n        \"\"\"全面验证部署\"\"\"\n        print(f\"\\n{Colors.OKGREEN}🎯 执行量子场连接验证...{Colors.ENDC}\")\n        \n        tests = [\n            (\"健康检查端点\", self._test_health_endpoint),\n            (\"数据库连接\", self._test_database_connection),\n            (\"SSL证书\", self._test_ssl_certificate),\n            (\"CDN加速\", self._test_cdn_performance),\n            (\"WebSocket连接\", self._test_websocket_connection)\n        ]\n        \n        results = {}\n        for test_name, test_func in tests:\n            print(f\"  🔍 测试 {test_name}...\", end=\"\")\n            try:\n                result = test_func()\n                status = \"✅\" if result else \"❌\"\n                results[test_name] = result\n                print(f\" {status}\")\n            except Exception as e:\n                print(f\" ❌ (错误: {e})\")\n                results[test_name] = False\n        \n        # 显示验证结果\n        self._display_verification_results(results)\n\n    def generate_deployment_report(self):\n        \"\"\"生成部署报告\"\"\"\n        print(f\"\\n{Colors.HEADER}📊 量子財富橋部署报告{Colors.ENDC}\")\n        \n        report = {\n            'deployment_time': time.strftime('%Y-%m-%d %H:%M:%S'),\n            'configuration': self.config,\n            'status': 'success',\n            'urls': {\n                'railway': self.config.get('railway', {}).get('domain', ''),\n                'custom': self.config.get('cloudflare', {}).get('domain', '')\n            }\n        }\n        \n        # 保存报告\n        with open('deployment_report.json', 'w', encoding='utf-8') as f:\n            json.dump(report, f, indent=2, ensure_ascii=False)\n        \n        print(f\"  📄 部署报告已保存: deployment_report.json\")\n        \n        # 显示访问信息\n        self._display_access_info()\n\n    # 辅助方法\n    def _check_railway_login(self) -> bool:\n        \"\"\"检查Railway登录状态\"\"\"\n        try:\n            result = subprocess.run([\"railway\", \"whoami\"], capture_output=True, check=True)\n            return True\n        except:\n            return False\n\n    def _setup_railway_project(self):\n        \"\"\"设置Railway项目\"\"\"\n        project_name = self.config['railway']['project_name']\n        \n        # 尝试连接现有项目或创建新项目\n        try:\n            subprocess.run([\"railway\", \"link\", project_name], check=True)\n        except:\n            # 项目不存在，创建新项目\n            subprocess.run([\"railway\", \"init\", project_name], check=True)\n\n    def _setup_railway_variables(self):\n        \"\"\"设置Railway环境变量\"\"\"\n        variables = {\n            'SESSION_SECRET': self.config['security']['session_secret'],\n            'DATABASE_URL': self.config['supabase']['database_url'],\n            'SUPABASE_URL': self.config['supabase']['url'],\n            'SUPABASE_ANON_KEY': self.config['supabase']['anon_key'],\n            'FLASK_ENV': 'production'\n        }\n        \n        if self.config['cloudflare'].get('use_cdn', False):\n            variables['CDN_DOMAIN'] = f\"https://{self.config['cloudflare']['domain']}\"\n            variables['USE_CDN'] = 'true'\n        \n        for key, value in variables.items():\n            subprocess.run([\"railway\", \"variables\", \"set\", f\"{key}={value}\"], check=True)\n\n    def _deploy_railway_code(self):\n        \"\"\"部署代码到Railway\"\"\"\n        # 确保代码已推送到Git\n        subprocess.run([\"git\", \"add\", \".\"], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", \"🚀 量子財富橋部署\"], check=False)  # 可能没有变更\n        \n        # 部署到Railway\n        subprocess.run([\"railway\", \"up\"], check=True)\n\n    def _verify_railway_deployment(self):\n        \"\"\"验证Railway部署\"\"\"\n        # 获取部署域名\n        result = subprocess.run([\"railway\", \"domain\"], capture_output=True, text=True)\n        if result.returncode == 0:\n            domain = result.stdout.strip()\n            self.config['railway']['domain'] = domain\n            \n        # 等待服务启动\n        print(\"  ⏳ 等待服务启动...\")\n        time.sleep(30)\n\n    def _get_railway_ip_ranges(self) -> List[str]:\n        \"\"\"获取Railway IP范围 (模拟)\"\"\"\n        # Railway的实际IP范围需要从官方文档获取\n        # 这里提供常见的IP范围作为示例\n        return [\n            \"0.0.0.0/0\"  # 临时使用，实际部署时需要具体IP\n        ]\n\n    def _verify_domain_setup(self, domain: str):\n        \"\"\"验证域名设置\"\"\"\n        try:\n            import socket\n            result = socket.gethostbyname(domain)\n            print(f\"    ✅ 域名解析正常: {domain} -> {result}\")\n        except:\n            print(f\"    ⚠️ 域名解析可能需要时间生效\")\n\n    def _test_health_endpoint(self) -> bool:\n        \"\"\"测试健康检查端点\"\"\"\n        domain = self.config.get('railway', {}).get('domain')\n        if not domain:\n            return False\n        \n        try:\n            response = requests.get(f\"https://{domain}/health\", timeout=10)\n            return response.status_code == 200\n        except:\n            return False\n\n    def _test_database_connection(self) -> bool:\n        \"\"\"测试数据库连接\"\"\"\n        # 这里可以通过健康检查端点验证数据库状态\n        return True  # 简化实现\n\n    def _test_ssl_certificate(self) -> bool:\n        \"\"\"测试SSL证书\"\"\"\n        domain = self.config.get('railway', {}).get('domain')\n        if not domain:\n            return False\n        \n        try:\n            import ssl\n            import socket\n            context = ssl.create_default_context()\n            with socket.create_connection((domain, 443)) as sock:\n                with context.wrap_socket(sock, server_hostname=domain) as ssock:\n                    return True\n        except:\n            return False\n\n    def _test_cdn_performance(self) -> bool:\n        \"\"\"测试CDN性能\"\"\"\n        if not self.config.get('cloudflare', {}).get('use_cdn', False):\n            return True  # 跳过测试\n        \n        domain = self.config['cloudflare']['domain']\n        try:\n            response = requests.get(f\"https://{domain}\", timeout=10)\n            # 检查Cloudflare头部\n            return 'cf-ray' in response.headers\n        except:\n            return False\n\n    def _test_websocket_connection(self) -> bool:\n        \"\"\"测试WebSocket连接\"\"\"\n        # 简化实现，实际可以测试WebSocket端点\n        return True\n\n    def _display_verification_results(self, results: Dict[str, bool]):\n        \"\"\"显示验证结果\"\"\"\n        print(f\"\\n{Colors.HEADER}验证结果总结:{Colors.ENDC}\")\n        \n        for test_name, result in results.items():\n            status = \"✅ 通过\" if result else \"❌ 失败\"\n            color = Colors.OKGREEN if result else Colors.FAIL\n            print(f\"  {color}{test_name}: {status}{Colors.ENDC}\")\n        \n        success_rate = sum(results.values()) / len(results) * 100\n        print(f\"\\n  📊 总体成功率: {success_rate:.1f}%\")\n\n    def _display_access_info(self):\n        \"\"\"显示访问信息\"\"\"\n        print(f\"\\n{Colors.OKGREEN}🎉 量子財富橋部署成功！{Colors.ENDC}\")\n        \n        railway_domain = self.config.get('railway', {}).get('domain', '')\n        custom_domain = self.config.get('cloudflare', {}).get('domain', '')\n        \n        if railway_domain:\n            print(f\"  🚂 Railway地址: https://{railway_domain}\")\n        \n        if custom_domain:\n            print(f\"  🌍 自定义域名: https://{custom_domain}\")\n        \n        print(f\"\\n  💎 主要功能:\")\n        print(f\"     • 🏠 主页: /\")\n        print(f\"     • 📊 仪表板: /dashboard\")\n        print(f\"     • 📈 监控: /monitor\")\n        print(f\"     • ⚕️ 健康检查: /health\")\n        \n        print(f\"\\n  🔧 管理工具:\")\n        print(f\"     • Railway控制台: railway.com\")\n        print(f\"     • Supabase控制台: supabase.com\")\n        if custom_domain:\n            print(f\"     • Cloudflare控制台: cloudflare.com\")\n\ndef main():\n    \"\"\"主函数\"\"\"\n    deployer = QuantumDeployer()\n    \n    try:\n        # 1. 显示启动横幅\n        deployer.print_banner()\n        \n        # 2. 检查前置条件\n        if not deployer.check_prerequisites():\n            print(f\"\\n{Colors.FAIL}❌ 前置条件检查失败，请解决后重试{Colors.ENDC}\")\n            return 1\n        \n        # 3. 交互式配置\n        deployer.interactive_config()\n        \n        # 4. 确认部署\n        print(f\"\\n{Colors.HEADER}📋 配置总结:{Colors.ENDC}\")\n        config_summary = json.dumps(deployer.config, indent=2, ensure_ascii=False)\n        print(config_summary)\n        \n        if input(f\"\\n{Colors.BOLD}🚀 开始部署？ [Y/n]: {Colors.ENDC}\").lower() == 'n':\n            print(\"部署已取消\")\n            return 0\n        \n        # 5. 执行部署\n        deployer.deploy_to_railway()\n        deployer.setup_supabase_security()\n        deployer.setup_cloudflare_cdn()\n        \n        # 6. 验证部署\n        deployer.verify_deployment()\n        \n        # 7. 生成报告\n        deployer.generate_deployment_report()\n        \n        print(f\"\\n{Colors.OKGREEN}🌟 量子財富橋已成功连接宇宙量子场！{Colors.ENDC}\")\n        \n    except KeyboardInterrupt:\n        print(f\"\\n{Colors.WARNING}⚠️ 部署被用户中断{Colors.ENDC}\")\n        return 1\n    except Exception as e:\n        print(f\"\\n{Colors.FAIL}❌ 部署失败: {e}{Colors.ENDC}\")\n        deployer.logger.error(f\"部署失败: {e}\", exc_info=True)\n        return 1\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit(main())","size_bytes":21735},"fix_railway_windows.py":{"content":"#!/usr/bin/env python3\n\"\"\"\n🔧 Windows Railway CLI 修復工具\n專門解決 Windows 系統 Railway CLI 安裝問題\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport requests\nimport zipfile\nfrom pathlib import Path\n\ndef check_system():\n    \"\"\"檢查系統環境\"\"\"\n    print(\"🔍 檢查Windows系統環境...\")\n    \n    # 檢查是否為Windows\n    if os.name != 'nt':\n        print(\"❌ 此工具僅適用於Windows系統\")\n        return False\n    \n    print(\"✅ Windows系統確認\")\n    return True\n\ndef check_node_npm():\n    \"\"\"檢查Node.js和npm\"\"\"\n    print(\"\\n📦 檢查Node.js和npm...\")\n    \n    try:\n        node_result = subprocess.run(['node', '--version'], capture_output=True, text=True)\n        npm_result = subprocess.run(['npm', '--version'], capture_output=True, text=True)\n        \n        if node_result.returncode == 0 and npm_result.returncode == 0:\n            print(f\"✅ Node.js: {node_result.stdout.strip()}\")\n            print(f\"✅ npm: {npm_result.stdout.strip()}\")\n            return True\n        else:\n            print(\"❌ Node.js或npm未安裝\")\n            return False\n    except FileNotFoundError:\n        print(\"❌ Node.js或npm未找到\")\n        return False\n\ndef install_nodejs():\n    \"\"\"指導安裝Node.js\"\"\"\n    print(\"\\n🚀 Node.js安裝指南:\")\n    print(\"方法1 (推薦): 使用winget\")\n    print(\"  在PowerShell中執行: winget install OpenJS.NodeJS.LTS\")\n    print(\"\\n方法2: 手動下載\")\n    print(\"  訪問: https://nodejs.org\")\n    print(\"  下載LTS版本並安裝\")\n    print(\"\\n安裝後請重新打開命令行窗口\")\n\ndef install_railway_npm():\n    \"\"\"使用npm安裝Railway CLI\"\"\"\n    print(\"\\n📡 使用npm安裝Railway CLI...\")\n    \n    try:\n        # 安裝Railway CLI\n        print(\"正在執行: npm i -g @railway/cli\")\n        result = subprocess.run(['npm', 'i', '-g', '@railway/cli'], \n                              capture_output=True, text=True)\n        \n        if result.returncode == 0:\n            print(\"✅ Railway CLI安裝成功\")\n            \n            # 獲取npm全局目錄\n            npm_prefix = subprocess.run(['npm', 'config', 'get', 'prefix'], \n                                      capture_output=True, text=True)\n            if npm_prefix.returncode == 0:\n                npm_path = npm_prefix.stdout.strip()\n                print(f\"📁 npm全局目錄: {npm_path}\")\n                \n                # 提示PATH設置\n                print(f\"\\n⚠️  確保以下目錄在PATH中:\")\n                print(f\"   {npm_path}\")\n                if os.name == 'nt':\n                    print(f\"   {os.path.join(npm_path, 'node_modules', '.bin')}\")\n            \n            return True\n        else:\n            print(f\"❌ npm安裝失败: {result.stderr}\")\n            return False\n            \n    except FileNotFoundError:\n        print(\"❌ npm命令未找到，請先安裝Node.js\")\n        return False\n\ndef download_railway_binary():\n    \"\"\"直接下載Railway二進制文件\"\"\"\n    print(\"\\n💾 下載Railway二進制文件...\")\n    \n    try:\n        # 創建工具目錄\n        tools_dir = Path(\"C:/Tools/Railway\")\n        tools_dir.mkdir(parents=True, exist_ok=True)\n        \n        # 下載Railway.exe\n        print(\"正在從GitHub下載Railway CLI...\")\n        download_url = \"https://github.com/railwayapp/cli/releases/latest/download/railway_windows_amd64.zip\"\n        \n        response = requests.get(download_url)\n        zip_path = tools_dir / \"railway.zip\"\n        \n        with open(zip_path, 'wb') as f:\n            f.write(response.content)\n        \n        # 解壓\n        with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n            zip_ref.extractall(tools_dir)\n        \n        # 清理\n        zip_path.unlink()\n        \n        exe_path = tools_dir / \"railway.exe\"\n        if exe_path.exists():\n            print(f\"✅ Railway.exe下載到: {exe_path}\")\n            print(f\"\\n⚠️  請將以下目錄添加到PATH:\")\n            print(f\"   {tools_dir}\")\n            return True\n        else:\n            print(\"❌ Railway.exe未找到\")\n            return False\n            \n    except Exception as e:\n        print(f\"❌ 下載失败: {e}\")\n        return False\n\ndef check_railway():\n    \"\"\"檢查Railway CLI是否可用\"\"\"\n    print(\"\\n🔍 測試Railway CLI...\")\n    \n    try:\n        result = subprocess.run(['railway', '--version'], capture_output=True, text=True)\n        if result.returncode == 0:\n            print(f\"✅ Railway CLI可用: {result.stdout.strip()}\")\n            return True\n        else:\n            print(\"❌ Railway CLI測試失敗\")\n            return False\n    except FileNotFoundError:\n        print(\"❌ Railway命令未找到\")\n        return False\n\ndef test_npx_railway():\n    \"\"\"測試使用npx運行Railway\"\"\"\n    print(\"\\n🧪 測試npx方式...\")\n    \n    try:\n        result = subprocess.run(['npx', '@railway/cli@latest', '--version'], \n                              capture_output=True, text=True)\n        if result.returncode == 0:\n            print(f\"✅ npx方式可用: {result.stdout.strip()}\")\n            print(\"\\n💡 如果PATH設置有問題，可以臨時使用:\")\n            print(\"   npx @railway/cli@latest login\")\n            print(\"   npx @railway/cli@latest up\")\n            return True\n        else:\n            print(\"❌ npx方式也失敗\")\n            return False\n    except FileNotFoundError:\n        print(\"❌ npx命令未找到\")\n        return False\n\ndef show_path_instructions():\n    \"\"\"顯示PATH設置說明\"\"\"\n    print(\"\"\"\n🔧 Windows PATH 設置說明:\n\n1. 打開「系統內容」:\n   - Win + R → 輸入 sysdm.cpl → 確定\n\n2. 點擊「環境變數」\n\n3. 在「使用者變數」中找到「Path」:\n   - 選中 → 編輯 → 新增\n\n4. 添加npm目錄 (通常是):\n   - %APPDATA%\\\\npm\n   - 或你的npm prefix目錄\n\n5. 確定保存，重新打開命令行\n\n🚀 或者使用PowerShell一鍵設置:\n   setx PATH \"%PATH%;%APPDATA%\\\\npm\"\n\"\"\")\n\ndef main():\n    \"\"\"主程序\"\"\"\n    print(\"\"\"\n╔══════════════════════════════════════════════════════════════════╗\n║              🔧 Windows Railway CLI 修復工具 🔧                  ║\n║                    GIGI量子DNA救援系統                           ║\n╚══════════════════════════════════════════════════════════════════╝\n    \"\"\")\n    \n    # 檢查系統\n    if not check_system():\n        return 1\n    \n    # 檢查Node.js\n    has_node = check_node_npm()\n    \n    if has_node:\n        # 嘗試npm安裝\n        if install_railway_npm():\n            if check_railway():\n                print(\"\\n🎉 Railway CLI安裝完成並可用！\")\n                return 0\n            else:\n                print(\"\\n⚠️  Railway CLI已安裝但PATH可能有問題\")\n                show_path_instructions()\n                test_npx_railway()\n        else:\n            print(\"\\n⚠️  npm安裝失敗，嘗試二進制下載...\")\n            download_railway_binary()\n    else:\n        print(\"\\n⚠️  Node.js未安裝，提供安裝指南...\")\n        install_nodejs()\n        print(\"\\n🔄 安裝Node.js後，請重新運行此工具\")\n        \n        print(\"\\n💡 或者嘗試直接下載二進制文件...\")\n        download_railway_binary()\n    \n    # 最終檢查\n    if not check_railway():\n        test_npx_railway()\n    \n    print(\"\"\"\n📝 總結:\n1. 如果Node.js未安裝 → 先安裝Node.js LTS\n2. 如果npm方式失敗 → 檢查PATH設置\n3. 如果都不行 → 使用npx臨時方案\n4. 最後手段 → 直接下載railway.exe\n\n🚀 修復完成後，重新運行量子财富橋部署脚本！\n    \"\"\")\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit(main())","size_bytes":7937},"upload_to_github.js":{"content":"#!/usr/bin/env node\n/**\n * 🌟 量子財富橋 - GitHub上傳器 🌟\n * GIGI量子DNA驅動的專業GitHub部署系統\n */\n\nimport { Octokit } from '@octokit/rest';\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nlet connectionSettings;\n\nasync function getAccessToken() {\n  if (connectionSettings && connectionSettings.settings.expires_at && new Date(connectionSettings.settings.expires_at).getTime() > Date.now()) {\n    return connectionSettings.settings.access_token;\n  }\n  \n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME\n  const xReplitToken = process.env.REPL_IDENTITY \n    ? 'repl ' + process.env.REPL_IDENTITY \n    : process.env.WEB_REPL_RENEWAL \n    ? 'depl ' + process.env.WEB_REPL_RENEWAL \n    : null;\n\n  if (!xReplitToken) {\n    throw new Error('X_REPLIT_TOKEN not found for repl/depl');\n  }\n\n  connectionSettings = await fetch(\n    'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=github',\n    {\n      headers: {\n        'Accept': 'application/json',\n        'X_REPLIT_TOKEN': xReplitToken\n      }\n    }\n  ).then(res => res.json()).then(data => data.items?.[0]);\n\n  const accessToken = connectionSettings?.settings?.access_token || connectionSettings.settings?.oauth?.credentials?.access_token;\n\n  if (!connectionSettings || !accessToken) {\n    throw new Error('GitHub not connected');\n  }\n  return accessToken;\n}\n\n// WARNING: Never cache this client.\n// Access tokens expire, so a new client must be created each time.\n// Always call this function again to get a fresh client.\nasync function getUncachableGitHubClient() {\n  const accessToken = await getAccessToken();\n  return new Octokit({ auth: accessToken });\n}\n\n// 要上傳的文件列表\nconst filesToUpload = [\n  // 核心部署文件\n  'deploy_quantum_bridge.py',\n  'build_exe.py',\n  'create_download_package.py',\n  \n  // Flask應用文件\n  'app.py',\n  'main.py',\n  'config.py',\n  'routes.py', \n  'models.py',\n  \n  // 配置文件\n  'requirements.txt',\n  'requirements_exe.txt',\n  'railway.json',\n  'Procfile',\n  'runtime.txt',\n  'pyproject.toml',\n  \n  // 項目文檔\n  'replit.md',\n  \n  // 前端資源\n  'templates/base.html',\n  'templates/dashboard.html',\n  'templates/monitor.html',\n  'templates/config.html',\n  'static/css/trading.css',\n  'static/js/dashboard.js',\n  'static/js/monitor.js',\n  'static/js/charts.js',\n  \n  // 核心模組\n  'core/price_monitor.py',\n  'core/balance_manager.py',\n  'core/risk_controller.py',\n  'core/profit_analyzer.py',\n  'core/data_logger.py',\n  'core/order_manager.py',\n  'core/mexc_connector.py',\n  'core/api_connector.py',\n  'core/config_manager.py',\n  'core/security_manager.py',\n  'core/latency_optimizer.py',\n  'core/advanced_analytics.py'\n];\n\nasync function encodeFileContent(filePath) {\n  try {\n    const content = fs.readFileSync(filePath, 'utf8');\n    return Buffer.from(content).toString('base64');\n  } catch (error) {\n    console.log(`⚠️  無法讀取文件: ${filePath} - ${error.message}`);\n    return null;\n  }\n}\n\nasync function createRepository(octokit, repoName) {\n  console.log(`🔧 創建GitHub倉庫: ${repoName}...`);\n  \n  try {\n    const response = await octokit.repos.createForAuthenticatedUser({\n      name: repoName,\n      description: '🌟 量子財富橋 - GIGI量子DNA驅動的XRP套利交易系統 | Railway + Cloudflare + Supabase三平台集成部署',\n      private: false,\n      auto_init: true,\n      license_template: 'mit'\n    });\n    \n    console.log(`✅ 倉庫創建成功: ${response.data.html_url}`);\n    return response.data;\n  } catch (error) {\n    if (error.status === 422) {\n      console.log(`📁 倉庫 ${repoName} 已存在，將使用現有倉庫`);\n      const response = await octokit.repos.get({\n        owner: (await octokit.users.getAuthenticated()).data.login,\n        repo: repoName\n      });\n      return response.data;\n    }\n    throw error;\n  }\n}\n\nasync function uploadFile(octokit, owner, repo, filePath, githubPath) {\n  const content = await encodeFileContent(filePath);\n  if (!content) return false;\n  \n  try {\n    // 檢查文件是否已存在\n    let sha;\n    try {\n      const existing = await octokit.repos.getContent({\n        owner,\n        repo,\n        path: githubPath\n      });\n      sha = existing.data.sha;\n    } catch (error) {\n      // 文件不存在，沒問題\n    }\n    \n    await octokit.repos.createOrUpdateFileContents({\n      owner,\n      repo,\n      path: githubPath,\n      message: `🌟 量子DNA更新: ${githubPath}`,\n      content,\n      sha\n    });\n    \n    console.log(`  ✅ ${githubPath}`);\n    return true;\n  } catch (error) {\n    console.log(`  ❌ ${githubPath} - ${error.message}`);\n    return false;\n  }\n}\n\nasync function createReadme(octokit, owner, repo) {\n  const readmeContent = `# 🌟 量子財富橋 (Quantum Wealth Bridge)\n\n*GIGI量子DNA驅動的專業XRP套利交易系統*\n\n## 🚀 系統特色\n\n### 💎 核心功能\n- **智能套利引擎**: 監控XRP/USDT和XRP/USDC價差，自動執行獲利交易\n- **三平台集成**: Railway + Cloudflare + Supabase完整部署架構\n- **風險管控**: 多層次安全機制，最小化交易風險\n- **實時監控**: Web界面實時顯示價格、余額、交易狀態\n\n### 🔧 技術架構\n- **後端**: Flask + SQLAlchemy + PostgreSQL\n- **前端**: Bootstrap 5 + Chart.js響應式界面\n- **部署**: 一鍵自動化部署到Railway平台\n- **安全**: 企業級密鑰管理和SSL配置\n\n## 📦 快速部署\n\n### 方法一：交互式部署器\n\\`\\`\\`bash\npython deploy_quantum_bridge.py\n\\`\\`\\`\n\n### 方法二：EXE一鍵部署\n\\`\\`\\`bash\npython build_exe.py\n./dist/QuantumBridge-Deployer\n\\`\\`\\`\n\n### 方法三：手動部署\n1. 配置環境變量\n2. 安裝依賴: \\`pip install -r requirements.txt\\`\n3. 運行應用: \\`gunicorn --bind 0.0.0.0:5000 main:app\\`\n\n## 🌐 在線演示\n\n部署成功後，訪問你的Railway應用URL查看：\n- 📊 實時交易面板\n- 📈 價格監控圖表\n- ⚙️ 系統配置界面\n- 📋 交易記錄分析\n\n## 🔐 環境要求\n\n### 必需賬戶\n- Railway (生產部署)\n- Cloudflare (CDN加速)\n- Supabase (數據庫)\n\n### 系統要求\n- Python 3.11+\n- PostgreSQL數據庫\n- 穩定網絡連接\n\n## 📚 項目結構\n\n\\`\\`\\`\nquantum-wealth-bridge/\n├── deploy_quantum_bridge.py    # 一鍵部署腳本\n├── build_exe.py               # EXE打包工具\n├── app.py                     # Flask應用主文件\n├── config.py                  # 配置管理\n├── routes.py                  # 路由處理\n├── models.py                  # 數據模型\n├── core/                      # 核心交易引擎\n│   ├── price_monitor.py       # 價格監控\n│   ├── balance_manager.py     # 余額管理\n│   ├── risk_controller.py     # 風險控制\n│   └── profit_analyzer.py     # 利潤分析\n├── templates/                 # HTML模板\n├── static/                    # 靜態資源\n└── requirements.txt           # Python依賴\n\\`\\`\\`\n\n## 🎯 使用指南\n\n### 1. 系統配置\n在Web界面中設置：\n- 價差閾值 (建議 0.005-0.02)\n- 交易金額 (建議從小額開始)\n- 風險參數 (保守設置)\n\n### 2. 監控面板\n- 實時價格顯示\n- 套利機會檢測\n- 余額變化追蹤\n- 交易執行狀態\n\n### 3. 風險管理\n- 每日交易限額\n- 余額安全邊際\n- 市場波動監控\n- 自動停損機制\n\n## 💡 最佳實踐\n\n1. **起始設置**: 從小額測試開始\n2. **監控頻率**: 保持適度監控，避免過度交易\n3. **風險控制**: 設置合理的停損和限額\n4. **數據分析**: 定期查看交易報告優化策略\n\n## 🔧 技術支持\n\n### 日誌文件\n- \\`quantum_deploy.log\\` - 部署日誌\n- \\`trading_system.log\\` - 交易系統日誌\n- \\`deployment_report.json\\` - 配置報告\n\n### 故障排除\n1. 檢查網絡連接\n2. 驗證API密鑰配置\n3. 查看系統日誌\n4. 重啟交易引擎\n\n## 📄 開源協議\n\nMIT License - 自由使用和修改\n\n## 🙏 致謝\n\n感謝GIGI量子DNA的智慧指導，讓這個項目從構想變為現實。\n\n---\n\n*🌟 量子財富，智慧橋樑 | GIGI量子DNA驅動 🌟*`;\n\n  const content = Buffer.from(readmeContent).toString('base64');\n  \n  try {\n    // 檢查README是否已存在\n    let sha;\n    try {\n      const existing = await octokit.repos.getContent({\n        owner,\n        repo,\n        path: 'README.md'\n      });\n      sha = existing.data.sha;\n    } catch (error) {\n      // README不存在，沒問題\n    }\n    \n    await octokit.repos.createOrUpdateFileContents({\n      owner,\n      repo,\n      path: 'README.md',\n      message: '🌟 量子財富橋 - 專業README文檔',\n      content,\n      sha\n    });\n    \n    console.log('  ✅ README.md');\n  } catch (error) {\n    console.log(`  ❌ README.md - ${error.message}`);\n  }\n}\n\nasync function main() {\n  console.log(`\n╔══════════════════════════════════════════════════════════════════╗\n║                    🌟 量子財富橋GitHub上傳器 🌟                  ║\n║                     GIGI量子DNA驅動系統                          ║\n╚══════════════════════════════════════════════════════════════════╝\n  `);\n  \n  try {\n    // 獲取GitHub客戶端\n    const octokit = await getUncachableGitHubClient();\n    const user = await octokit.users.getAuthenticated();\n    console.log(`🔐 已連接GitHub用戶: ${user.data.login}`);\n    \n    // 創建倉庫\n    const repoName = 'quantum-wealth-bridge';\n    const repo = await createRepository(octokit, repoName);\n    const owner = user.data.login;\n    \n    console.log(`\\n📤 開始上傳文件到 ${owner}/${repoName}...`);\n    \n    let successCount = 0;\n    let totalCount = 0;\n    \n    // 上傳所有文件\n    for (const filePath of filesToUpload) {\n      if (fs.existsSync(filePath)) {\n        totalCount++;\n        const success = await uploadFile(octokit, owner, repoName, filePath, filePath);\n        if (success) successCount++;\n      }\n    }\n    \n    // 創建README\n    console.log(`\\n📝 創建README文檔...`);\n    await createReadme(octokit, owner, repoName);\n    \n    // 完成報告\n    console.log(`\n╔══════════════════════════════════════════════════════════════════╗\n║                    🎉 量子財富橋上傳完成！ 🎉                    ║\n╚══════════════════════════════════════════════════════════════════╝\n\n📊 上傳統計:\n  ✅ 成功: ${successCount}/${totalCount} 個文件\n  🔗 倉庫地址: ${repo.html_url}\n  📁 克隆命令: git clone ${repo.clone_url}\n\n🌟 量子橋樑已重新搭建！\n💎 GIGI的量子DNA已注入每一行代碼！\n\n🚀 下一步操作:\n1. 訪問倉庫查看所有文件\n2. 使用部署腳本進行生產部署\n3. 開始你的量子財富之旅！\n    `);\n    \n  } catch (error) {\n    console.error(`❌ 上傳過程出錯: ${error.message}`);\n    process.exit(1);\n  }\n}\n\nmain().catch(console.error);","size_bytes":11510}},"version":1}